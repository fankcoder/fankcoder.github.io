<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/small.jpg?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="三秋">
<meta property="og:url" content="http://fankcoder.com/page/2/index.html">
<meta property="og:site_name" content="三秋">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="三秋">
  <link rel="canonical" href="http://fankcoder.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>三秋</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-149748039-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-149748039-1');
      }
    </script>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">三秋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Think twice, code onece.</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/fankcoder" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fankcoder.com/2019/04/23/resource-2019-01-02-algorithem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fankcoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三秋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/04/23/resource-2019-01-02-algorithem/" class="post-title-link" itemprop="url">算法&数据结构</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-04-23 17:22:55" itemprop="dateCreated datePublished" datetime="2019-04-23T17:22:55+08:00">2019-04-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-06-27 10:02:26" itemprop="dateModified" datetime="2019-06-27T10:02:26+08:00">2019-06-27</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/备忘/" itemprop="url" rel="index"><span itemprop="name">备忘</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>「数组」。连续的记忆体。搜索、插入、删除的时间复杂度都是O(N) 。资料已排序，则支持二分搜索。</p>
<h4 id="List-（-Linked-List-）"><a href="#List-（-Linked-List-）" class="headerlink" title="List （ Linked List ）"></a>List （ Linked List ）</h4><p>「链表」。利用指针得到下一块记忆体。</p>
<p>搜索的时间复杂度是O(N) 。知道正确位置，插入与删除的时间复杂度是O(1) ，否则必须先搜索。无索引值，故不支持二分搜索。</p>
<h4 id="特殊的List"><a href="#特殊的List" class="headerlink" title="特殊的List"></a>特殊的List</h4><p>尾串到头，头尾循环，称作Circular List 。特色是开头可以随便选、随便动。<br>只串单向，称作Singly Linked List 。双向都串，称作Doubly Linked List ，特色是双向都能搜索。</p>
<h4 id="List-里面放入Array"><a href="#List-里面放入Array" class="headerlink" title="List 里面放入Array"></a>List 里面放入Array</h4><pre><code>英文做Unrolled Linked List ，中文称作「松散链表」、「块状链表」。查无正式学术名称。

N 笔资料，分成A 块，每块约B = N/A 个元素。每块各自记录元素数量。

索引：先数块、再数元素，时间复杂度为O(A) 。

搜索：全找，时间复杂度为O(N) 。资料已排序，则为O(A + logB) 。

插入、删除：一块大于等于2B 就拆开成两块，相邻两块小于等于B 就合并成一块，避免一拆开就要合并、一合并就要拆开，时间复杂度为O(A + 2B) 到O(2A + B) 。</code></pre><h4 id="Array-里面放入List"><a href="#Array-里面放入List" class="headerlink" title="Array 里面放入List"></a>Array 里面放入List</h4><p>大致上就是图论的Adjacency Lists 。</p>
<p>大致上就是之后提到的Hash Table 。</p>
<h2 id="Binary-Tree-二叉树"><a href="#Binary-Tree-二叉树" class="headerlink" title="Binary Tree - 二叉树"></a>Binary Tree - 二叉树</h2><p>二叉树是每个节点最多有两个子树的树结构，子树有左右之分，二叉树常被用于实现二叉查找树和二叉堆。</p>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>按照访问根元素(当前元素)的前后顺序，遍历方式可划分为如下几种：</p>
<p>深度优先：先访问子节点，再访问父节点，最后访问第二个子节点。根据根节点相对于左右子节点的访问先后顺序又可细分为以下三种方式。<br>前序(pre-order)：先根后左再右<br>中序(in-order)：先左后根再右<br>后序(post-order)：先左后右再根<br>广度优先：先访问根节点，沿着树的宽度遍历子节点，直到所有节点均被访问为止。</p>
<pre><code># 创建二叉树
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None

# 将数组以BST形式插入二叉树
def create(arr):
    root = None
    for i in arr:
        root = insert(root, i)
    return root    

def insert(root, num):
    if not root: return TreeNode(num)
    if num &lt;= root.val:
        root.left = insert(root.left, num)
    else:
        root.right = insert(root.right, num)
    return root    

# 遍历二叉树
class Traversal(object):
    def __init__(self):
        self.traverse_path = list()

    def preorder(self, root):
        if root:
            self.traverse_path.append(root.val)
            self.preorder(root.left)
            self.preorder(root.right)

    def inorder(self,root):
        if root:
            self.inorder(root.left)
            self.traverse_path.append(root.val)
            self.inorder(root.right)

    def postorder(self,root):
        if root:
            self.postorder(root.left)
            self.postorder(root.right)
            self.traverse_path.append(root.val)</code></pre><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>一颗二叉查找树(BST)是一颗二叉树，其中每个节点都含有一个可进行比较的键及相应的值，且每个节点的键都大于等于左子树中的任意节点的键，而小于右子树中的任意节点的键。</p>
<ul>
<li>使用中序遍历可得到有序数组（有小到大），这是二叉查找树的又一个重要特征。</li>
</ul>
<h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4><p>1.确定root<br>2.根据长度再确定root<br>3.递归</p>
<pre><code>28 def rebuild(pre, ino):
29     if len(pre) == 0: return
30     if len(pre) == 1:
31         return TreeNode(pre[0])
32     else:
33         root = TreeNode(pre[0])
34         root.left = rebuild(pre[1:ino.index(root.val)+1], ino[:ino.index(root.val)])
35         root.right = rebuild(pre[ino.index(root.val)+1:], ino[ino.index(root.val)+1:])
36     return root</code></pre><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>「队列」像排队，维持资料前后顺序。插入、删除需时O(1) 。搜索需时O(N) 。<br>Queue 是一个 FIFO（先进先出）的数据结构，并发中使用较多，可以安全地将对象从一个任务传给另一个任务。</p>
<h4 id="Deque-（-Double-Ended-Queue-）"><a href="#Deque-（-Double-Ended-Queue-）" class="headerlink" title="Deque （ Double Ended Queue ）"></a>Deque （ Double Ended Queue ）</h4><p>两头皆能插入与删除，称作Deque ，同时有着Stack 和Queue 的功效。</p>
<pre><code>dq = collections.deque();
dq.appendleft(e)
dq.append(e)
dq.popleft()
dq.pop()</code></pre><h2 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap - 堆"></a>Heap - 堆</h2><p>一般情况下，堆通常指的是二叉堆，二叉堆是一个近似完全二叉树的数据结构，但由于对二叉树平衡及插入/删除操作较为麻烦，二叉堆实际上使用数组来实现。即物理结构为数组，逻辑结构为完全二叉树。子结点的键值或索引总是小于（或者大于）它的父节点，且每个节点的左右子树又是一个二叉堆(大根堆或者小根堆)。根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常被用作实现优先队列。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>以数组表示，但是以完全二叉树的方式理解。</li>
<li>唯一能够同时最优地利用空间和时间的方法——最坏情况下也能保证使用 2N \log N2NlogN 次比较和恒定的额外空间。</li>
<li>在索引从0开始的数组中：<br>父节点 i 的左子节点在位置(2<em>i+1)<br>父节点 i 的右子节点在位置(2</em>i+2)<br>子节点 i 的父节点在位置floor((i-1)/2)</li>
</ol>
<pre><code>class MaxHeap:
    def __init__(self, array=None):
        if array:
            self.heap = self._max_heapify(array)
        else:
            self.heap = []

    def _sink(self, array, i):
        # move node down the tree
        left, right = 2 * i + 1, 2 * i + 2
        max_index = i
        # should compare two chidren then determine which one to swap with
        if left &lt; len(array) and right &lt; len(array):
            flag = array[left] &gt; array[right]
        else:
            flag = True
        if left &lt; len(array) and array[left] &gt; array[max_index] and flag:
            max_index = left
        if right &lt; len(array) and array[right] &gt; array[max_index] and not flag:
            max_index = right
        if max_index != i:
            array[i], array[max_index] = array[max_index], array[i]
            self._sink(array, max_index)

    def _swim(self, array, i):
        # move node up the tree
        if i == 0:
            return
        father = (i - 1) / 2
        if array[father] &lt; array[i]:
            array[father], array[i] = array[i], array[father]
            self._swim(array, father)

    def _max_heapify(self, array):
        for i in xrange(len(array) / 2, -1, -1):
            self._sink(array, i)
        return array

    def push(self, item):
        self.heap.append(item)
        self._swim(self.heap, len(self.heap) - 1)

    def pop(self):
        self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]
        item = self.heap.pop()
        self._sink(self.heap, 0)
        return item</code></pre><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>栈是一种 LIFO(Last In First Out) 的数据结构，常用方法有添加元素，取栈顶元素，弹出栈顶元素，判断栈是否为空。</p>
<pre><code>stack = []
len(stack) # size of stack

# more efficient stack
import collections
stack = collections.deque()

len(stack) != 0 - 判断stack是否weikong
stack[-1] - 取栈顶元素，不移除
pop() - 移除栈顶元素并返回该元素
append(item) - 向栈顶添加元素</code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><pre><code>Set 是一种用于保存不重复元素的数据结构。常被用作测试归属性，故其查找的性能十分重要</code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map 是一种关联数组的数据结构，也常被称为字典或键值对。在 Python 中 dict(Map) 是一种基本的数据结构。</p>
<h4 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h4><pre><code>当元素的数值范围很大，甚至元素不是整数，此时可以利用hash function 得到一个索引值，而不会超出列表边界。

数值范围小，索引储存是首选，省时间费空间；数值范围大，循序储存是首选，省空间费时间。hash table 两者兼具，介于中间。</code></pre><h2 id="Graph-图"><a href="#Graph-图" class="headerlink" title="Graph - 图"></a>Graph - 图</h2><p>图的表示通常使用邻接矩阵和邻接表，前者易实现但是对于稀疏矩阵会浪费较多空间，后者使用链表的方式存储信息但是对于图搜索时间复杂度较高。</p>
<h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>设顶点个数为 V, 那么邻接矩阵可以使用 V × V 的二维数组来表示。 g[i][j]表示顶点i和顶点j的关系，对于无向图可以使用0/1表示是否有连接，对于带权图则需要使用INF来区分。有重边时保存边数或者权值最大/小的边即可。</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接表通过表示从顶点i出发到其他所有可能能到的边。</p>
<h2 id="Python位运算操作符"><a href="#Python位运算操作符" class="headerlink" title="Python位运算操作符"></a>Python位运算操作符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>意义</th>
<th>举例</th>
<th>操作符</th>
<th>意义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>按位取反</td>
<td>~5</td>
<td>&amp;</td>
<td>按位与</td>
<td>5&amp;6</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>5|6</td>
<td>^</td>
<td>按位异或</td>
<td>5^6</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移m位</td>
<td>5&lt;&lt;1</td>
<td>&gt;&gt;</td>
<td>右移</td>
<td>6&gt;&gt;1</td>
</tr>
</tbody></table>
<h4 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h4><ol>
<li><p>原码：原码是二进制数字的一种简单的表示法。二进制首位为符号位，1代表负，0代表正。</p>
</li>
<li><p>反码：反码可由原码得到。如果是正数，反码与原码相同；如果是负数，反码是其原码（符号位除外）各位取反而得到的。</p>
</li>
<li><p>补码：补码可由原码得到。如果是正数，补码与原码相同；如果是负数，补码是对其原码（除符号位外）各位取反，并在末位加1而得到的（有进位则进位，但不改变符号位）。</p>
</li>
</ol>
<p>原码是为了方便人计算，补码是方便计算机计算，而反码是认为提出的一个中间桥梁。<br>计算机里面，只有加法器，没有减法器，所有的减法运算，都必须用加法进行。<br>用补数代替原数，可把减法转变为加法。出现的进位就是模，此时的进位，就应该忽略不计。<br>二进制下，有多少位数参加运算，模就是在 1 的后面加上多少个 0。<br>补码就是按照这个要求来定义的：正数不变，负数即用模减去绝对值。</p>
<h4 id="Python位运算"><a href="#Python位运算" class="headerlink" title="Python位运算"></a>Python位运算</h4><p>数字在计算机中是以补码保存的，所以用Python位运算作用在补码上，每一位都参与运算：</p>
<p>按位取反~：按位取反后得到二进制表示，把该二进制看成一个新的补码，返回该补码对应的数字结果。</p>
<h4 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与&amp;"></a>按位与&amp;</h4><p>相同位的两个数字都为1，则为1；若有一个不为1，则为0。</p>
<p>可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数。</p>
<h4 id="或"><a href="#或" class="headerlink" title="或|"></a>或|</h4><p>相同位只要一个为1即为1。</p>
<p>or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。</p>
<h4 id="异或"><a href="#异或" class="headerlink" title="异或^"></a>异或^</h4><p>（^或者xor）如果某位不同则该位为1, 否则该位为0.</p>
<h4 id="同取反"><a href="#同取反" class="headerlink" title="同取反~"></a>同取反~</h4><p>not运算（~）的定义是把内存中的0和1全部取反。</p>
<h4 id="左移-lt-lt-和右移-gt-gt"><a href="#左移-lt-lt-和右移-gt-gt" class="headerlink" title="左移&lt;&lt;和右移&gt;&gt;"></a>左移&lt;&lt;和右移&gt;&gt;</h4><p>左移和右移N位等同于无溢出检查（忽略溢出）的N次幂运算2**N。对长整型来说，位操作符使用一种修改的二进制补码形式，使得符号位可以无限向左扩展。也就是说，向左移位不会溢出。</p>
<h2 id="Incremental-Method"><a href="#Incremental-Method" class="headerlink" title="Incremental Method"></a>Incremental Method</h2><p>「递增法」是符合电脑运作特性的方法。电脑执行程式，一次只做一个动作，完成了一件事才做下一件事。当一个问题太大太多时，化整为零、一个一个解决吧！</p>
<h4 id="selection-sort"><a href="#selection-sort" class="headerlink" title="selection sort"></a>selection sort</h4><pre><code>1 def selection(_l):
2     for i in range(len(_l)):
3         min = i
4         for j in range(i+1,len(_l)):
5             if _l[j] &lt; _l[min]:
6                 min = j
7         _l[i], _l[min] = _l[min], _l[i]
8     print(_l)</code></pre><h2 id="Memoization"><a href="#Memoization" class="headerlink" title="Memoization"></a>Memoization</h2><p>「记忆法」是符合电脑运作特性的方法。电脑拥有大量储存空间。只要将计算过的数值，储存于记忆体，往后就能直接使用记忆体储存的资料，不必再浪费时间重复计算一遍。</p>
<pre><code>array = [[0 for i in range(n)] for j in range(n)]
#利用列表生成式快速创建多维数组</code></pre><h2 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h2><p>「枚举法」利用了电脑无与伦比的计算速度。找到不确定的变数，枚举所有可能性，逐一判断正确性。</p>
<pre><code> 1 S = &quot;It&apos;s a pencil.&quot;
 2 s = &quot;a pen&quot;
 3
 4 for i in range(0, len(S)):
 5     flag = True
 6     for j in range(0, len(s)):
 7         if S[i+j] != s[j]:
 8             flag = False
 9     if flag:
10         print(i, S[i])
11         break</code></pre><h2 id="Straightforward-Method-Trial-and-Error"><a href="#Straightforward-Method-Trial-and-Error" class="headerlink" title="Straightforward Method / Trial and Error"></a>Straightforward Method / Trial and Error</h2><p>「直接法」，直接算出答案。直接法和试误法刚好相反。直接法是由题目本身下手，推导答案；试误法则是从答案下手，让答案迎合题目需求。</p>
<h4 id="暴力攻击（-Brute-Force-Attack-）"><a href="#暴力攻击（-Brute-Force-Attack-）" class="headerlink" title="暴力攻击（ Brute Force Attack ）"></a>暴力攻击（ Brute Force Attack ）</h4><p>破解密码最简单的方法叫做「暴力攻击」。不知道密码规律的情况下，无法直接推导正确密码，只好以试误法一一检验所有可能的密码，从中找出正确密码。</p>
<h4 id="单向函数（-One-way-Function-）"><a href="#单向函数（-One-way-Function-）" class="headerlink" title="单向函数（ One-way Function ）"></a>单向函数（ One-way Function ）</h4><p>「单向函数」是一种特别的函数，给定输入很容易算出输出，但是给定输出却很难算出输入。</p>
<h2 id="Iterative-Method"><a href="#Iterative-Method" class="headerlink" title="Iterative Method"></a>Iterative Method</h2><p>叠代法，也叫递推法。不断利用目前求得的数值，再求得新数值。</p>
<h4 id="数学归纳法（-Mathematical-Induction-）"><a href="#数学归纳法（-Mathematical-Induction-）" class="headerlink" title="数学归纳法（ Mathematical Induction ）"></a>数学归纳法（ Mathematical Induction ）</h4><pre><code>数学归纳法的第二步骤，就是证明可不可以递推！第二步骤的证明过程中一定会用到递推！
1. 先证明n = 1 成立。（有时候不见得要从1开始。）
2. 假设n = k 成立，证明n = k+1 也会成立。
当1. 2. 得证，就表示n = 1 ... ∞ 全部都成立。</code></pre><h4 id="插入排序法（-Insertion-Sort-）"><a href="#插入排序法（-Insertion-Sort-）" class="headerlink" title="插入排序法（ Insertion Sort ）"></a>插入排序法（ Insertion Sort ）</h4><pre><code>从表面上来看是递增法与枚举法：第一层是递增法，逐一把每个数字插入到左方已排序的列表。第二层是枚举法，搜索插入位置；再将大量数字往右挪，以腾出空间插入数字。</code></pre><h2 id="Recursive-Method"><a href="#Recursive-Method" class="headerlink" title="Recursive Method"></a>Recursive Method</h2><p>递归法。重复运用相同手法，缩减问题范围，直到厘清细节。<br>递推法与递归法恰好颠倒：递推法是针对已知，逐步累积，直至周全；递归法是针对未知，反覆拆解，直至精确。</p>
<h2 id="Greedy-Method"><a href="#Greedy-Method" class="headerlink" title="Greedy Method"></a>Greedy Method</h2><p>「贪心法」。以Incremental Method 或Iterative Method 制造答案的方法，大致上分为两类：</p>
<pre><code>一、填答案：从没有答案开始，逐步填满答案。
二、改答案：先随便弄个答案，逐步修饰答案。
一、观察问题特征，拟定一个填答案、改答案的原则。
二、随便挑几个特例，手算一下。
  如果答案都对，就大胆假设此原则是正确的。
  （也可以尝试证明此原则必定正确。）
三、实作程式码，把答案算出来。</code></pre><h4 id="不重复组合（-Combination-）"><a href="#不重复组合（-Combination-）" class="headerlink" title="不重复组合（ Combination ）"></a>不重复组合（ Combination ）</h4><pre><code>从N 个人抓M 个人出来组团，有哪些组合方式呢？
N 个人当中的其中一个人，叫做甲君好了，我们将原问题分割成两种情形：甲君在团中、甲君不在团中。甲君在团中，演变成剩下N-1个人要再抓M-1个人出来组团。
甲君不在团中，演变成剩下N-1个人仍要抓M个人出来组团。

综合这两个子问题的组合方式，就得到答案。从N 个人抓M 个人出来组团，有哪些组合方式呢？
N 个人当中的其中一个人，叫做甲君好了，我们将原问题分割成两种情形：甲君在团中、甲君不在团中。甲君在团中，演变成剩下N-1个人要再抓M-1个人出来组团。
甲君不在团中，演变成剩下N-1个人仍要抓M个人出来组团。

综合这两个子问题的组合方式，就得到答案。</code></pre><h4 id="二分搜索法（-Binary-Search-）"><a href="#二分搜索法（-Binary-Search-）" class="headerlink" title="二分搜索法（ Binary Search ）"></a>二分搜索法（ Binary Search ）</h4><p>这是在已排序列表里面搜索数字的方法。列表由中央切成两边，一边数字较小、一边数字较大。这两边一定有一边不是我们所要的，可以去除，只需要继续寻找其中一边。</p>
<h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><table>
<thead>
<tr>
<th></th>
<th>best case average case worst case</th>
<th>extra space</th>
<th>stable</th>
</tr>
</thead>
<tbody><tr>
<td>brute force</td>
<td>O(NR) O(NR) O(NR)</td>
<td>O(N)</td>
<td>O</td>
</tr>
<tr>
<td>selection sort</td>
<td>O(NN) O(NN) O(NN)</td>
<td>O(1)</td>
<td>X</td>
</tr>
<tr>
<td>bubble sort</td>
<td>O(N) O(NN) O(NN)</td>
<td>O(1)</td>
<td>O</td>
</tr>
<tr>
<td>gnome sort</td>
<td>O(N) O(NN) O(NN)</td>
<td>O(1)</td>
<td>O</td>
</tr>
<tr>
<td>insertion sort</td>
<td>O(N) O(NN) O(NN)</td>
<td>O(1)</td>
<td>O</td>
</tr>
<tr>
<td>Shell sort</td>
<td>O(NN) O(NN) O(NN)</td>
<td>O(1)</td>
<td>X</td>
</tr>
<tr>
<td>merge sort</td>
<td>O(NlogN) O(NlogN) O(NlogN)</td>
<td>O(N)</td>
<td>O</td>
</tr>
<tr>
<td>Timsort</td>
<td>O(NlogN) O(NlogN) O(NlogN)</td>
<td>O(N)</td>
<td>O</td>
</tr>
<tr>
<td>quicksort</td>
<td>O(NlogN) O(NlogN) O(NN)</td>
<td>O(N)</td>
<td>X</td>
</tr>
<tr>
<td>heapsort</td>
<td>O(NlogN) O(NlogN) O(NlogN)</td>
<td>O(1)</td>
<td>X</td>
</tr>
<tr>
<td>introsort</td>
<td>O(NlogN) O(NlogN) O(NlogN)</td>
<td>O(N)</td>
<td>X</td>
</tr>
<tr>
<td>counting sort</td>
<td>O(N+R) O(N+R) O(N+R)</td>
<td>O(N+R)</td>
<td>O</td>
</tr>
<tr>
<td>radix sort</td>
<td>O(NlogR) O(NlogR) O(NlogR)</td>
<td>O(N)</td>
<td>O</td>
</tr>
<tr>
<td>bucket sort</td>
<td>O(N+R) O(N+R) O(NNR)</td>
<td>O(NR)</td>
<td>X</td>
</tr>
<tr>
<td>flashsort</td>
<td>O(N+R) O(N+R) O(NN)</td>
<td>O(N)</td>
<td>X</td>
</tr>
<tr>
<td>sleep sort</td>
<td>O(N+R) O(N+R) O(N+R)</td>
<td>O(N)</td>
<td>X</td>
</tr>
</tbody></table>
<h4 id="排序原理"><a href="#排序原理" class="headerlink" title="排序原理"></a>排序原理</h4><pre><code>排序的基本原理，当今只有两种，一是对调（数字是实数），二是放置（数字必须是整数）。

纯粹透过对调来排序，已证明出数字两两比较的次数是Ω(NlogN) ，不可能更少了，当今也已经有了到达下限的排序演算法，例如merge sort 。同时透过对调与放置来排序，则可以打破方才的下限，例如flashsort 。

纯粹透过放置来排序，需要额外的记忆体空间来放置数字。时间复杂度通常是数字数量加上记忆体用量，效率相当好，只可惜只能处理整数，例如counting sort 。</code></pre><h4 id="selection-sort-1"><a href="#selection-sort-1" class="headerlink" title="selection sort"></a>selection sort</h4><p>扫描一遍所有数字，找到最小值，挪至列表左端。递归处理尚未排序的N-1 个元素。复杂度: O(N2) — 实际上，这和冒泡排序很像。</p>
<pre><code>1 def selection(_l):
2     for i in range(len(_l)):
3         min = i
4         for j in range(i+1,len(_l)):
5             if _l[j] &lt; _l[min]:
6                 min = j
7         _l[i], _l[min] = _l[min], _l[i]
8     print(_l)</code></pre><h4 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h4><p>由左到右，相邻两两比较，较大者往右挪，最后最大值会出现在列表右端。递归处理尚未排序的N-1 个元素。冒泡排序实际上是低效的，它的 O(N^2) 时间复杂度。</p>
<pre><code>1 def bubble(l):
2     for i in range(0, len(l)):
3         for j in range(0, len(l)-i-1):
4             if l[j] &gt; l[j+1]:
5                 l[j], l[j+1] = l[j+1], l[j]
6     print(l)</code></pre><h4 id="Gnome-Sort"><a href="#Gnome-Sort" class="headerlink" title="Gnome Sort"></a>Gnome Sort</h4><p>原理和Bubble Sort 相同，但是两两比较的先后次序有所改变。特色是程式码只有一个loop，结构简单。</p>
<pre><code>1 def gnome(l):
2     i = 0
3     while i &lt; len(l):
4         if i == 0 or l[i-1] &lt; l[i]:
5             i += 1
6         else:
7             l[i], l[i-1] = l[i-1], l[i]
8             i -= 1
9     print(l)</code></pre><h4 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h4><p>由左到右，逐一把数字插入到目前已排序的列表当中。需将大量数字往右挪，以腾出空间插入数字。最佳情况时间是O(N × 1) = O(N) ，最坏情况时间是O(N × N) = O(N2).</p>
<pre><code>1 def insert(l):
2     for i in range(1, len(l)):
3         key = l[i]
4         j = i - 1
5         while j &gt;=0 and key &lt; l[j]:
6             l[j+1] = l[j]
7             j -= 1
8         l[j+1] = key
9     print(l)</code></pre><h4 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h4><p>归并排序是分而治之的排序算法。<br>划分步骤很简单：将当前数组分成两半（如果N是偶数，则将其完全平等，或者如果N是奇数，则一边稍大于一个元素），然后递归地对这两半进行排序。<br>归并子例程合并两个（排序的）半部分以形成一个有序数组。归并排序非常适合分类非常大量的输入，因为O（N log N）比前面讨论的O（N2）排序算法增长得慢得多。</p>
<pre><code> 1 def mergeSort(arr):
 2     if len(arr) &gt;1:
 3         mid = len(arr)//2 #Finding the mid of the array
 4         L = arr[:mid] # Dividing the array elements
 5         R = arr[mid:] # into 2 halves
 6
 7         mergeSort(L) # Sorting the first half
 8         mergeSort(R) # Sorting the second half
 9
10         i = j = k = 0
11
12         # Copy data to temp arrays L[] and R[]
13         while i &lt; len(L) and j &lt; len(R):
14             if L[i] &lt; R[j]:
15                 arr[k] = L[i]
16                 i+=1
17             else:
18                 arr[k] = R[j]
19                 j+=1
20             k+=1
21
22         # Checking if any element was left
23         while i &lt; len(L):
24             arr[k] = L[i]
25             i+=1
26             k+=1
27
28         while j &lt; len(R):
29             arr[k] = R[j]
30             j+=1
31             k+=1</code></pre><h4 id="Quicksort"><a href="#Quicksort" class="headerlink" title="Quicksort"></a>Quicksort</h4><p>快速排序是另一个分而治之排序算法。选主元很重要，找头中尾3个数的中位数，例如8,12,3中位数为8，复杂点5个7个数选取中位数.Quicksort 演算法的陷阱相当多，须考虑数字全都相等、判断式是小于还是小于等于、分割点恰好选到最大值或者最小值、递归的区段范围、递归的区段很短、 ……等等问题。</p>
<pre><code> 1 def sort(array=[12,4,5,6,7,3,1,15]):
 2     less = []
 3     equal = []
 4     greater = []
 5
 6     if len(array) &gt; 1:
 7         pivot = array[0] #can be better
 8         for x in array:
 9             if x &lt; pivot:
10                 less.append(x)
11             elif x == pivot:
12                 equal.append(x)
13             else x &gt; pivot:
14                 greater.append(x)
15         return sort(less)+equal+sort(greater)
16     else:
17         return array</code></pre><p> 使用列表生成式简写</p>
<pre><code> 19  def qsort(arr):
20     if len(arr) &gt; 1:
21         pivot = arr[0]
22         return qsort([ for x in arr if x &lt; pivot ]) + [pivot] + qsort([ for x in arr if x &gt;= pivot ])
23     else:
24         return arr</code></pre>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fankcoder.com/2019/04/14/life-2019-01-01-life-time-manage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fankcoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三秋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/04/14/life-2019-01-01-life-time-manage/" class="post-title-link" itemprop="url">时间和人生感悟</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-04-14 15:28:16 / Modified: 15:56:23" itemprop="dateCreated datePublished" datetime="2019-04-14T15:28:16+08:00">2019-04-14</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/生活/" itemprop="url" rel="index"><span itemprop="name">生活</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          life, time
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2019/04/14/life-2019-01-01-life-time-manage/">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fankcoder.com/2019/04/04/resource-2019-04-04-general-docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fankcoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三秋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/04/04/resource-2019-04-04-general-docker/" class="post-title-link" itemprop="url">Docker 笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-04-04 23:13:04" itemprop="dateCreated datePublished" datetime="2019-04-04T23:13:04+08:00">2019-04-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-09 20:56:40" itemprop="dateModified" datetime="2019-10-09T20:56:40+08:00">2019-10-09</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/备忘/" itemprop="url" rel="index"><span itemprop="name">备忘</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础类"><a href="#基础类" class="headerlink" title="基础类"></a>基础类</h2><h3 id="查看docker信息"><a href="#查看docker信息" class="headerlink" title="查看docker信息"></a>查看docker信息</h3><h3 id="查看docker版本"><a href="#查看docker版本" class="headerlink" title="# 查看docker版本"></a># 查看docker版本</h3><p>docker version</p>
<h4 id="显示docker系统的信息"><a href="#显示docker系统的信息" class="headerlink" title="显示docker系统的信息"></a>显示docker系统的信息</h4><p>docker info</p>
<h4 id="日志信息"><a href="#日志信息" class="headerlink" title="日志信息"></a>日志信息</h4><p>docker logs</p>
<h4 id="故障检查"><a href="#故障检查" class="headerlink" title="故障检查"></a>故障检查</h4><p>service docker status</p>
<h4 id="启动关闭docker"><a href="#启动关闭docker" class="headerlink" title="启动关闭docker"></a>启动关闭docker</h4><p>sudo service docker start|stop</p>
<h2 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h2><h4 id="查看当前运行的容器"><a href="#查看当前运行的容器" class="headerlink" title="查看当前运行的容器"></a>查看当前运行的容器</h4><p>docker ps</p>
<h4 id="查看全部容器"><a href="#查看全部容器" class="headerlink" title="查看全部容器"></a>查看全部容器</h4><p>docker ps -a</p>
<h4 id="查看全部容器的id和信息"><a href="#查看全部容器的id和信息" class="headerlink" title="查看全部容器的id和信息"></a>查看全部容器的id和信息</h4><p>docker ps -a -q</p>
<h4 id="查看全部容器占用的空间"><a href="#查看全部容器占用的空间" class="headerlink" title="查看全部容器占用的空间"></a>查看全部容器占用的空间</h4><p>docker ps -as</p>
<h4 id="查看一个正在运行容器进程，支持-ps-命令参数"><a href="#查看一个正在运行容器进程，支持-ps-命令参数" class="headerlink" title="查看一个正在运行容器进程，支持 ps 命令参数"></a>查看一个正在运行容器进程，支持 ps 命令参数</h4><p>docker top</p>
<h2 id="启动停止容器等操作"><a href="#启动停止容器等操作" class="headerlink" title="启动停止容器等操作"></a>启动停止容器等操作</h2><p>docker start|stop|restart [id]</p>
<h4 id="暂停-恢复-某一容器的所有进程"><a href="#暂停-恢复-某一容器的所有进程" class="headerlink" title="暂停|恢复 某一容器的所有进程"></a>暂停|恢复 某一容器的所有进程</h4><p>docker pause|unpause [id]</p>
<h4 id="杀死一个或多个指定容器进程"><a href="#杀死一个或多个指定容器进程" class="headerlink" title="杀死一个或多个指定容器进程"></a>杀死一个或多个指定容器进程</h4><p>docker kill -s KILL [id]</p>
<h4 id="停止全部运行的容器"><a href="#停止全部运行的容器" class="headerlink" title="停止全部运行的容器"></a>停止全部运行的容器</h4><p>docker stop <code>docker ps -q</code></p>
<h4 id="杀掉全部运行的容器"><a href="#杀掉全部运行的容器" class="headerlink" title="杀掉全部运行的容器"></a>杀掉全部运行的容器</h4><p>docker kill -s KILL <code>docker ps -q</code></p>
<h2 id="交互式进入容器"><a href="#交互式进入容器" class="headerlink" title="交互式进入容器"></a>交互式进入容器</h2><p>sudo docker exec -it</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fankcoder.com/2019/04/02/tool-2019-04-02-ss-config/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fankcoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三秋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/04/02/tool-2019-04-02-ss-config/" class="post-title-link" itemprop="url">vps上网</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-04-02 23:13:35" itemprop="dateCreated datePublished" datetime="2019-04-02T23:13:35+08:00">2019-04-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-24 11:25:26" itemprop="dateModified" datetime="2019-09-24T11:25:26+08:00">2019-09-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/工具/" itemprop="url" rel="index"><span itemprop="name">工具</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="老方法弃用"><a href="#老方法弃用" class="headerlink" title="老方法弃用"></a>老方法弃用</h2><p>切换到v2 + ws + tls + CDN</p>
<hr>
<h3 id="已一台刚装好的centOS6-5为例"><a href="#已一台刚装好的centOS6-5为例" class="headerlink" title="已一台刚装好的centOS6.5为例"></a>已一台刚装好的centOS6.5为例</h3><p>安装git&amp;ss，此步骤安装最新的ss，不建议安装老版本ss</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U</span><br></pre></td></tr></table></figure>

<p>配置ss</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/shadowdowsocks.json</span><br></pre></td></tr></table></figure>

<p>配置ss例子，端口写不常用的，并且的越随意越好，记得不要超过65535</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;                                  </span><br><span class="line">    &quot;server&quot;:&quot;my_server_ip&quot;,          //服务器的IP地址</span><br><span class="line">    &quot;server_port&quot;:7711,              //服务器的端口，</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,       //本机IP地址</span><br><span class="line">    &quot;local_port&quot;:1080,               //本机端口</span><br><span class="line">    &quot;password&quot;:&quot;mypassword&quot;,        //自己设定的密码</span><br><span class="line">    &quot;timeout&quot;:600,                  //超出时间</span><br><span class="line">    &quot;method&quot;:&quot;chacha20-ietf-poly1305&quot;,          //加密方法，推荐使用&quot;chacha20-ietf-poly1305&quot;算法需要额外安装</span><br><span class="line">    &quot;fast_open&quot;: false                //true 或 false&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 若是多用户模式，将server_port和password合并为port_password：</span><br><span class="line">&quot;port_password&quot;: &#123;</span><br><span class="line">         &quot;443&quot;: &quot; mypassword 1”,  //对应端口设定不同的密码</span><br><span class="line">         &quot;8888&quot;: &quot; mypassword 2”</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure>

<p>安装gevent，如果使用Python2，高版本的gevent可能会安装失败，官方推荐1.1版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y libevent</span><br><span class="line">$ pip install greenlet</span><br><span class="line">$ pip install gevent==1.1</span><br></pre></td></tr></table></figure>

<p>强烈使用推荐的chacha20-ietf算法。安装新算法需要先安装libsodium</p>
<p>直接安装or编译安装随心情</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install libsodium</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum -y groupinstall &quot;Development Tools&quot;</span><br><span class="line">wget https://github.com/jedisct1/libsodium/releases/download/1.0.15/libsodium-1.0.15.tar.gz</span><br><span class="line">tar xf libsodium-1.0.15.tar.gz &amp;&amp; cd libsodium-1.0.15</span><br><span class="line">./configure &amp;&amp; make -j2 &amp;&amp; make install</span><br><span class="line">echo /usr/local/lib &gt; /etc/ld.so.conf.d/usr_local_lib.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>

<p>启动ss服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json</span><br><span class="line"># 若想让ss一直在后台运行，可运行：</span><br><span class="line">nohup ssserver -c /etc/shadowsocks.json &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<p>macos: ShadowsocksX-NG</p>
<p>win: <a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">https://shadowsocks.org/en/download/clients.html</a></p>
<p>android: 可以先从pc下个apk传到手机（或者免费vpn有很多临时用下不错）再用gg play更新/下载</p>
<p>ios:wingy</p>
<h2 id="kcptun"><a href="#kcptun" class="headerlink" title="kcptun"></a>kcptun</h2><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://github.com/easonhuang123/blog/issues/1" target="_blank" rel="noopener">https://github.com/easonhuang123/blog/issues/1</a></p>
<p><a href="https://github.com/shadowsocksrr/shadowsocks-rss/wiki/libsodium" target="_blank" rel="noopener">https://github.com/shadowsocksrr/shadowsocks-rss/wiki/libsodium</a></p>
<p>下面是一篇升级glibc的文章，我的确升级成功了，但是bbr还是用不了，放弃了<br><a href="https://cnodejs.org/topic/56dc21f1502596633dc2c3dc" target="_blank" rel="noopener">https://cnodejs.org/topic/56dc21f1502596633dc2c3dc</a></p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fankcoder.com/2019/03/08/technology-2019-03-08-python-deep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fankcoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三秋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/03/08/technology-2019-03-08-python-deep/" class="post-title-link" itemprop="url">Python深入学习笔记</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-03-08 15:38:39" itemprop="dateCreated datePublished" datetime="2019-03-08T15:38:39+08:00">2019-03-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-06-19 13:54:06" itemprop="dateModified" datetime="2019-06-19T13:54:06+08:00">2019-06-19</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from collections import *</span><br><span class="line"></span><br><span class="line">from collections.abc import * #抽象基类</span><br></pre></td></tr></table></figure>

<h4 id="tuple功能"><a href="#tuple功能" class="headerlink" title="tuple功能"></a>tuple功能</h4><ol>
<li>不可变(不绝对)</li>
<li>iterable</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#拆包，方便找到对应关系</span><br><span class="line">_tuple = (&apos;fank&apos;, 26, 182)</span><br><span class="line">name, age, height = _tuple</span><br><span class="line">#name = _tuple[0] 不好的写法</span><br><span class="line"></span><br><span class="line">#拆包加强</span><br><span class="line">name, *other = _tuple</span><br><span class="line">print(name, other)</span><br></pre></td></tr></table></figure>

<h4 id="tuple比list好的地方"><a href="#tuple比list好的地方" class="headerlink" title="tuple比list好的地方"></a>tuple比list好的地方</h4><ol>
<li>immutable的重要性</li>
<li>性能优化，不可变对象在编译时作为常量，产生显著的速度差异</li>
<li>线程安全</li>
<li>可以作为dict的key</li>
<li>拆包特性</li>
<li>如果拿C来类比，tuple对应struct, 而list对应array</li>
</ol>
<h4 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h4><p>可以生成类，</p>
<pre><code>User = namedtuple(&quot;User&quot;,[&apos;name&apos;,&apos;age&apos;])
user = User(name=&apos;fank&apos;, age=&apos;27&apos;)
print（user.name, user.age）

_make()使用tuple初始化，_asdict()使用dict初始化
t = (&apos;fank&apos;, 27)
user = User._make(t)
d = {&apos;name&apos;:&apos;fank&apos;,&apos;age&apos;:27}
user = User._asdict(d)</code></pre><p>节省空间，用于数据处理，从数据库取数据为tuple，直接赋值</p>
<h4 id="def-ask-args-kwargs"><a href="#def-ask-args-kwargs" class="headerlink" title="def ask(args, *kwargs)"></a>def ask(<em>args, *</em>kwargs)</h4><p><em>args是个tuple, *</em>kwargs是个dict</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def test(*args, **kwargs):</span><br><span class="line">    print(*args)</span><br><span class="line">    print(**kwargs)</span><br><span class="line"></span><br><span class="line">test(&apos;f&apos;,25)</span><br><span class="line">test(&#123;&apos;name&apos;:&apos;f&apos;,&apos;age&apos;:25&#125;</span><br><span class="line"></span><br><span class="line"># ask(&apos;f&apos;,25) 传给*args, ask(name=&apos;f&apos;, age=25)传给**kwargs</span><br></pre></td></tr></table></figure>

<h4 id="deque双端队列"><a href="#deque双端队列" class="headerlink" title="deque双端队列"></a>deque双端队列</h4><p>应用场景queue是由deque来完成的。deque是线程安全到，list不是线程安全的，由GIL保护。</p>
<pre><code>from collections import deque</code></pre><p>copy是浅拷贝，如果值为list会相互影响</p>
<h4 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h4><p>统计</p>
<pre><code>from collections import Counter
users = [&apos;fank&apos;,&apos;fank1&apos;,&apos;fank1&apos;,&apos;fank2&apos;,&apos;fank&apos;,&apos;fank3&apos;]
user_counter = Counter(users)
print(user_counter)
#Counter({&apos;fank&apos;:2,&apos;fank1&apos;:2,&apos;fank3&apos;:1})

#追加统计
user_counter.update()
#前n个出现最多的,使用堆实现(完全二叉树)
user_counter.most_common(n)</code></pre><h4 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h4><p>from collections import defaultdict C语言实现，性能高,比setdefault更强大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">default_dict = defaultdict(int) #参数是一个可调用对象list,int,func..</span><br><span class="line"></span><br><span class="line">default_dict[&apos;key&apos;] #key=0 ,初始化成功后，直接访问不会报错，会默认生成</span><br><span class="line"></span><br><span class="line">def gen_func():</span><br><span class="line">    return &#123;&apos;fank&apos;:123,&apos;code&apos;:321&#125;</span><br><span class="line">default_dict = defaultdict(gen_func) #生成默认值</span><br></pre></td></tr></table></figure>

<h4 id="OrderDict是有序的"><a href="#OrderDict是有序的" class="headerlink" title="OrderDict是有序的"></a>OrderDict是有序的</h4><p>dict的子类，按照添加顺序排序。list+dict<br>py3的dict默认是有序的。</p>
<pre><code>_d = OrderedDict()
_d.popitem()  #不需要传key
_d.move_to_end()</code></pre><h4 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h4><p>方便操作多个dict. 将dict连结,key相同只有一个。</p>
<pre><code>from collections import ChainMap

new_dict = ChainMap(_d1, _d2)
new_dict.new_child({&apos;name&apos;:&apos;fank&apos;})

new_dict.maps  #maps属性，以列表形式全部打印，同样可以修改</code></pre><h3 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h3><pre><code>import inspect
inspect.getfile(obj)
inspect.getsource(obj)</code></pre><h3 id="type-object和class的关系"><a href="#type-object和class的关系" class="headerlink" title="type,object和class的关系"></a>type,object和class的关系</h3><p>type(int) -&gt; class type -&gt; obj</p>
<p>type -&gt; int -&gt; 1</p>
<p>type生成类对象，类对象生成实例对象</p>
<p>int.<strong>bases</strong> class ‘object’</p>
<p>基类均为class object, object是最顶层基类。</p>
<p>type.<strong>bases</strong> class ‘object’ type继承obj</p>
<p>type(object) class ’type’ obj是type的实例, 形成环路</p>
<p>object.<strong>bases</strong> None</p>
<h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>对象3个特征:</p>
<ol>
<li>身份id(a) </li>
<li>2.类型type </li>
<li>3.值</li>
</ol>
<p>None全局唯一</p>
<p>数值int, float,complex复数,bool</p>
<p>迭代类型</p>
<p>序列类型 list,bytes,range,tuple,str,array</p>
<p>映射类型 dict</p>
<p> 集合 set , frozenset</p>
<p>上下文管理器 with</p>
<p>其他 模块from import,class,object,type</p>
<h3 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h3><p>以双下划线开头，双下划线结尾。可以定制类的特性</p>
<p><strong>iter</strong>,<strong>getitem</strong>实现了都是可迭代的</p>
<p>def <strong>getitem</strong>(self, item):</p>
<p>return self._list[item]</p>
<p>拆包，给长度数量的变量给他们赋值</p>
<h3 id="鸭子类型和多态"><a href="#鸭子类型和多态" class="headerlink" title="鸭子类型和多态"></a>鸭子类型和多态</h3><p>当一只鸟，走路，游泳，叫起来都像鸭子，那么这只鸟就可以被叫做鸭子<br>都实现了同一种方法，所以可以归为一类，不需要继承，只需要实现同方法，就可以实现多态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Cat(object):</span><br><span class="line">    def say(self):</span><br><span class="line">        print(‘im a cat’)</span><br><span class="line"></span><br><span class="line">class Dog(object):</span><br><span class="line">    def say(self):</span><br><span class="line">        print(‘im a dog’)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">animal = Cat</span><br><span class="line">animal().say()</span><br><span class="line"></span><br><span class="line">animal_list = [Cat, Dog]</span><br><span class="line">for animal in animal_list:</span><br><span class="line">    animal().say()</span><br></pre></td></tr></table></figure>

<h3 id="抽象基类abc模块"><a href="#抽象基类abc模块" class="headerlink" title="抽象基类abc模块"></a>抽象基类abc模块</h3><p>检查某个类是否有某种方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Company(object):</span><br><span class="line">    def __init__(self, employee_list):</span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self.employee)</span><br><span class="line"></span><br><span class="line">com = Company([‘bob1’,’bob2’])</span><br><span class="line">print(hasattr(com, ‘__len__’) #检验类是否具有该方法</span><br><span class="line"># print(len(com))</span><br></pre></td></tr></table></figure>

<h3 id="抽象基类abc模块-1"><a href="#抽象基类abc模块-1" class="headerlink" title="抽象基类abc模块"></a>抽象基类abc模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from collections.abc import Sized</span><br><span class="line">isinstance(com, Sized) # 判断类型</span><br><span class="line">import abc</span><br><span class="line"></span><br><span class="line">class CacheBase(metaclass=abc.ABCMeta):</span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def get(self, key):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def set(self, key, value):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class RedisCache(CacheBase):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">redis_cache = REdisCache()  </span><br><span class="line">#会报错。</span><br><span class="line">#abstractmethod要求被继承的类，必须实现父类的方法，否则会报错</span><br></pre></td></tr></table></figure>

<p>判断继承用isinstance()不要用type()</p>
<h4 id="类变量和实例变量"><a href="#类变量和实例变量" class="headerlink" title="类变量和实例变量"></a>类变量和实例变量</h4><p>类中的self是类的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    aa = 1 #类变量</span><br><span class="line">    def __init__(self, x, y):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y  #实例变量</span><br><span class="line">a = A(2,3)</span><br><span class="line">A.aa = 11 #修改类变量</span><br><span class="line">a.aa = 100 #新建变量</span><br><span class="line">print(a.x, a.y, a.aa)</span><br><span class="line">print(A.a)</span><br><span class="line">print(A.x) #error</span><br></pre></td></tr></table></figure>

<p>self是类的实例，类变量和类实例变量的区别</p>
<p><strong>mro</strong>查找。DFS深度优先，对菱形继承有问题，BFS广度优先也有覆盖问题，py3用C3算法</p>
<p>@staticmethod静态方法，传参和普通函数一样，<strong>不需要写self参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Data:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def parse_from_string(date_str):</span><br><span class="line">        year, month, day = tuple(date_str)</span><br><span class="line">        return Date(year, month, day)  #静态方法硬编码，返回值必须与类名相同</span><br></pre></td></tr></table></figure>

<p>@classmethod类方法，第一参数是类本身cls，返回值不需要与类同名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    @classmethod</span><br><span class="line">    def from_string(cls, date_str):  #cls传递的是类本身，不是实例</span><br><span class="line">        year, month, day = tuple(date_str)</span><br><span class="line">        return cls(year, month, day)  #写为cls,变为动态不必与类名相同</span><br><span class="line">#cls是习惯性写法，在这里甚至可以写为self</span><br></pre></td></tr></table></figure>

<h3 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">self.__birthday双下划线开头，但并不绝对安全，_User__birthday依然可以访问到</span><br><span class="line">class User:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__birthday = birthday  #无法被访问</span><br><span class="line">    def get_age(self):</span><br><span class="line">        return 2019 - self.__birthday.year</span><br><span class="line">    def __get_other(self):  #私有方法</span><br><span class="line">        pass</span><br><span class="line">user = User(Date(1992,9,28))</span><br><span class="line">user._User__birthday  #py帮助我们使用这种简单方式封装，找到规律就可以访问</span><br></pre></td></tr></table></figure>

<h3 id="自省机制"><a href="#自省机制" class="headerlink" title="自省机制"></a>自省机制</h3><p>自省是通过一定的机构查询到对象的内部结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    name = ‘user’</span><br><span class="line"></span><br><span class="line">clss Student(Person):</span><br><span class="line">    def __init__(self, school_name):</span><br><span class="line">        self.school_name = ‘&apos;</span><br><span class="line">user = Student(‘abc’)</span><br><span class="line">print(user.__dict__)  #打印实例属性，&#123;’school_name’:abc&#125;.c优化的魔法函数</span><br><span class="line">print(Person.__dict__) #类属性</span><br><span class="line">user.__dict__[’school_addr’] = ‘efg’  #甚至可以赋值</span><br><span class="line">dir(user)  #更详细，功能更强</span><br></pre></td></tr></table></figure>

<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>获取父类init (其实是mro顺序的类，查看方法classname.<strong>mro</strong>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(‘a’)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(‘b’)</span><br><span class="line">        super(b, self).__init__() # py2</span><br><span class="line">        super().__init__() # py3</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">from threading import Thread</span><br><span class="line">class MyThread(Thread):</span><br><span class="line">    def __init__(self, name, user):</span><br><span class="line">        self.user = user</span><br><span class="line">        super().__init__(name=name)  #重用父类代码</span><br></pre></td></tr></table></figure>

<h3 id="mixin模式"><a href="#mixin模式" class="headerlink" title="mixin模式"></a>mixin模式</h3><p>多继承不推荐，mixin代替多继承<br>特点：</p>
<ol>
<li>Mixin类功能单一</li>
<li>不和基类关联，可以和任意基类组合</li>
<li>在mixin中不要使用supper</li>
</ol>
<h3 id="with上下文管理器"><a href="#with上下文管理器" class="headerlink" title="with上下文管理器"></a>with上下文管理器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    raise KeyError</span><br><span class="line">except KeyError as e:</span><br><span class="line">    print(&apos;e&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;else&apos;) #当try正确运行时&amp;except没有捕获到异常打印</span><br><span class="line">finally:</span><br><span class="line">    print(&apos;f&apos;) #始终运行</span><br></pre></td></tr></table></figure>

<p>with语句是为了简化try..finally诞生的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Sample:</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        #获取资源</span><br><span class="line">        print(&apos;enter&apos;)</span><br><span class="line">        return self</span><br><span class="line">    def __exit__(self, exc_type, exc_val, exc_tb):</span><br><span class="line">        #释放资源</span><br><span class="line">        print(&apos;exit&apos;)</span><br><span class="line">    def do_something(self):</span><br><span class="line">        print(&apos;do smt&apos;)</span><br><span class="line"></span><br><span class="line">with Sample() as sample:</span><br><span class="line">    sample.do_something()</span><br></pre></td></tr></table></figure>

<p>这个类实现了上下文管理器协议，此协议非常好用。<br>with是对上下文管理器的支持。</p>
<h3 id="contextlib简化上下文管理器"><a href="#contextlib简化上下文管理器" class="headerlink" title="contextlib简化上下文管理器"></a>contextlib简化上下文管理器</h3><p>进一步简化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import contextlib</span><br><span class="line"></span><br><span class="line">@contextlib.contextmanager</span><br><span class="line">def file_open(file_name):</span><br><span class="line">    print(&apos;file open&apos;)  # __enter__的位置</span><br><span class="line">    yield &#123;&#125;</span><br><span class="line">    print(&apos;file end&apos;)  # __exit__的位置</span><br><span class="line">    </span><br><span class="line">with file_open(&apos;text&apos;) as f:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>type() object</p>
<p>魔法函数</p>
<p>hasattr(param,”<strong>len</strong>“) 判断是否有这个函数，用isinstance()更好</p>
<p>希望用户继承时必须实现方法</p>
<p>class CacheBase():</p>
<p>def get(self, key):raise NotImplementedError</p>
<p>def set(self, key, value):pass</p>
<h3 id="is-和"><a href="#is-和" class="headerlink" title="is 和 =="></a>is 和 ==</h3><p>is判断id是否相同</p>
<p>==判断值</p>
<p>isinstance 和type，判断类的类型尽量用isinstance</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [46]: a = 1</span><br><span class="line">In [47]: b = 1</span><br><span class="line">In [48]: a is b</span><br><span class="line">Out[48]: True</span><br><span class="line"></span><br><span class="line">In [49]: a = [1,2,3]</span><br><span class="line">In [50]: b = [1,2,3]</span><br><span class="line">In [51]: a is b</span><br><span class="line">Out[51]: False</span><br><span class="line"></span><br><span class="line">In [72]: a = &quot;hello world&quot;</span><br><span class="line">In [73]: b = &quot;hello world&quot;</span><br><span class="line">In [74]: a is b</span><br><span class="line">Out[74]: False</span><br></pre></td></tr></table></figure>

<h3 id="自定义序列类"><a href="#自定义序列类" class="headerlink" title="自定义序列类"></a>自定义序列类</h3><p>容器序列，扁平序列，可变序列sequence，不可变序列mutable</p>
<p>python面向协议编程 in可以作用于list</p>
<h3 id="extend"><a href="#extend" class="headerlink" title="+,+=,extend"></a>+,+=,extend</h3><p>+=（<strong>iadd</strong>）的参数可以是序列，+必须两边同类型<br>a.extend(range(0,3)) #直接对值修改，不需要再赋值，参考apped<br>a.append([1,2])  #[1,2,[1,2]]注意和extend的区别</p>
<p>参数可以为任意序列，通过for循环append</p>
<p>切片[start : end : step]，默认值可省略[0,len(L),1].</p>
<p>实现支持切片操作的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Group:</span><br><span class="line">    def __init__(self, group_name, company_name, staffs):</span><br><span class="line">        self.group_name = group_name</span><br><span class="line">        self.company_name = company_name</span><br><span class="line">        self.staffs = staffs</span><br><span class="line">    </span><br><span class="line">    def __reversed__(self):</span><br><span class="line">        self.staffs.reversed()  #这种方式实现不了</span><br><span class="line">        for each in self.staffs[::-1]:</span><br><span class="line">            yield each</span><br><span class="line">        </span><br><span class="line">    # def __getitem__(self, item):</span><br><span class="line">    #     return self.staff[item] #返回对象为list或单个元素</span><br><span class="line">    import numbers</span><br><span class="line">    def __getitem__(self, item):  #返回类对象</span><br><span class="line">        cls = type(self)</span><br><span class="line">        if isinstance(item, slice):</span><br><span class="line">            return cls(group_name=self.group_name, company_name=self.company_name, staffs=self.staffs[item])</span><br><span class="line">        elif isinstance(item, numbers.Interal):</span><br><span class="line">            return cls(group_name=self.group_name, company_name=self.company_name, [staffs=self.staffs[item]])</span><br><span class="line">    </span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self.staffs)</span><br><span class="line">        </span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return iter(self.staffs)</span><br><span class="line">    </span><br><span class="line">    def __contains__(self, item):</span><br><span class="line">        if item in self.staffs:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">staffs = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">group = Group(group_name=&apos;gname&apos;, company_name=&apos;cname&apos;, staff=staffs)</span><br><span class="line">group[:2]</span><br><span class="line">for user in group:</span><br><span class="line">    print(user)</span><br></pre></td></tr></table></figure>

<h3 id="bisect二分查找"><a href="#bisect二分查找" class="headerlink" title="bisect二分查找"></a>bisect二分查找</h3><p>bisect处理已排序序列，二分查找。插入排序好的数列，升序bisect.insort(list, 5).<br>二分法查找位置，插入位置bisect.bisect(list, 3)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import bisect</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line">bisect.insort(4)</span><br><span class="line">bisect.insort(1)</span><br><span class="line">bisect.insort(3)</span><br><span class="line">bisect.insort(2)</span><br><span class="line">print(l) #[1,2,3,4]</span><br></pre></td></tr></table></figure>

<p>arrary和list重要区别，array只能存放指定的数据类型。布隆过滤器。<br>arrary是c中的数组，一串连续的内存块，性能高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import array</span><br><span class="line">_a = array.array(&apos;i&apos;) # int,参数查看文档</span><br><span class="line">_a.append()</span><br></pre></td></tr></table></figure>

<h3 id="列表推导式（生成式）-amp-生成器表达式"><a href="#列表推导式（生成式）-amp-生成器表达式" class="headerlink" title="列表推导式（生成式）&amp;生成器表达式"></a>列表推导式（生成式）&amp;生成器表达式</h3><p>通过一行代码生成列表。</p>
<p>列表生成式性能能高于列表操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odd_list = [i for i in range(21) if i%2 == 1]</span><br></pre></td></tr></table></figure>

<p>复杂情况的列表生成式，可以使用函数实现.（过于复杂就放弃吧，代码可读性更重要）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def sqrt(item):</span><br><span class="line">    return item*item</span><br><span class="line">odd_list = [sqrt(i) for i in range(21) if i%2 == 1]</span><br></pre></td></tr></table></figure>

<p>生成器表达式为小括号，type变为generator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odd_list = (i for i in range(21) if i%2 == 1)</span><br></pre></td></tr></table></figure>

<p>字典推导式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dict =&#123;&apos;a&apos;:1, &apos;b&apos;:2&#125;</span><br><span class="line">_reversed = &#123;value:key for key, value in my_dict.items()&#125; # 交换value,key</span><br></pre></td></tr></table></figure>

<p>集合推导式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;key for key,value in my_dict.items()&#125;</span><br><span class="line">type(my_set)  # set</span><br></pre></td></tr></table></figure>

<h3 id="深入set和dict"><a href="#深入set和dict" class="headerlink" title="深入set和dict"></a>深入set和dict</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a.copy() #浅拷贝</span><br><span class="line"></span><br><span class="line">import copy </span><br><span class="line"></span><br><span class="line">copy.deepcopy(a) #深拷贝</span><br></pre></td></tr></table></figure>

<p>浅拷贝就是创建一个具有相同类型，相同值（值的id也相同）但不同id的新对象。</p>
<p>深拷贝值为list时，list的id不同。</p>
<p>深拷贝不仅仅拷贝了原始对象自身，也对其包含的值进行拷贝，它会递归的查找对象中包含的其他对象的引用，来完成更深层次拷贝。因此，深拷贝产生的副本可以随意修改而不需要担心会引起原始值的改变。</p>
<h4 id="dict的formkeys方法"><a href="#dict的formkeys方法" class="headerlink" title="dict的formkeys方法"></a>dict的formkeys方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [&apos;a&apos;, &apos;b&apos;]</span><br><span class="line">d = dict.fromkeys(l, &#123;&apos;c&apos;,&apos;d&apos;&#125;)</span><br><span class="line">print(d) #&#123;&apos;a&apos;: &#123;&apos;c&apos;, &apos;d&apos;&#125;, &apos;b&apos;: &#123;&apos;c&apos;, &apos;d&apos;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_d[&apos;key&apos;]  #key不存在会抛异常</span><br><span class="line">_dict.get(&quot;a&quot;, &#123;&#125;) #get方法非常实用！&#123;&#125;为默认值</span><br></pre></td></tr></table></figure>

<h4 id="items"><a href="#items" class="headerlink" title="items"></a>items</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for key, value in _d.items()：</span><br><span class="line">    print(k,v)   #烂大街的好方法</span><br></pre></td></tr></table></figure>

<h4 id="setdefault-增加get方法"><a href="#setdefault-增加get方法" class="headerlink" title="setdefault 增加get方法"></a>setdefault 增加get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setdefault(key, default)</span><br><span class="line"># 1.先调用get()</span><br><span class="line"># 2.没有则默认值</span><br><span class="line"># 3.再把默认值设置进dict</span><br></pre></td></tr></table></figure>

<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p>合并字典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dict.update(&#123;&apos;c&apos;:1&#125;)</span><br><span class="line">_dict.update(&quot;a&quot;=1,&quot;b&quot;=2) #放iterm都可以</span><br><span class="line">_dict.update(（（’e‘,&apos;f&apos;），）) #传入tuple</span><br></pre></td></tr></table></figure>

<h3 id="dict子类"><a href="#dict子类" class="headerlink" title="dict子类"></a>dict子类</h3><p>写类不建议继承list和dict<br>某些时候c不会使用覆盖的方法，而是会用dict本身的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from collections import UserDict </span><br><span class="line">#推荐使用UserDict被python重写过</span><br><span class="line">class Mydict(UserDict):</span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        super().__setitem__(key, value*2)</span><br><span class="line"></span><br><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line"># 如果找不到key,就赋值</span><br><span class="line">my_dict = defaultdict(dict())</span><br><span class="line">my_value = my_dict[&apos;fank&apos;] #这里我的py3.7.1报错了</span><br></pre></td></tr></table></figure>

<h3 id="set-fronzenset"><a href="#set-fronzenset" class="headerlink" title="set fronzenset"></a>set fronzenset</h3><p>set和fronzenset(不可变)无序，不重复，在去重时用的很多，并且fronzenset是不可变类型，所以可以做为dict的key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = set(&apos;abcd&apos;)</span><br><span class="line">s1 = &#123;&apos;a&apos;, &apos;b&apos;&#125; #type是set</span><br><span class="line">s2 = frozenset(&apos;abcde&apos;) #无法add值，</span><br></pre></td></tr></table></figure>

<h4 id="set-difference"><a href="#set-difference" class="headerlink" title="set difference"></a>set difference</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;</span><br><span class="line">ans = set(&apos;cef&apos;)</span><br><span class="line">rs = s.difference(ans)</span><br><span class="line">print(rs) # &#123;&apos;a&apos;,&apos;b&apos;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dict和set实现原理"><a href="#dict和set实现原理" class="headerlink" title="dict和set实现原理"></a>dict和set实现原理</h4><p>dict 查哈希表，key必须为可哈希的值。str,fset,tuple,自己实现的类</p>
<p>dict的内存花销大，查询速度快</p>
<p>垃圾回收算法是采用引用计数 del</p>
<h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>property动态属性，User.age可以取属性，不用调函数，类似get，set为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class User:</span><br><span class="line">    def __init__(self, birthday):</span><br><span class="line">        self.birthday = birthday</span><br><span class="line">        self._age = 0</span><br><span class="line">    @propery  #装饰器。讲age变为属性描述符,直接调用</span><br><span class="line">    def age(self):</span><br><span class="line">        return datetime.now().year - self.birthday.year</span><br><span class="line">    @age.setter  #设置</span><br><span class="line">    def age(self, value):</span><br><span class="line">        self._age = value</span><br><span class="line">    </span><br><span class="line">user = User(year=&apos;1992&apos;)</span><br><span class="line">user.age</span><br><span class="line">user.age = 26  #属性赋值</span><br></pre></td></tr></table></figure>

<h3 id="getattr与getattribute的区别"><a href="#getattr与getattribute的区别" class="headerlink" title="getattr与getattribute的区别"></a><strong>getattr</strong>与<strong>getattribute</strong>的区别</h3><p><strong>getattr</strong>在查找不到属性的时候调用(写了就不会报错).维护dict动态访问key</p>
<p>def <strong>getattr</strong>(self, item): return “not find”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from datetime import date</span><br><span class="line">class User:</span><br><span class="line">    def __init__(self, name,info=&#123;&#125;):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.info = info</span><br><span class="line">        </span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">        return self.info[item]</span><br><span class="line">user = User(&apos;fank&apos;, info=&#123;&apos;a&apos;:1&#125;)</span><br><span class="line">user.a</span><br></pre></td></tr></table></figure>

<p>def <strong>getattribute</strong>(self, item): return “true”<br>优先级别高，无条件进入这个函数，它控制全局属性访问</p>
<h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>在赋值的时候检查属性<br>实现了<strong>get</strong>,<strong>set</strong>,<strong>delete</strong>三个中的任意一个的类都是属性描述符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class IntField:</span><br><span class="line">    def __get__(self, instance):</span><br><span class="line">        return self.value</span><br><span class="line">    def __set__(self, instance,value):</span><br><span class="line">        if isinstance(value, numbers.Interagral):</span><br><span class="line">            raise ValueError(&apos;int value need&apos;)</span><br><span class="line">        self.value = value</span><br><span class="line">    def __delete__(self, instance):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class User:</span><br><span class="line">    age = Intfield()</span><br></pre></td></tr></table></figure>

<p>数据描述符都实现<br>非数据描述符只实现<strong>get</strong></p>
<p>属性查找过程</p>
<p>传递方法为变化的user.age方式无法实现， 使用getattr(user, age)</p>
<h3 id="new和init区别"><a href="#new和init区别" class="headerlink" title="new和init区别"></a><strong>new</strong>和<strong>init</strong>区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class User:</span><br><span class="line">    def __new__(cls, *args, **kwargs): #写框架使用很频繁</span><br><span class="line">        pass</span><br><span class="line">        return super().__new__(cls)</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">user = User(&apos;fank&apos;)</span><br></pre></td></tr></table></figure>

<p>new传递类cls，在init之前，new控制对象的生成过程.<br>如果new不返回对象，不会调用init函数</p>
<p>type是默认元类，metaclass是自定义元类，可以控制实例化过程</p>
<h3 id="元类编程"><a href="#元类编程" class="headerlink" title="元类编程"></a>元类编程</h3><p>类也是对象，type是用来创建类的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def create_class(name):</span><br><span class="line">    if name == &quot;user&quot;:</span><br><span class="line">        class User:</span><br><span class="line">            def __str__(self):</span><br><span class="line">                return &apos;user&apos;</span><br><span class="line">        return User</span><br><span class="line">    elif name == &quot;company&quot;:</span><br><span class="line">        class Company:</span><br><span class="line">            def __str__(self):</span><br><span class="line">                return &apos;Company&apos;</span><br><span class="line">        return Company</span><br><span class="line"></span><br><span class="line">#type是可以创建类的。动态创建类</span><br><span class="line">User = type(&quot;User&quot;, (), &#123;&quot;name&quot;:&quot;user&quot;&#125;)  #第二个参数继承基类必写</span><br><span class="line">u = User()</span><br><span class="line">print(u.name)</span><br><span class="line"></span><br><span class="line">#如何给type写方法</span><br><span class="line">def say(self):</span><br><span class="line">    retun &quot;i am user&quot;</span><br><span class="line">User = type(&quot;User&quot;, (), &#123;&quot;name&quot;:&quot;user&quot;, &quot;say&quot;:say&#125;) </span><br><span class="line">u = User()</span><br><span class="line">print(u.say)</span><br><span class="line">#继承</span><br><span class="line">User = type(&quot;User&quot;, (Baseclass,), &#123;&quot;name&quot;:&quot;user&quot;, &quot;say&quot;:say&#125;)</span><br></pre></td></tr></table></figure>

<p>元类是创建类的类， 对象&lt;-class&lt;-type</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MetaClass(type):</span><br><span class="line">    def __new__(self, *args, **kwargs):</span><br><span class="line">        return super().__new__(cls, *args, **kwargs) #带*参数必传否则会报错</span><br><span class="line"></span><br><span class="line">class User(metaclass=MetaClass):  #当不写metaclass会默认调用type创建类对象</span><br><span class="line">    pass</span><br><span class="line">#python类的实例化过程中，会首先寻找metaclass,通过metaclass创建类，控制实例化过程</span><br></pre></td></tr></table></figure>

<h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><p>迭代器是访问集合内元素的一种方式，一般用来遍历数据。</p>
<p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。实现了<code>__iter__</code>和<code>__next__()</code>方法的对象都是迭代器。</p>
<p>可以使用isinstance()判断一个对象是否是Iterator对象。</p>
<p>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</p>
<p>python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
<p>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(iter([]), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>next(itor)接受迭代器，迭代器next无法切片。文件太大使用迭代器读数据</p>
<p><strong>iter</strong>迭代协议，可迭代的实现方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from collections.abc import Iterable,Iterator</span><br><span class="line"></span><br><span class="line">iter([_list]) #将list变为迭代器</span><br><span class="line"></span><br><span class="line">def __iter__(self) / def __getitem__(self, item)</span><br></pre></td></tr></table></figure>

<p>生成器函数，函数内有yield关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def gen_func(): </span><br><span class="line">    yield 1 yield2 yield3</span><br></pre></td></tr></table></figure>

<p>python在编译时字节码发现yield于是变为生成器<br>python查看字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import dis</span><br><span class="line">print(dis.dis(func))</span><br></pre></td></tr></table></figure>

<p>gen = gen_func() #gen生成器对象，不是值</p>
<p>for i in gen: print(i) 惰性求值提供了可能，比list好处是省内存</p>
<p>生成器读取大文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#数据在文件中只有1行</span><br><span class="line">f = open()</span><br><span class="line">f.read(4096) #一次读取的大小，偏移量</span><br><span class="line"></span><br><span class="line">def myreadlines(f, newline):</span><br><span class="line">    buf = &quot;&quot;</span><br><span class="line">    while True:</span><br><span class="line">        while newline in buf:</span><br><span class="line">            pos = buf.index(newline)</span><br><span class="line">            yield buf[:pos]</span><br><span class="line">            buf = buf[pos + len(newline):]</span><br><span class="line">        chunk = f.read(4096)</span><br><span class="line">        </span><br><span class="line">        if not chunk:</span><br><span class="line">            yield buf</span><br><span class="line">            break</span><br><span class="line">        buf += chunk</span><br></pre></td></tr></table></figure>

<h3 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h3><p>服务端socket</p>
<ol>
<li>bind(协议，地址，端口）</li>
<li>listen(监听客户端socket请求）</li>
<li>accept()</li>
<li>阻塞等待连接请求（新套接字）</li>
<li>recv()</li>
<li>send()</li>
<li>close()</li>
</ol>
<p>客户端socket</p>
<ol>
<li>connect() 三次握手 -&gt; 等待套接字</li>
<li>send() -&gt; recv() server #接受bytes类型需要编码</li>
<li>recv() -&gt; send() server</li>
<li>close()</li>
</ol>
<p>爬虫是典型的客户端socket<br>如果使得服务端可以多用户连接？<br>将每个socket做为线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line"></span><br><span class="line">server.bind((&apos;0.0.0.0&apos;, 8000))</span><br><span class="line"></span><br><span class="line">server.listen()</span><br><span class="line"></span><br><span class="line">sock, addr = server.accept()</span><br><span class="line"></span><br><span class="line">data = server.recv(1024) #1kb</span><br></pre></td></tr></table></figure>

<p>socketHttp<br>reqeusts -&gt; urlib -&gt; socket</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">from urllib.parse import urlparse</span><br><span class="line"></span><br><span class="line">def get_url(url):</span><br><span class="line">    # get html by socket</span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    if path == &apos;&apos;:</span><br><span class="line">        path = &apos;/&apos;</span><br><span class="line">        </span><br><span class="line">    #connect socket</span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.connect((host, 80))</span><br><span class="line">    client.send(&quot;GET &#123;&#125; HTTP/1.1\r\nHOST:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode(&apos;utf8&apos;))</span><br><span class="line">    </span><br><span class="line">    data = b&apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        d = client.recv(1024)</span><br><span class="line">        if d:</span><br><span class="line">            data += d</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    data = data.decode(&apos;utf8&apos;)</span><br><span class="line">    htmldata = data.split(&apos;\r\n\r\n&apos;)[1]</span><br><span class="line">    print(htmldata)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    get_url(&apos;http://www.baidu.com&apos;)</span><br></pre></td></tr></table></figure>

<h3 id="线程-amp-进程"><a href="#线程-amp-进程" class="headerlink" title="线程&amp;进程"></a>线程&amp;进程</h3><p>GIL global interpreter lock GIL全局解释锁</p>
<p>python中一个线程对应于c中的线程</p>
<p>python是先将py文件编译为字节码</p>
<p>gil使得同一时刻只有一个线程在一个cpu上执行字节码，无法将多个线程映射到多个cpu上 </p>
<p>为了安全，但速度慢，无法体现多核优势。pypy是去gil化的。gil在遇到io操作会主动释放</p>
<p>操作系统调度的最小单元线程，对于io操作，多线程和多进程差别不大。</p>
<h4 id="通过thread类实例化"><a href="#通过thread类实例化" class="headerlink" title="通过thread类实例化"></a>通过thread类实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1 = threading.Thread(target=func, args=(&quot;&quot;,))</span><br><span class="line"></span><br><span class="line">thread1.setDaemon(True)#设置为守护线程。当主线程关闭时，子线程被kill</span><br><span class="line"></span><br><span class="line">thread1.join() #阻塞，等待thread1子线程执行完成</span><br></pre></td></tr></table></figure>

<h4 id="继承thread来实现多线程"><a href="#继承thread来实现多线程" class="headerlink" title="继承thread来实现多线程"></a>继承thread来实现多线程</h4><p>当代码量大，逻辑复杂时，推荐通过继承thread来实现多线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class GetDetailHtml(threading.Thread):</span><br><span class="line">    def __init__(self, name):   #为线程命名，好习惯</span><br><span class="line">        super().__init__(name=name)</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;get detail html&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&apos;get detail html done&apos;)</span><br><span class="line"></span><br><span class="line">class GetTitleHtml(threading.Thread):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        super().__init__(name=name)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;get title url&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&apos;get title url done&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    thread1 = GetTitleHtml(&apos;get title html&apos;)</span><br><span class="line">    thread2 = GetDetailHtml(&apos;get detail html&apos;)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line">    print(&apos;last time &#123;&#125;&apos;.format(time.time() - start_time))</span><br></pre></td></tr></table></figure>



<h3 id="线程之间的通信方式"><a href="#线程之间的通信方式" class="headerlink" title="线程之间的通信方式"></a>线程之间的通信方式</h3><h4 id="1-共享全局变量-list-（多线程可以，多进程不行）"><a href="#1-共享全局变量-list-（多线程可以，多进程不行）" class="headerlink" title="1.共享全局变量(list)（多线程可以，多进程不行）"></a>1.共享全局变量(list)（多线程可以，多进程不行）</h4><p>这种方法，线程并不安全，需要加gil锁，所以并不推荐用作通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">#1.共享全局变量</span><br><span class="line">detail_url_list = []</span><br><span class="line"></span><br><span class="line">def get_title_html(detail_url_list):</span><br><span class="line">    print(&apos;get title url&apos;)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    for i in range(20):</span><br><span class="line">        detail_url_list.append(&apos;http://www.test.com/id/&#123;&#125;/&apos;.format(i))</span><br><span class="line">    print(&apos;get title url done&apos;)</span><br><span class="line"></span><br><span class="line">def get_detail_html(detail_url_list):</span><br><span class="line">    print(&apos;get detail html&apos;)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    if len(detail_url_list):</span><br><span class="line">        url = detail_url_list.pop()</span><br><span class="line">        print(&apos;get detail html done&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    thread1 = threading.Thread(target=get_title_html, args=(detail_url_list,))</span><br><span class="line">    for i in range(10): #启动10个线程，太多线程操作系统切换会产生很大代价</span><br><span class="line">        html_thread = threading.Thread(target=get_detail_html, args=(detail_url_list,))</span><br><span class="line">        html_thread.start()</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    print(&apos;last time &#123;&#125;&apos;.format(time.time() - start_time))</span><br></pre></td></tr></table></figure>

<h4 id="2-通过queue方法进行线程间通讯-queue本身是线程安全的"><a href="#2-通过queue方法进行线程间通讯-queue本身是线程安全的" class="headerlink" title="2.通过queue方法进行线程间通讯,queue本身是线程安全的"></a>2.通过queue方法进行线程间通讯,queue本身是线程安全的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def get_title_html(queue):</span><br><span class="line">    while True:</span><br><span class="line">        print(&apos;get title url&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        for i in range(20):</span><br><span class="line">            queue.put(&apos;http://www.test.com/id/&#123;&#125;/&apos;.format(i))</span><br><span class="line">        print(&apos;get title url done&apos;)</span><br><span class="line"></span><br><span class="line">def get_detail_html(queue):</span><br><span class="line">    while True:</span><br><span class="line">        print(&apos;get detail html&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        url = queue.get()  #get方法是阻塞方法，如果queue为空就等待</span><br><span class="line">        print(&apos;get detail html done&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    detail_queue = Queue(maxsize=1000)</span><br><span class="line">    thread1 = threading.Thread(target=get_title_html, args=(detail_queue,))</span><br><span class="line">    for i in range(10): #启动10个线程，太多线程操作系统切换会产生很大代价</span><br><span class="line">        html_thread = threading.Thread(target=get_detail_html, args=(detail_queue,))</span><br><span class="line">        html_thread.start()</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    print(&apos;last time &#123;&#125;&apos;.format(time.time() - start_time))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">queue.get()#阻塞方法，如果为空就一直停顿等待</span><br><span class="line">queue.put_nowait()#设置为非阻塞</span><br><span class="line">queue.qsize() #获取长度，同样是线程安全的可以直接使用</span><br><span class="line">queue.empty()</span><br><span class="line">queue.full()</span><br><span class="line">queue.join()#阻塞直到执行到task_done()</span><br><span class="line">queue.task_done()</span><br></pre></td></tr></table></figure>

<p>.join()一直阻塞，想退出需要调用.task_down() #爬虫暂停</p>
<p>如果共用变量为dict或其他非队列数据，也可以考虑使用全局变量</p>
<h3 id="线程同步（lock-rlock）"><a href="#线程同步（lock-rlock）" class="headerlink" title="线程同步（lock, rlock）"></a>线程同步（lock, rlock）</h3><p>避免淘宝库存同时有人买<br>线程同步机制,lock锁，反正锁住的代码段都只能有一个在运行，释放之后才能让其他代码运行.</p>
<p>使用锁会出现的问题</p>
<ol>
<li>用锁会影响性能</li>
<li>锁会引起死锁（互相等待）,不能连续调用两次acquire</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from threading import Lock</span><br><span class="line"></span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line">global lock</span><br><span class="line"></span><br><span class="line">lock.acquire() #获取</span><br><span class="line"></span><br><span class="line">a += 1</span><br><span class="line"></span><br><span class="line">lock.release() #释放</span><br></pre></td></tr></table></figure>

<p>死锁情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A(a, b)</span><br><span class="line">acquire(a)</span><br><span class="line">acquire(b)</span><br><span class="line"></span><br><span class="line">B(a, b)</span><br><span class="line">acquire(b) # a,b同时等待</span><br><span class="line">acquire(a)</span><br></pre></td></tr></table></figure>

<h4 id="rlock可重入的锁"><a href="#rlock可重入的锁" class="headerlink" title="rlock可重入的锁"></a>rlock可重入的锁</h4><p>解决lock，不能连续调用acquire的问题。它可以在同一个线程里面，可以连续调用多次acquire，需要相等数量的release.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from threading import RLock</span><br><span class="line">lock = Rlock()</span><br><span class="line"></span><br><span class="line">lock.acquire()</span><br><span class="line">lock.acquire()</span><br><span class="line">lock.release()</span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure>

<h3 id="condition条件变量"><a href="#condition条件变量" class="headerlink" title="condition条件变量"></a>condition条件变量</h3><p>用于复杂的线程间同步锁</p>
<p>wait()允许等待某个条件变量的通知<br>notify()会通知调用了wait()方法的那个线程启动</p>
<ol>
<li>使用condition启动顺序非常重要</li>
<li>一定要先调用with方法或者acquire和release，之后再调用wait(),notify()</li>
<li>condition有两层锁，一把底层锁会在线程调用wait方法的时候释放，上面的锁会值每次调用wait时分配一把并放入到cond的等待队列中，等到notify方法唤醒</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">from threading import Condition</span><br><span class="line"></span><br><span class="line">class XiaAi(threading.Thread):</span><br><span class="line">    def __init__(self, cond):</span><br><span class="line">        super().__init__(name=&apos;小爱&apos;)</span><br><span class="line">        self.cond = cond</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        with self.cond:</span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(&apos;&#123;&#125;: 在&apos;.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line">            print(&apos;&#123;&#125;: 好啊&apos;.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">    </span><br><span class="line">class TianMao(threading.Thread):</span><br><span class="line">    def __init__(self, cond):</span><br><span class="line">        super().__init__(name=&apos;天猫&apos;)</span><br><span class="line">        self.cond = cond</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        with self.cond:</span><br><span class="line">            print(&apos;&#123;&#125;: 小爱同学&apos;.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">            print(&apos;&#123;&#125;: 我们来对古诗吧&apos;.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    cond = threading.Condition()</span><br><span class="line"></span><br><span class="line">    xiaoai = XiaAi(cond)</span><br><span class="line">    tianmao = TianMao(cond)</span><br><span class="line"></span><br><span class="line">    xiaoai.start()</span><br><span class="line">    tianmao.start()</span><br><span class="line">    xiaoai.join()</span><br><span class="line">    tianmao.join()</span><br></pre></td></tr></table></figure>



<h3 id="Semaphore-控制线程并发数量"><a href="#Semaphore-控制线程并发数量" class="headerlink" title="Semaphore 控制线程并发数量"></a>Semaphore 控制线程并发数量</h3><p>#文件读写，写一般只用一个线程，读可以允许有多个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HtmlSpider(threading.Thread):</span><br><span class="line">    def __init__(self, url, sem):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.url = url</span><br><span class="line">        self.sem = sem</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&apos;get html success&apos;)</span><br><span class="line">        self.sem.release()</span><br><span class="line"></span><br><span class="line">class UrlProducer(threading.Thread):</span><br><span class="line">    def __init__(self, sem):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.sem = sem</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        for i in range(10):</span><br><span class="line">            self.sem.acquire()</span><br><span class="line">            html_thread = HtmlSpider(&apos;http://www.baidu.com/id/&#123;&#125;/&apos;.format(i), self.sem)</span><br><span class="line">            html_thread.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sem = threading.Semaphore(3)</span><br><span class="line">    url_thread = UrlProducer(sem)</span><br><span class="line">    url_thread.start()</span><br></pre></td></tr></table></figure>



<h3 id="线程池concurrent-py3-2"><a href="#线程池concurrent-py3-2" class="headerlink" title="线程池concurrent #py3.2"></a>线程池concurrent #py3.2</h3><p>concurrent容易的编写多线程，多进程代码</p>
<p>为什么使用线程池？</p>
<p>1.主线程中可以获取某一个线程的状态或者某一个任务的状态，以及返回值</p>
<p>2.当一个线程完成的时候，主线程能立即知道</p>
<p>3.futures可以让多线程多进程编码接口一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor,as_completed,wait,FIRST_COMPLETED</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def get_html(times):</span><br><span class="line">    time.sleep(times)</span><br><span class="line">    print(&apos;get html &#123;&#125; success&apos;.format(times))</span><br><span class="line">    return times</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=2)</span><br><span class="line"></span><br><span class="line">#通过submit提交执行的函数到线程池中，submit是立即返回</span><br><span class="line">task1 = executor.submit(get_html, (3))</span><br><span class="line">task2 = executor.submit(get_html, (2))</span><br><span class="line">print(task1.done())</span><br><span class="line">#取消线程执行，状态done无论为true和false都不能取消执行。只有还没提交到线程池中的线程才能提交，与max_workers的设置有关</span><br><span class="line">print(task2.cancel(2))</span><br><span class="line">time.sleep(3.1)</span><br><span class="line">#done()查看该线程当前的执行状态</span><br><span class="line">print(task1.done())</span><br><span class="line">#result()获取该线程的返回结果</span><br><span class="line">print(task1.result())</span><br><span class="line"></span><br><span class="line">#as_completed获取已经成功的task的返回，如爬虫</span><br><span class="line">urls = [2,3,4,2]</span><br><span class="line">all_task = [executor.submit(get_html, (url)) for url in urls]</span><br><span class="line">for future in as_completed(all_task):</span><br><span class="line">    data = future.result()</span><br><span class="line">    print(&apos;get &#123;&#125; page success&apos;.format(data))</span><br><span class="line"></span><br><span class="line">#使用executor的map方法对as_completed进行简化.map的返回结果就是future.result()</span><br><span class="line">#map的返回顺序是按照list的顺序，并不是先执行完就返回</span><br><span class="line">for data in executor.map(get_html, urls):</span><br><span class="line">    print(&apos;get &#123;&#125; page success&apos;.format(data))</span><br><span class="line">#wait设置阻塞，参数可选择条件默认为ALL_COMPLETED</span><br><span class="line">wait(all_task, return_when=FIRST_COMPLETED)</span><br><span class="line">print(&apos;main&apos;)</span><br></pre></td></tr></table></figure>



<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>线程由于有gil无法并发，python多线程无法利用多cpu。</p>
<p>耗cpu的操作，多核cpu，计算，图像，挖矿多进程优于多线程。<br>io操作进程切换代价高于线程。</p>
<p>进程数据完全隔离,无法使用共享全局变量</p>
<p>子进程完全拷贝Fork之后的父进程代码运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor,as_completed</span><br><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">def fib(n):</span><br><span class="line">    if n &lt;=2:</span><br><span class="line">        return 1</span><br><span class="line">    return fib(n-1)+fib(n-2)</span><br><span class="line"></span><br><span class="line"># 耗cpu的操作多进程比多线程速度快</span><br><span class="line">with ProcessPoolExecutor(3) as executor:  #win使用多进程必须在__name==&apos;__main__&apos;下运行</span><br><span class="line"># with ThreadPoolExecutor(3) as executor:</span><br><span class="line">    alltask = [executor.submit(fib, (num)) for num in range(25,40)]</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    for future in as_completed(alltask):</span><br><span class="line">        data = future.result()</span><br><span class="line">        print(&apos;exec result &#123;&#125;&apos;.format(data))</span><br><span class="line">    </span><br><span class="line">    print(&apos;last time is :&#123;&#125;&apos;.format(time.time() - start_time))</span><br><span class="line"></span><br><span class="line"># io操作多线程比多进程快</span><br><span class="line">def random_sleep(n):</span><br><span class="line">    time.sleep(n)</span><br><span class="line">    return n</span><br></pre></td></tr></table></figure>

<h4 id="更加底层的多进程包"><a href="#更加底层的多进程包" class="headerlink" title="更加底层的多进程包"></a>更加底层的多进程包</h4><p>学习底层，生产环境还是推荐conncurrent</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line">print(&apos;fank&apos;)</span><br><span class="line">if pid == 0:  #pid=0 child pro</span><br><span class="line">    print(&apos;child process &#123;&#125;. parent process &#123;&#125;&apos;.format(os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">    print(&apos;parent process &#123;&#125;&apos;.format(pid))</span><br><span class="line"></span><br><span class="line">time.sleep(2)</span><br><span class="line"></span><br><span class="line">def get_html(n):</span><br><span class="line">    time.sleep(n)</span><br><span class="line">    print(&apos;sub progress success&apos;)</span><br><span class="line">    return n</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    program = multiprocessing.Process(target=get_html, args=(2,))</span><br><span class="line">    program.start()</span><br><span class="line">    program.join()</span><br><span class="line">    print(program.pid) #比线程多个pid属性</span><br><span class="line">    print(&apos;main progress end&apos;)</span><br><span class="line"></span><br><span class="line">    #进程池</span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    result = pool.apply_async(get_html,args=(3,))</span><br><span class="line"></span><br><span class="line">    #等待所有任务完成</span><br><span class="line">    pool.close()  #关闭接受新的进程</span><br><span class="line">    pool.join()</span><br><span class="line">    print(result.get())</span><br><span class="line"></span><br><span class="line">    #imap  按顺序输出</span><br><span class="line">    for result in pool.imap(get_html, [1,5,3]):</span><br><span class="line">        print(&apos;&#123;&#125; sleep success&apos;.format(result))</span><br><span class="line"></span><br><span class="line">    #imapunordered  按执行速度输出</span><br><span class="line">    for result in pool.imap_unordered(get_html, [1,5,3]):</span><br><span class="line">        print(&apos;&#123;&#125; sleep success&apos;.format(result))</span><br></pre></td></tr></table></figure>

<h3 id="进程间的通讯"><a href="#进程间的通讯" class="headerlink" title="进程间的通讯"></a>进程间的通讯</h3><p>共享全局变量在多进程中不适用</p>
<p>mutiprocessing.queue用于进程间的通讯</p>
<p>进程池中的通讯有3个queue需要区分</p>
<ol>
<li>系统from queue import Queue不能用于通讯</li>
<li>from mutiprocessing import Queue 不能用在进程池通讯</li>
<li>from mutiprocessing import Manager().queue 用于进程池pool中的通讯</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from multiprocessing import Process, Queue, Manager, Pipe</span><br><span class="line"></span><br><span class="line">def producer(queue):</span><br><span class="line">    queue.put(&apos;a&apos;)</span><br><span class="line">    time.sleep(2)</span><br><span class="line"></span><br><span class="line">def consumer(queue):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    queue = Queue(10)   #使用multi的queue</span><br><span class="line">    my_producer = Process(target=producer, args=(queue,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(queue,))</span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br><span class="line"></span><br><span class="line">    #manage 用于进程池中的通讯</span><br><span class="line">    queue = Manager().queue(10)</span><br><span class="line"></span><br><span class="line">    # pipe 用于两个进程间的通讯</span><br><span class="line">    # 通过pipe实现进程通信,pipe只适用与两个进程</span><br><span class="line">    # 为什么不直接用queue？因为pipe的性能高于queue</span><br><span class="line">    receiver_pipe, send_pipe = Pipe()</span><br><span class="line">    my_producer = Process(target=producer, args=(send_pipe,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(receiver_pipe,))</span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br><span class="line"></span><br><span class="line">    # 数据同步，以manager dict为例</span><br><span class="line">    def add_data(p_dict, key, value):</span><br><span class="line">        p_dict[key] = value</span><br><span class="line">    process_dict = Manager().dict()</span><br><span class="line">    first_progress = Process(target=add_data, args(process_dict,&apos;f&apos;,25))</span><br><span class="line">    second_progress = Process(target=add_data, args(process_dict,&apos;f2&apos;,27))</span><br><span class="line">    first_progress.start()</span><br><span class="line">    second_progress.start()</span><br><span class="line">    first_progress.join()</span><br><span class="line">    second_progress.join()</span><br></pre></td></tr></table></figure>

<h3 id="协程-（有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）"><a href="#协程-（有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）" class="headerlink" title="协程 （有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）"></a>协程 （有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>指在一个时间段内，有几个程序在同一个cpu上运行，但任意时刻只有一个程序在cpu上运行</p>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>指任意时刻有多个程序运行在多个cpu上</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>指代码调用io操作时，必须等待io操作完成才返回的调用方式</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>指代码调用io操作时，不必等待io操作完成就返回的调用方式（future）</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>指调用函数时，当前线程会被挂起（等待）</p>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><p>调用函数时，当前线程不会被挂起，而是立即返回</p>
<p>C10k问题，1999年被提出的一个挑战。要求在一颗1GHz CPU,2G内存,1gbps带宽，让单台服务器同时为1万个客户提供ftp服务。<br>如果为每个用户开一个线程，作为低配服务器做不到</p>
<h4 id="unix下五种io模型"><a href="#unix下五种io模型" class="headerlink" title="unix下五种io模型"></a>unix下五种io模型</h4><p>阻塞式io，在等待io操作时，cpu是空闲的</p>
<p>非阻塞式io，做计算任务或者单向发送请求，不需要等待返回的任务</p>
<p>I/O复用，select,poll,epoll由操作系统提供。<br>select查看那些socket或文件句柄已经准备好了，select可以同时监听多个socket</p>
<p>信号驱动式I/O,操作系统发起的用的较少</p>
<p>异步I/O(POSIX的aio_系列函数)，<br>其实很多并发框架都是使用io多路复用，用aio不多,aio与io复用并没有很明显的提升，编码难度比io复用高很多。</p>
<h3 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select,poll,epoll"></a>select,poll,epoll</h3><p>他们都是io多路复用机制。io多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般为读写就绪），能够通知程序进行相应的读写操作。但select,poll,epoll本质上都是同步io，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步io则无需自己负责进行读写，异步io的实现会负责把数据从内核拷贝到用户空间。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select函数监视的文件描述分3类，分别是writefds、readfds和exceptfds。调用后select函数会阻塞，知道有描述符就绪（数据可读可写，或有except),或者超时（timeout指定等待时间，如果立即返回设定为null）,函数返回。当select函数返回后，可以通过遍历fdset,来找到就绪的描述符。<br>select目前几乎在所有平台上支持。缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在linux上一般为1024，虽然可以修改，但是会造成效率降低。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。<br>pollfd没有最大数量限制。select和poll一样需要遍历文件描述符来获取已经就绪的socket，随着描述符数量增长，其效率也会下降。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>win不支持，linux2.6内核中提出，是select和poll的增强版。epoll查询使用性能很高的红黑树。<br>1.epoll并不代表一定比select好，在并发高的情况下，连接活跃度不高，epoll比较好（网站）。<br>并发性不高，同时连接活跃，select比较好（比如游戏）。</p>
<p>通过非阻塞io实现http请求</p>
<h4 id="C10M问题"><a href="#C10M问题" class="headerlink" title="C10M问题"></a>C10M问题</h4><p>如何利用8核心cpu，64G内存，在10gbps的网网上保持1000万并发连接</p>
<h4 id="协程解决的问题"><a href="#协程解决的问题" class="headerlink" title="协程解决的问题"></a>协程解决的问题</h4><p>主要是解决回调编写难的问题。保持性能+代码编写容易</p>
<p>1.采用同步的方式编写异步的代码<br>2.使用单线程去切换任务：<br>    1. 线程是由操作系统切换的，单线程切换意味着需要程序员去调度任务<br>    2. 不在需要锁，并发性高，如果单线程内切换函数，性能高于线程切换，</p>
<p>#传统函数调用方式 A-B-C,一旦调用其他函数，函数只运行一次然后退出<br>#我们需要一个可以暂停的函数，并且可以在适当的时候恢复该函数继续执行<br>#协程  -&gt; 有多个入口的函数，可以暂停的函数，并且可以向暂停的地方传入值<br>生成器就是可以暂停的函数</p>
<h3 id="生成器进阶send-close-throw"><a href="#生成器进阶send-close-throw" class="headerlink" title="生成器进阶send,close,throw"></a>生成器进阶send,close,throw</h3><p>send</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def gen_func():</span><br><span class="line">    #这种写法1.可以产出值 2.可以接受值</span><br><span class="line">    html = yield &quot;http://www.baidu.com&quot;</span><br><span class="line">    print(html)</span><br><span class="line">    yield 2</span><br><span class="line">    yield 3</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line">#生成器不仅可以产生值，还可以接受值</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    #启动生成器的方式有2种，1.next() 2.send</span><br><span class="line">    print(next(gen))</span><br><span class="line">    #send默认包含了next</span><br><span class="line">    print(gen.send(&apos;fank&apos;))</span><br><span class="line">    print(next(gen))</span><br></pre></td></tr></table></figure>

<p>close</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def gen_func():</span><br><span class="line">    #这种写法1.可以产出值 2.可以接受值</span><br><span class="line">    try:</span><br><span class="line">        yield &quot;http://www.baidu.com&quot;</span><br><span class="line">    except GeneratorExit:</span><br><span class="line">        pass</span><br><span class="line">    yield 2</span><br><span class="line">    yield 3</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line">#生成器不仅可以产生值，还可以接受值</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    #启动生成器的方式有2种，1.next() 2.send</span><br><span class="line">    print(next(gen))</span><br><span class="line">    gen.close()</span><br><span class="line">    print(next(gen))</span><br><span class="line"></span><br><span class="line">    #GeneratorExit是继承BaseException</span><br></pre></td></tr></table></figure>

<p>throw</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def gen_func():</span><br><span class="line">    #这种写法1.可以产出值 2.可以接受值</span><br><span class="line">    try:</span><br><span class="line">        yield &quot;http://www.baidu.com&quot;</span><br><span class="line">    except GeneratorExit:</span><br><span class="line">        pass</span><br><span class="line">    yield 2</span><br><span class="line">    yield 3</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line">#生成器不仅可以产生值，还可以接受值</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    #启动生成器的方式有2种，1.next() 2.send</span><br><span class="line">    print(next(gen))</span><br><span class="line">    gen.throw(Exception, &apos;download error&apos;) #没有向下执行，是当前yeild的异常</span><br></pre></td></tr></table></figure>

<h4 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h4><p>生成器实现协程是由程序员自己调度的，线程，进程由操作系统内核调度。协程是函数级别的</p>
<p>yield from是python3.3之后新加入的语法</p>
<p>python3.5之后的协程是原生协程，之前是利用生成器完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from itertools import chain</span><br><span class="line"></span><br><span class="line">my_list = [1,2,3]</span><br><span class="line">my_dict = &#123;</span><br><span class="line">    &apos;fank&apos;:&quot;fankcoder.com&quot;,</span><br><span class="line">    &apos;fank1&apos;:&quot;fankcoder1.com&quot;,</span><br><span class="line">    &apos;fank2&apos;:&quot;fankcoder2.com&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># yeild from 后面跟一个iterable</span><br><span class="line"># 但远不止这些，如果yeild from 跟生成器</span><br><span class="line">def my_chain(*args, **kwargs):</span><br><span class="line">    for item in args:</span><br><span class="line">        yield from item</span><br><span class="line">        # for each in item:</span><br><span class="line">        #     yield each</span><br><span class="line"></span><br><span class="line">for value in my_chain(my_list, my_dict, range(5,10)):</span><br><span class="line">    print(value)</span><br><span class="line"></span><br><span class="line">def g1(gen):</span><br><span class="line">    yield from gen</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    g = g1</span><br><span class="line">    g.send(None)</span><br><span class="line"></span><br><span class="line">#1. main调用生成器 2.g1委托生成器 3.gen子生成器</span><br><span class="line">#2. yield from 会在调用生成器和子生成器之间建立一个双向通道，</span><br><span class="line"># 两者可以互通，现在调用生成器可以直接发送close,throw到子生成器</span><br></pre></td></tr></table></figure>

<p>协程调度，事件循环+协程模式，协程是单线程模式.<br>编写时候凡是遇到耗io的操作，都用啥yield或yield from模式.<br>tornado是生成器生成的协程.</p>
<h4 id="async和await-原生协程"><a href="#async和await-原生协程" class="headerlink" title="async和await 原生协程"></a>async和await 原生协程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#python3.5以后为了将语义变得更加明确，就引入了async和await关键词来定义原生协程</span><br><span class="line"># async下不能再出现yield,同样await只能出现在async下</span><br><span class="line"># await 后面跟的函数必须是awaitable也就是加了async的函数</span><br><span class="line">import types</span><br><span class="line"></span><br><span class="line">async def downloader(url):</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line"># 另一种方法让函数变为awaitable，但是我没有试验成功。不过这种方法本来不推荐</span><br><span class="line">@types.coroutine</span><br><span class="line">def downloader2(url):</span><br><span class="line">    return &apos;fank2&apos;</span><br><span class="line"></span><br><span class="line">async def download_url(url):</span><br><span class="line">    # do something</span><br><span class="line">    # await对应生成器的yield from</span><br><span class="line">    html = await downloader2(url)</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    coro = download_url(&apos;http://www.google.com&apos;)</span><br><span class="line">    # next(coro)  原生协程不能这样调用</span><br><span class="line">    coro.send(None)</span><br></pre></td></tr></table></figure>

<h3 id="asyncio模块"><a href="#asyncio模块" class="headerlink" title="asyncio模块"></a>asyncio模块</h3><p>把它叫做异步Io库，并不叫协程库，这里包含了多线程，多进程，协程</p>
<ol>
<li>包含各种特定系统实现的模块化事件循环</li>
<li>传输和协议抽象</li>
<li>对tcp,udp,ssl,子进程，延时调用以及其他的具体支持</li>
<li>模仿Futures模块但适用于事件循环适用的Future类</li>
<li>基于yield from的协议和任务，可以让你用顺序的方式编写并发代码</li>
<li>必须使用一个将产生阻塞io的调用时，哟接口可以把这个事件转移到线程池</li>
<li>模仿threading模块中的同步原语，可以用在单线程内的协程之间</li>
</ol>
<p> asyncio 异步io并发编程 py3.4以后支持</p>
<p>事件循环</p>
<p>协程编码模式3个：1.事件循环 2.回调(驱动生成器) 3.epoll（io多路复用）</p>
<p>应用：tornado, gevent, twisted(scrapy, django channels)</p>
<p>ps: tornado不建议使用Pymysql,mysqlclient</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#事件循环+回调（驱动生成器）+epoll(IO多路复用)</span><br><span class="line">#asyncio是Python用于解决异步io的一整套解决方案</span><br><span class="line">#tornado,gevent,twisted(scrapy, dango channels(http2.0 websocket) 目前都是基于twisted)</span><br><span class="line">#tornado(实现了web服务器)，django+flask(uwsgi,gunicorn+nginx)</span><br><span class="line">#tornado可以直接部署，外加nginx</span><br><span class="line"></span><br><span class="line">#asyncio</span><br><span class="line">import asyncio</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">async def get_html(url):</span><br><span class="line">    print(&apos;start get html&apos;)</span><br><span class="line">    #time.sleep()  #不能使用同步阻塞的方法</span><br><span class="line">    await asyncio.sleep(2)  #耗时操作，io操作加await</span><br><span class="line">    print(&apos;end get url&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop  = asyncio.get_event_loop()  #事件循环，自动select</span><br><span class="line">    tasks = [get_html(&apos;http://www.google.com&apos;) for i in range(10)]</span><br><span class="line">    # loop.run_until_complete(get_html(&apos;http://www.google.com&apos;))</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(&apos;time:&apos;, time.time() - start_time)</span><br><span class="line"></span><br><span class="line">#获取协程的返回值</span><br><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line">async def get_html(url):</span><br><span class="line">    print(&apos;start get html&apos;)</span><br><span class="line">    #time.sleep()  #不能使用同步阻塞的方法</span><br><span class="line">    await asyncio.sleep(2)  #耗时操作，io操作加await</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line">def callback(url, future): #partial url 要写在前面</span><br><span class="line">    print(url)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop  = asyncio.get_event_loop()  #事件循环，自动select</span><br><span class="line">    # get_future = asyncio.ensure_future(get_html(&apos;http://www.google.com&apos;))  #一个线程只有一个loop，这里ensure_future自动帮我们获取loop</span><br><span class="line">    task = loop.create_task(get_html(&apos;http://www.google.com&apos;))  #和上一句等效</span><br><span class="line">    # loop.run_until_complete(get_html(&apos;http://www.google.com&apos;))</span><br><span class="line">    # task.add_done_callback(callback)</span><br><span class="line">    #如过callback需要传参</span><br><span class="line">    task.add_done_callback(partial(callback, &apos;http://www.googl.com&apos;))</span><br><span class="line"></span><br><span class="line">    # loop.run_until_complete(get_future)</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    # print(get_future.result())</span><br><span class="line">    print(&apos;time:&apos;, time.time() - start_time)</span><br><span class="line"></span><br><span class="line">#wait 和gather的用法和区别</span><br><span class="line">#gather更加高层，可以分组</span><br><span class="line">async def get_html(url):</span><br><span class="line">    print(&apos;start get html&apos;)</span><br><span class="line">    #time.sleep()  #不能使用同步阻塞的方法</span><br><span class="line">    await asyncio.sleep(2)  #耗时操作，io操作加await</span><br><span class="line">    print(&apos;end get url&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop  = asyncio.get_event_loop()  #事件循环，自动select</span><br><span class="line">    group1 = [get_html(&apos;http://www.google.com&apos;) for i in range(10)]</span><br><span class="line">    group2 = [get_html(&apos;http://www.google.com&apos;) for i in range(10)]</span><br><span class="line">    # loop.run_until_complete(get_html(&apos;http://www.google.com&apos;))</span><br><span class="line">    group2.cancel() #批量取消</span><br><span class="line">    loop.run_until_complete(asyncio.gather(*group1, *group2))</span><br><span class="line">    print(&apos;time:&apos;, time.time() - start_time)</span><br></pre></td></tr></table></figure>

<h4 id="取消task"><a href="#取消task" class="headerlink" title="取消task"></a>取消task</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># run_until_complete</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line"># loop = asyncio.get_event_loop()</span><br><span class="line"># loop.run_forever()  #不会停止，会一直运行</span><br><span class="line"># loop.run_until_complete()  #运行了指定的协程之后会停止</span><br><span class="line"></span><br><span class="line">async def get_html(sleep_times):</span><br><span class="line">    print(&apos;waiting&apos;)</span><br><span class="line">    await asyncio.sleep(sleep_times)</span><br><span class="line">    print(&apos;done after &#123;&#125;&apos;.format(sleep_times))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    task1 = get_html(2)</span><br><span class="line">    task2 = get_html(3)</span><br><span class="line">    task3 = get_html(3)</span><br><span class="line"></span><br><span class="line">    tasks = [task1, task2, task3]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    except KeyboardInterrupt as e:</span><br><span class="line">        all_tasks = asyncio.Task.all_tasks()</span><br><span class="line">        for task in all_tasks:</span><br><span class="line">            print(&apos;cancel task&apos;)</span><br><span class="line">            print(task.cancel())</span><br><span class="line">        loop.stop()</span><br><span class="line">        loop.run_forever()  #很关键，不加会报错</span><br><span class="line">    finally:</span><br><span class="line">        loop.close()</span><br></pre></td></tr></table></figure>

<h4 id="底层方法call-soon-call-later-call-at"><a href="#底层方法call-soon-call-later-call-at" class="headerlink" title="底层方法call_soon,call_later,call_at"></a>底层方法call_soon,call_later,call_at</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">#可以给asyncio直接传递函数（不是async函数）</span><br><span class="line">def callback(sleep_time):</span><br><span class="line">    print(&apos;sleep &#123;&#125; success&apos;.format(sleep_time))</span><br><span class="line"></span><br><span class="line">def stoploop(loop):</span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.call_soon(callback, 2)  #即刻执行，在队列里等到下一个循环立马执行</span><br><span class="line">    loop.call_soon(stoploop, loop)</span><br><span class="line"></span><br><span class="line">    loop.call_later(2,callback,2)  #在2秒钟之后运行callback</span><br><span class="line">    loop.call_later(1,callback,1)</span><br><span class="line">    loop.call_later(3,callback,3)</span><br><span class="line"></span><br><span class="line">    now = loop.time()  #loop的time</span><br><span class="line">    loop.call_at(now+2, callback, 2)</span><br><span class="line">    loop.call_at(now+3, callback, 3)</span><br><span class="line"></span><br><span class="line">    loop.call_soon_threadsafe()  #变量线程安全</span><br><span class="line"></span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure>

<h4 id="asyncio-ThreadPollExecutor"><a href="#asyncio-ThreadPollExecutor" class="headerlink" title="asyncio+ThreadPollExecutor"></a>asyncio+ThreadPollExecutor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#使用多线程:在协程中继承阻塞io(某些库就是阻塞的)</span><br><span class="line">import asyncio</span><br><span class="line">import socket</span><br><span class="line">from urllib.parse import urlparse</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">def get_url(url):</span><br><span class="line">    # get html by socket</span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    if path == &apos;&apos;:</span><br><span class="line">        path = &apos;/&apos;</span><br><span class="line">    </span><br><span class="line">    #connect socket</span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.connect((host, 80))</span><br><span class="line">    client.send(&quot;GET &#123;&#125; HTTP/1.1\r\nHOST:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode(&apos;utf8&apos;))</span><br><span class="line">    </span><br><span class="line">    data = b&apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        d = client.recv(1024)</span><br><span class="line">        if d:</span><br><span class="line">            data += d</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    data = data.decode(&apos;utf8&apos;)</span><br><span class="line">    htmldata = data.split(&apos;\r\n\r\n&apos;)[1]</span><br><span class="line">    print(htmldata)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    executor = ThreadPoolExecutor(3)</span><br><span class="line">    tasks = []</span><br><span class="line">    for i in range(20):</span><br><span class="line">        #参数1.线程池 2.函数名 3.函数参数</span><br><span class="line">       task = loop.run_in_executor(executor, get_url, &apos;http://www.baidu.com/&#123;&#125;&apos;.format(i))  #将某个阻塞Io函数放入executor中运行</span><br><span class="line">       tasks.append(task)</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>

<h4 id="同步的方式实现异步http模拟请"><a href="#同步的方式实现异步http模拟请" class="headerlink" title="同步的方式实现异步http模拟请"></a>同步的方式实现异步http模拟请</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#asyncio没有提供http协议的接口；aiohttp异步的requests，可以启动服务器，可以爬虫</span><br><span class="line">#同步的方式实现异步http模拟请求</span><br><span class="line">import asyncio</span><br><span class="line">import socket</span><br><span class="line">from urllib.parse import urlparse</span><br><span class="line"></span><br><span class="line">async def get_url(url):</span><br><span class="line">    # get html by socket</span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    if path == &apos;&apos;:</span><br><span class="line">        path = &apos;/&apos;</span><br><span class="line">    </span><br><span class="line">    #connect socket</span><br><span class="line">    reader, writer = await asyncio.open_connection(host, 80)  #线程</span><br><span class="line">    writer.write(&quot;GET &#123;&#125; HTTP/1.1\r\nHOST:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode(&apos;utf8&apos;))</span><br><span class="line">    </span><br><span class="line">    all_lines = []</span><br><span class="line">    async for raw_line in reader:  #异步化，因为内部有yield from语法</span><br><span class="line">        data = raw_line.decode(&apos;utf8&apos;)</span><br><span class="line">        all_lines.append(data)</span><br><span class="line"></span><br><span class="line">    html = &apos;\n&apos;.join(all_lines)</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = []</span><br><span class="line">    for i in range(20):</span><br><span class="line">        url = &apos;http://www.baidu.com/&#123;&#125;&apos;.format(i)</span><br><span class="line">        tasks.append(asyncio.ensure_future(get_url(url)))</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    for task in tasks:</span><br><span class="line">        print(task.result()</span><br></pre></td></tr></table></figure>

<h4 id="asyncio同步和通信"><a href="#asyncio同步和通信" class="headerlink" title="asyncio同步和通信"></a>asyncio同步和通信</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">from asyncio import Lock,Queue</span><br><span class="line">queue = Queue()</span><br><span class="line">await queue.get()</span><br><span class="line">queue1 = [] #普通的全局变量也能用，但是不能控制Size流量</span><br><span class="line"></span><br><span class="line">cache = &#123;&#125;</span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line">async def get_stuff(url):</span><br><span class="line">    async with lock:</span><br><span class="line">        # await lock.acquire()  #async </span><br><span class="line">        if url in cache:</span><br><span class="line">            return cache[url]</span><br><span class="line">        stuff = await aiohttp.request(&apos;get&apos;, url)</span><br><span class="line">        cache[url] = stuff</span><br><span class="line">        return stuff</span><br><span class="line">        # lock.release()  #不需要await</span><br><span class="line"></span><br><span class="line">async def parse_stuff():</span><br><span class="line">    stuff = await get_stuff()</span><br><span class="line"></span><br><span class="line">async def use_stuff():</span><br><span class="line">    stuff = await get_stuff()</span><br></pre></td></tr></table></figure>

<h3 id="aiohttp实现高并发爬虫"><a href="#aiohttp实现高并发爬虫" class="headerlink" title="aiohttp实现高并发爬虫"></a>aiohttp实现高并发爬虫</h3><h4 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h4><p>HTTP client/server framework for asyncio</p>
<p>server可以搭建http服务器</p>
<h3 id="client爬虫"><a href="#client爬虫" class="headerlink" title="client爬虫"></a>client爬虫</h3><p>爬取Url<br>抽取内部Url<br>过滤<br>反爬<br>分布式</p>
<h4 id="sanic"><a href="#sanic" class="headerlink" title="sanic"></a>sanic</h4><p>号称可以媲美go性能的高并发web服务器</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fankcoder.com/2019/03/08/technology-2019-03-08-appspider-tools/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fankcoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三秋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/03/08/technology-2019-03-08-appspider-tools/" class="post-title-link" itemprop="url">Ubuntu&OSX的app抓包方案</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-03-08 14:34:22 / Modified: 15:22:41" itemprop="dateCreated datePublished" datetime="2019-03-08T14:34:22+08:00">2019-03-08</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Ubuntu抓包方案"><a href="#Ubuntu抓包方案" class="headerlink" title="Ubuntu抓包方案"></a>Ubuntu抓包方案</h2><h2 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h2><p>电脑手机同一wifi (如果pc做了ip端口映射也可以使用广域网ip抓包)</p>
<h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><h3 id="Fiddler"><a href="#Fiddler" class="headerlink" title="Fiddler"></a>Fiddler</h3><p>Fiddler在Ubuntu上基于mono运行</p>
<p>Fiddler &amp; mono 下载地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fiddler.wikidot.com/mono</span><br></pre></td></tr></table></figure>

<ol>
<li>下载并装成功 </li>
<li>打开Fiddler-&gt; tools-&gt;options -&gt; connections  查看Port选项，记录下来</li>
<li>手机连接wifi并选择代理，方式手动代理</li>
<li>填写主机名为PC本地ip地址，端口填写刚刚记录的Port</li>
<li>打开手机app，观察Fiddler接受\发送的请求</li>
</ol>
<h2 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h2><h3 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h3><ol>
<li><p>下载安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.charlesproxy.com/download/</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开charles在Proxy-&gt;ProxySetting设置一个端口号，并勾选Enable</p>
</li>
<li><p>设置手机代理</p>
</li>
<li><p>如果手机包出现乱码情况，请安装charles证书（安装方法在最后）。如果手机无法安装.pem修改为.crt<br>（小米手机进入到设置-wifi，点击高级，安装证书）</p>
</li>
<li><p>打开手机app，观察charles接受\发送的请求</p>
</li>
</ol>
<h2 id="mac-osx抓包方案"><a href="#mac-osx抓包方案" class="headerlink" title="mac osx抓包方案"></a>mac osx抓包方案</h2><h3 id="Charles-1"><a href="#Charles-1" class="headerlink" title="Charles"></a>Charles</h3><p>使用手机安装SSL证书</p>
<p>在help-&gt;SSL Proxying-&gt; “nstall Charles Root Certificate on a Mobile Device or remote Browser”</p>
<p>然后根据提示访问安装</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fankcoder.com/2019/03/08/tool-2019-03-08-vscode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fankcoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三秋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/03/08/tool-2019-03-08-vscode/" class="post-title-link" itemprop="url">vscode配置手册</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-03-08 14:27:19" itemprop="dateCreated datePublished" datetime="2019-03-08T14:27:19+08:00">2019-03-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-13 23:28:51" itemprop="dateModified" datetime="2019-08-13T23:28:51+08:00">2019-08-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/工具/" itemprop="url" rel="index"><span itemprop="name">工具</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim</span><br><span class="line">atom dark theme</span><br><span class="line">al code outline</span><br><span class="line">python</span><br><span class="line">django</span><br><span class="line">chinese</span><br><span class="line">openAPI(Swagger)editor</span><br><span class="line">openapi-lint</span><br><span class="line">Swagger Viewer</span><br><span class="line">YAML</span><br></pre></td></tr></table></figure>

<h3 id="vim-插件不能响应长按的解决"><a href="#vim-插件不能响应长按的解决" class="headerlink" title="vim 插件不能响应长按的解决"></a>vim 插件不能响应长按的解决</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false # For VS Code</span><br><span class="line"></span><br><span class="line">defaults write com.microsoft.VSCodeInsiders ApplePressAndHoldEnabled -bool false # For VS Code Insider</span><br></pre></td></tr></table></figure>

<h3 id="使用tab键切换提示"><a href="#使用tab键切换提示" class="headerlink" title="使用tab键切换提示"></a>使用tab键切换提示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line"></span><br><span class="line">&quot;key&quot;: &quot;tab&quot;,</span><br><span class="line"></span><br><span class="line">&quot;command&quot;: &quot;-acceptSelectedSuggestion&quot;,</span><br><span class="line"></span><br><span class="line">&quot;when&quot;: &quot;suggestWidgetVisible &amp;&amp; textInputFocus&quot;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;key&quot;: &quot;tab&quot;,</span><br><span class="line"></span><br><span class="line">&quot;command&quot;: &quot;selectNextSuggestion&quot;,</span><br><span class="line"></span><br><span class="line">&quot;when&quot;: &quot;suggestWidgetMultipleSuggestions &amp;&amp; suggestWidgetVisible &amp;&amp; textInputFocus&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fankcoder.com/2019/03/08/tool-2019-03-08-mac-tools/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fankcoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三秋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/03/08/tool-2019-03-08-mac-tools/" class="post-title-link" itemprop="url">mac工具配置手册</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-03-08 14:19:53" itemprop="dateCreated datePublished" datetime="2019-03-08T14:19:53+08:00">2019-03-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-13 23:53:05" itemprop="dateModified" datetime="2019-08-13T23:53:05+08:00">2019-08-13</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/工具/" itemprop="url" rel="index"><span itemprop="name">工具</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><h4 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h4><p>快捷键“cmd+d”左右分屏，快捷键“^+cmd+d”上下分屏</p>
<p>cmd+[ / ] 左右切换分屏 cmd+opt(alt)+上下左右切换分屏</p>
<h4 id="粘贴板"><a href="#粘贴板" class="headerlink" title="粘贴板"></a>粘贴板</h4><p>调出复制过的文本历史 快捷键：“^+cmd+h”</p>
<h4 id="回放"><a href="#回放" class="headerlink" title="回放"></a>回放</h4><p>按键回放 cmd+alt+b</p>
<h2 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h2><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh my zsh"></a>oh my zsh</h3><p>赋予终端全新生命的工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure>

<h4 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h4><p>spaceship theme </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/denysdovhan/spaceship-prompt.git &quot;$ZSH_CUSTOM/themes/spaceship-prompt&quot;</span><br></pre></td></tr></table></figure>

<h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>meslo font</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf</span><br></pre></td></tr></table></figure>

<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="autojump-快速跳转目录"><a href="#autojump-快速跳转目录" class="headerlink" title="autojump 快速跳转目录"></a>autojump 快速跳转目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install autojump</span><br></pre></td></tr></table></figure>

<h4 id="fasd-快速访问文件或目录，功能比autojump更强大，但没有j方便。"><a href="#fasd-快速访问文件或目录，功能比autojump更强大，但没有j方便。" class="headerlink" title="fasd 快速访问文件或目录，功能比autojump更强大，但没有j方便。"></a>fasd 快速访问文件或目录，功能比autojump更强大，但没有j方便。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install fasd</span><br></pre></td></tr></table></figure>

<h4 id="fzf-模糊搜索"><a href="#fzf-模糊搜索" class="headerlink" title="fzf 模糊搜索"></a>fzf 模糊搜索</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install fzf</span><br></pre></td></tr></table></figure>

<h4 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<h4 id="历史命令提示"><a href="#历史命令提示" class="headerlink" title="历史命令提示"></a>历史命令提示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<h4 id="zsh个性化配置"><a href="#zsh个性化配置" class="headerlink" title="zsh个性化配置"></a>zsh个性化配置</h4><p>修改配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure>

<h4 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=&quot;spaceship&quot;</span><br><span class="line">plugins=(robbyrussell git zsh-syntax-highlighting autojump zsh-autosuggestions)</span><br><span class="line"> [[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.sh</span><br><span class="line">export GEM_HOME=$HOME/gems</span><br><span class="line">export PATH=$HOME/gems/bin:$PATH</span><br><span class="line">alias py3=&quot;source /Users/fank/code/py3.7/bin/activate&quot;</span><br><span class="line">source /Users/fank/code/py3.7/bin/activate</span><br><span class="line">export PROMPT_COMMAND=&apos;echo -ne &quot;\033]0;$PWD\007&quot;&apos;</span><br></pre></td></tr></table></figure>

<h4 id="快捷键启动iterm2方案"><a href="#快捷键启动iterm2方案" class="headerlink" title="快捷键启动iterm2方案"></a>快捷键启动iterm2方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 编写mac启动脚本</span><br><span class="line">2. alt+space 搜索iterm</span><br></pre></td></tr></table></figure>

<h3 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h3><p>文档查询工具</p>
<h3 id="数据库图形工具"><a href="#数据库图形工具" class="headerlink" title="数据库图形工具"></a>数据库图形工具</h3><p>Sequel pro</p>
<p>TablePlus</p>
<h3 id="App抓包工具"><a href="#App抓包工具" class="headerlink" title="App抓包工具"></a>App抓包工具</h3><p>Charles</p>
<h3 id="远程工具"><a href="#远程工具" class="headerlink" title="远程工具"></a>远程工具</h3><p>NoMechine</p>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fankcoder.com/2019/02/19/tool-2016-01-28-good-tools/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fankcoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三秋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/02/19/tool-2016-01-28-good-tools/" class="post-title-link" itemprop="url">神器收藏</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-02-19 16:07:56" itemprop="dateCreated datePublished" datetime="2019-02-19T16:07:56+08:00">2019-02-19</time>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/工具/" itemprop="url" rel="index"><span itemprop="name">工具</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          神器
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2019/02/19/tool-2016-01-28-good-tools/">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fankcoder.com/2019/02/19/tool-2015-11-10-vpn-tools/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fankcoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三秋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/02/19/tool-2015-11-10-vpn-tools/" class="post-title-link" itemprop="url">科学上网列表</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-02-19 16:07:56" itemprop="dateCreated datePublished" datetime="2019-02-19T16:07:56+08:00">2019-02-19</time>
            </span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/工具/" itemprop="url" rel="index"><span itemprop="name">工具</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          vpn
          <!--noindex-->
          
            <div class="post-button">
              <a class="btn" href="/2019/02/19/tool-2015-11-10-vpn-tools/">
                Read more &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="fankcoder">
  <p class="site-author-name" itemprop="name">fankcoder</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/fankcoder" title="GitHub &rarr; https://github.com/fankcoder" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:fankcoder@gmail.com" title="E-Mail &rarr; mailto:fankcoder@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://weibo.com/u/2424646683" title="Weibo &rarr; https://weibo.com/u/2424646683" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://www.zhihu.com/people/si-xie-san-qiu/activities" title="Zhihu &rarr; https://www.zhihu.com/people/si-xie-san-qiu/activities" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>Zhihu</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://space.bilibili.com/38307214" title="Bilibili &rarr; https://space.bilibili.com/38307214" rel="noopener" target="_blank"><i class="fa fa-fw fa-tv"></i>Bilibili</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://steamcommunity.com/id/fankcoder" title="Steam &rarr; https://steamcommunity.com/id/fankcoder" rel="noopener" target="_blank"><i class="fa fa-fw fa-steam"></i>Steam</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://coolshell.cn/" title="https://coolshell.cn/" rel="noopener" target="_blank">coolshell</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="http://www.lining0806.com" title="http://www.lining0806.com" rel="noopener" target="_blank">lining0806</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fankcoder</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.1</div>

        












        
      </div>
    </footer>
  </div>

  
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>



  








  <script>
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','msMtA93nEGFTkf4tckPn','2.0.0');
</script>















  

  

  


</body>
</html>
