<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/small.jpg?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="collections123from collections import *from collections.abc import * #抽象基类">
<meta name="keywords" content="pyhton">
<meta property="og:type" content="article">
<meta property="og:title" content="Python深入学习笔记">
<meta property="og:url" content="http://fankcoder.com/2019/03/08/technology-2019-03-08-python-deep/index.html">
<meta property="og:site_name" content="三秋">
<meta property="og:description" content="collections123from collections import *from collections.abc import * #抽象基类">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-10-10T18:38:31.215Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python深入学习笔记">
<meta name="twitter:description" content="collections123from collections import *from collections.abc import * #抽象基类">
  <link rel="canonical" href="http://fankcoder.com/2019/03/08/technology-2019-03-08-python-deep/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Python深入学习笔记 | 三秋</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-149748039-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-149748039-1');
      }
    </script>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">三秋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Think twice, code onece.</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/fankcoder" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fankcoder.com/2019/03/08/technology-2019-03-08-python-deep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fankcoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三秋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Python深入学习笔记

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-03-08 15:38:39" itemprop="dateCreated datePublished" datetime="2019-03-08T15:38:39+08:00">2019-03-08</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-11 02:38:31" itemprop="dateModified" datetime="2019-10-11T02:38:31+08:00">2019-10-11</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from collections import *</span><br><span class="line"></span><br><span class="line">from collections.abc import * #抽象基类</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="tuple功能"><a href="#tuple功能" class="headerlink" title="tuple功能"></a>tuple功能</h4><ol>
<li>不可变(不绝对)</li>
<li>iterable</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#拆包，方便找到对应关系</span><br><span class="line">_tuple = (&apos;fank&apos;, 26, 182)</span><br><span class="line">name, age, height = _tuple</span><br><span class="line">#name = _tuple[0] 不好的写法</span><br><span class="line"></span><br><span class="line">#拆包加强</span><br><span class="line">name, *other = _tuple</span><br><span class="line">print(name, other)</span><br></pre></td></tr></table></figure>

<h4 id="tuple比list好的地方"><a href="#tuple比list好的地方" class="headerlink" title="tuple比list好的地方"></a>tuple比list好的地方</h4><ol>
<li>immutable的重要性</li>
<li>性能优化，不可变对象在编译时作为常量，产生显著的速度差异</li>
<li>线程安全</li>
<li>可以作为dict的key</li>
<li>拆包特性</li>
<li>如果拿C来类比，tuple对应struct, 而list对应array</li>
</ol>
<h4 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h4><p>可以生成类，</p>
<pre><code>User = namedtuple(&quot;User&quot;,[&apos;name&apos;,&apos;age&apos;])
user = User(name=&apos;fank&apos;, age=&apos;27&apos;)
print（user.name, user.age）

_make()使用tuple初始化，_asdict()使用dict初始化
t = (&apos;fank&apos;, 27)
user = User._make(t)
d = {&apos;name&apos;:&apos;fank&apos;,&apos;age&apos;:27}
user = User._asdict(d)</code></pre><p>节省空间，用于数据处理，从数据库取数据为tuple，直接赋值</p>
<h4 id="def-ask-args-kwargs"><a href="#def-ask-args-kwargs" class="headerlink" title="def ask(args, *kwargs)"></a>def ask(<em>args, *</em>kwargs)</h4><p><em>args是个tuple, *</em>kwargs是个dict</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def test(*args, **kwargs):</span><br><span class="line">    print(*args)</span><br><span class="line">    print(**kwargs)</span><br><span class="line"></span><br><span class="line">test(&apos;f&apos;,25)</span><br><span class="line">test(&#123;&apos;name&apos;:&apos;f&apos;,&apos;age&apos;:25&#125;</span><br><span class="line"></span><br><span class="line"># ask(&apos;f&apos;,25) 传给*args, ask(name=&apos;f&apos;, age=25)传给**kwargs</span><br></pre></td></tr></table></figure>

<h4 id="deque双端队列"><a href="#deque双端队列" class="headerlink" title="deque双端队列"></a>deque双端队列</h4><p>应用场景queue是由deque来完成的。deque是线程安全到，list不是线程安全的，由GIL保护。</p>
<pre><code>from collections import deque</code></pre><p>copy是浅拷贝，如果值为list会相互影响</p>
<h4 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h4><p>统计</p>
<pre><code>from collections import Counter
users = [&apos;fank&apos;,&apos;fank1&apos;,&apos;fank1&apos;,&apos;fank2&apos;,&apos;fank&apos;,&apos;fank3&apos;]
user_counter = Counter(users)
print(user_counter)
#Counter({&apos;fank&apos;:2,&apos;fank1&apos;:2,&apos;fank3&apos;:1})

#追加统计
user_counter.update()
#前n个出现最多的,使用堆实现(完全二叉树)
user_counter.most_common(n)</code></pre><h4 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h4><p>from collections import defaultdict C语言实现，性能高,比setdefault更强大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">default_dict = defaultdict(int) #参数是一个可调用对象list,int,func..</span><br><span class="line"></span><br><span class="line">default_dict[&apos;key&apos;] #key=0 ,初始化成功后，直接访问不会报错，会默认生成</span><br><span class="line"></span><br><span class="line">def gen_func():</span><br><span class="line">    return &#123;&apos;fank&apos;:123,&apos;code&apos;:321&#125;</span><br><span class="line">default_dict = defaultdict(gen_func) #生成默认值</span><br></pre></td></tr></table></figure>

<h4 id="OrderDict是有序的"><a href="#OrderDict是有序的" class="headerlink" title="OrderDict是有序的"></a>OrderDict是有序的</h4><p>dict的子类，按照添加顺序排序。list+dict<br>py3的dict默认是有序的。</p>
<pre><code>_d = OrderedDict()
_d.popitem()  #不需要传key
_d.move_to_end()</code></pre><h4 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h4><p>方便操作多个dict. 将dict连结,key相同只有一个。</p>
<pre><code>from collections import ChainMap

new_dict = ChainMap(_d1, _d2)
new_dict.new_child({&apos;name&apos;:&apos;fank&apos;})

new_dict.maps  #maps属性，以列表形式全部打印，同样可以修改</code></pre><h3 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h3><pre><code>import inspect
inspect.getfile(obj)
inspect.getsource(obj)</code></pre><h3 id="type-object和class的关系"><a href="#type-object和class的关系" class="headerlink" title="type,object和class的关系"></a>type,object和class的关系</h3><p>type(int) -&gt; class type -&gt; obj</p>
<p>type -&gt; int -&gt; 1</p>
<p>type生成类对象，类对象生成实例对象</p>
<p>int.<strong>bases</strong> class ‘object’</p>
<p>基类均为class object, object是最顶层基类。</p>
<p>type.<strong>bases</strong> class ‘object’ type继承obj</p>
<p>type(object) class ’type’ obj是type的实例, 形成环路</p>
<p>object.<strong>bases</strong> None</p>
<h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>对象3个特征:</p>
<ol>
<li>身份id(a) </li>
<li>2.类型type </li>
<li>3.值</li>
</ol>
<p>None全局唯一</p>
<p>数值int, float,complex复数,bool</p>
<p>迭代类型</p>
<p>序列类型 list,bytes,range,tuple,str,array</p>
<p>映射类型 dict</p>
<p> 集合 set , frozenset</p>
<p>上下文管理器 with</p>
<p>其他 模块from import,class,object,type</p>
<h3 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h3><p>以双下划线开头，双下划线结尾。可以定制类的特性</p>
<p><strong>iter</strong>,<strong>getitem</strong>实现了都是可迭代的</p>
<p>def <strong>getitem</strong>(self, item):</p>
<p>return self._list[item]</p>
<p>拆包，给长度数量的变量给他们赋值</p>
<h3 id="鸭子类型和多态"><a href="#鸭子类型和多态" class="headerlink" title="鸭子类型和多态"></a>鸭子类型和多态</h3><p>当一只鸟，走路，游泳，叫起来都像鸭子，那么这只鸟就可以被叫做鸭子<br>都实现了同一种方法，所以可以归为一类，不需要继承，只需要实现同方法，就可以实现多态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Cat(object):</span><br><span class="line">    def say(self):</span><br><span class="line">        print(‘im a cat’)</span><br><span class="line"></span><br><span class="line">class Dog(object):</span><br><span class="line">    def say(self):</span><br><span class="line">        print(‘im a dog’)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">animal = Cat</span><br><span class="line">animal().say()</span><br><span class="line"></span><br><span class="line">animal_list = [Cat, Dog]</span><br><span class="line">for animal in animal_list:</span><br><span class="line">    animal().say()</span><br></pre></td></tr></table></figure>

<h3 id="抽象基类abc模块"><a href="#抽象基类abc模块" class="headerlink" title="抽象基类abc模块"></a>抽象基类abc模块</h3><p>检查某个类是否有某种方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Company(object):</span><br><span class="line">    def __init__(self, employee_list):</span><br><span class="line">        self.employee = employee_list</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self.employee)</span><br><span class="line"></span><br><span class="line">com = Company([‘bob1’,’bob2’])</span><br><span class="line">print(hasattr(com, ‘__len__’) #检验类是否具有该方法</span><br><span class="line"># print(len(com))</span><br></pre></td></tr></table></figure>

<h3 id="抽象基类abc模块-1"><a href="#抽象基类abc模块-1" class="headerlink" title="抽象基类abc模块"></a>抽象基类abc模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from collections.abc import Sized</span><br><span class="line">isinstance(com, Sized) # 判断类型</span><br><span class="line">import abc</span><br><span class="line"></span><br><span class="line">class CacheBase(metaclass=abc.ABCMeta):</span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def get(self, key):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def set(self, key, value):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class RedisCache(CacheBase):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">redis_cache = REdisCache()  </span><br><span class="line">#会报错。</span><br><span class="line">#abstractmethod要求被继承的类，必须实现父类的方法，否则会报错</span><br></pre></td></tr></table></figure>

<p>判断继承用isinstance()不要用type()</p>
<h4 id="类变量和实例变量"><a href="#类变量和实例变量" class="headerlink" title="类变量和实例变量"></a>类变量和实例变量</h4><p>类中的self是类的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    aa = 1 #类变量</span><br><span class="line">    def __init__(self, x, y):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y  #实例变量</span><br><span class="line">a = A(2,3)</span><br><span class="line">A.aa = 11 #修改类变量</span><br><span class="line">a.aa = 100 #新建变量</span><br><span class="line">print(a.x, a.y, a.aa)</span><br><span class="line">print(A.a)</span><br><span class="line">print(A.x) #error</span><br></pre></td></tr></table></figure>

<p>self是类的实例，类变量和类实例变量的区别</p>
<p><strong>mro</strong>查找。DFS深度优先，对菱形继承有问题，BFS广度优先也有覆盖问题，py3用C3算法</p>
<p>@staticmethod静态方法，传参和普通函数一样，<strong>不需要写self参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Data:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def parse_from_string(date_str):</span><br><span class="line">        year, month, day = tuple(date_str)</span><br><span class="line">        return Date(year, month, day)  #静态方法硬编码，返回值必须与类名相同</span><br></pre></td></tr></table></figure>

<p>@classmethod类方法，第一参数是类本身cls，返回值不需要与类同名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    @classmethod</span><br><span class="line">    def from_string(cls, date_str):  #cls传递的是类本身，不是实例</span><br><span class="line">        year, month, day = tuple(date_str)</span><br><span class="line">        return cls(year, month, day)  #写为cls,变为动态不必与类名相同</span><br><span class="line">#cls是习惯性写法，在这里甚至可以写为self</span><br></pre></td></tr></table></figure>

<h3 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">self.__birthday双下划线开头，但并不绝对安全，_User__birthday依然可以访问到</span><br><span class="line">class User:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__birthday = birthday  #无法被访问</span><br><span class="line">    def get_age(self):</span><br><span class="line">        return 2019 - self.__birthday.year</span><br><span class="line">    def __get_other(self):  #私有方法</span><br><span class="line">        pass</span><br><span class="line">user = User(Date(1992,9,28))</span><br><span class="line">user._User__birthday  #py帮助我们使用这种简单方式封装，找到规律就可以访问</span><br></pre></td></tr></table></figure>

<h3 id="自省机制"><a href="#自省机制" class="headerlink" title="自省机制"></a>自省机制</h3><p>自省是通过一定的机构查询到对象的内部结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    name = ‘user’</span><br><span class="line"></span><br><span class="line">clss Student(Person):</span><br><span class="line">    def __init__(self, school_name):</span><br><span class="line">        self.school_name = ‘&apos;</span><br><span class="line">user = Student(‘abc’)</span><br><span class="line">print(user.__dict__)  #打印实例属性，&#123;’school_name’:abc&#125;.c优化的魔法函数</span><br><span class="line">print(Person.__dict__) #类属性</span><br><span class="line">user.__dict__[’school_addr’] = ‘efg’  #甚至可以赋值</span><br><span class="line">dir(user)  #更详细，功能更强</span><br></pre></td></tr></table></figure>

<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>获取父类init (其实是mro顺序的类，查看方法classname.<strong>mro</strong>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(‘a’)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(‘b’)</span><br><span class="line">        super(b, self).__init__() # py2</span><br><span class="line">        super().__init__() # py3</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">from threading import Thread</span><br><span class="line">class MyThread(Thread):</span><br><span class="line">    def __init__(self, name, user):</span><br><span class="line">        self.user = user</span><br><span class="line">        super().__init__(name=name)  #重用父类代码</span><br></pre></td></tr></table></figure>

<h3 id="mixin模式"><a href="#mixin模式" class="headerlink" title="mixin模式"></a>mixin模式</h3><p>多继承不推荐，mixin代替多继承<br>特点：</p>
<ol>
<li>Mixin类功能单一</li>
<li>不和基类关联，可以和任意基类组合</li>
<li>在mixin中不要使用supper</li>
</ol>
<h3 id="with上下文管理器"><a href="#with上下文管理器" class="headerlink" title="with上下文管理器"></a>with上下文管理器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    raise KeyError</span><br><span class="line">except KeyError as e:</span><br><span class="line">    print(&apos;e&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;else&apos;) #当try正确运行时&amp;except没有捕获到异常打印</span><br><span class="line">finally:</span><br><span class="line">    print(&apos;f&apos;) #始终运行</span><br></pre></td></tr></table></figure>

<p>with语句是为了简化try..finally诞生的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Sample:</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        #获取资源</span><br><span class="line">        print(&apos;enter&apos;)</span><br><span class="line">        return self</span><br><span class="line">    def __exit__(self, exc_type, exc_val, exc_tb):</span><br><span class="line">        #释放资源</span><br><span class="line">        print(&apos;exit&apos;)</span><br><span class="line">    def do_something(self):</span><br><span class="line">        print(&apos;do smt&apos;)</span><br><span class="line"></span><br><span class="line">with Sample() as sample:</span><br><span class="line">    sample.do_something()</span><br></pre></td></tr></table></figure>

<p>这个类实现了上下文管理器协议，此协议非常好用。<br>with是对上下文管理器的支持。</p>
<h3 id="contextlib简化上下文管理器"><a href="#contextlib简化上下文管理器" class="headerlink" title="contextlib简化上下文管理器"></a>contextlib简化上下文管理器</h3><p>进一步简化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import contextlib</span><br><span class="line"></span><br><span class="line">@contextlib.contextmanager</span><br><span class="line">def file_open(file_name):</span><br><span class="line">    print(&apos;file open&apos;)  # __enter__的位置</span><br><span class="line">    yield &#123;&#125;</span><br><span class="line">    print(&apos;file end&apos;)  # __exit__的位置</span><br><span class="line">    </span><br><span class="line">with file_open(&apos;text&apos;) as f:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>type() object</p>
<p>魔法函数</p>
<p>hasattr(param,”<strong>len</strong>“) 判断是否有这个函数，用isinstance()更好</p>
<p>希望用户继承时必须实现方法</p>
<p>class CacheBase():</p>
<p>def get(self, key):raise NotImplementedError</p>
<p>def set(self, key, value):pass</p>
<h3 id="is-和"><a href="#is-和" class="headerlink" title="is 和 =="></a>is 和 ==</h3><p>is判断id是否相同</p>
<p>==判断值</p>
<p>isinstance 和type，判断类的类型尽量用isinstance</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [46]: a = 1</span><br><span class="line">In [47]: b = 1</span><br><span class="line">In [48]: a is b</span><br><span class="line">Out[48]: True</span><br><span class="line"></span><br><span class="line">In [49]: a = [1,2,3]</span><br><span class="line">In [50]: b = [1,2,3]</span><br><span class="line">In [51]: a is b</span><br><span class="line">Out[51]: False</span><br><span class="line"></span><br><span class="line">In [72]: a = &quot;hello world&quot;</span><br><span class="line">In [73]: b = &quot;hello world&quot;</span><br><span class="line">In [74]: a is b</span><br><span class="line">Out[74]: False</span><br></pre></td></tr></table></figure>

<h3 id="自定义序列类"><a href="#自定义序列类" class="headerlink" title="自定义序列类"></a>自定义序列类</h3><p>容器序列，扁平序列，可变序列sequence，不可变序列mutable</p>
<p>python面向协议编程 in可以作用于list</p>
<h3 id="extend"><a href="#extend" class="headerlink" title="+,+=,extend"></a>+,+=,extend</h3><p>+=（<strong>iadd</strong>）的参数可以是序列，+必须两边同类型<br>a.extend(range(0,3)) #直接对值修改，不需要再赋值，参考apped<br>a.append([1,2])  #[1,2,[1,2]]注意和extend的区别</p>
<p>参数可以为任意序列，通过for循环append</p>
<p>切片[start : end : step]，默认值可省略[0,len(L),1].</p>
<p>实现支持切片操作的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Group:</span><br><span class="line">    def __init__(self, group_name, company_name, staffs):</span><br><span class="line">        self.group_name = group_name</span><br><span class="line">        self.company_name = company_name</span><br><span class="line">        self.staffs = staffs</span><br><span class="line">    </span><br><span class="line">    def __reversed__(self):</span><br><span class="line">        self.staffs.reversed()  #这种方式实现不了</span><br><span class="line">        for each in self.staffs[::-1]:</span><br><span class="line">            yield each</span><br><span class="line">        </span><br><span class="line">    # def __getitem__(self, item):</span><br><span class="line">    #     return self.staff[item] #返回对象为list或单个元素</span><br><span class="line">    import numbers</span><br><span class="line">    def __getitem__(self, item):  #返回类对象</span><br><span class="line">        cls = type(self)</span><br><span class="line">        if isinstance(item, slice):</span><br><span class="line">            return cls(group_name=self.group_name, company_name=self.company_name, staffs=self.staffs[item])</span><br><span class="line">        elif isinstance(item, numbers.Interal):</span><br><span class="line">            return cls(group_name=self.group_name, company_name=self.company_name, [staffs=self.staffs[item]])</span><br><span class="line">    </span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self.staffs)</span><br><span class="line">        </span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return iter(self.staffs)</span><br><span class="line">    </span><br><span class="line">    def __contains__(self, item):</span><br><span class="line">        if item in self.staffs:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">staffs = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">group = Group(group_name=&apos;gname&apos;, company_name=&apos;cname&apos;, staff=staffs)</span><br><span class="line">group[:2]</span><br><span class="line">for user in group:</span><br><span class="line">    print(user)</span><br></pre></td></tr></table></figure>

<h3 id="bisect二分查找"><a href="#bisect二分查找" class="headerlink" title="bisect二分查找"></a>bisect二分查找</h3><p>bisect处理已排序序列，二分查找。插入排序好的数列，升序bisect.insort(list, 5).<br>二分法查找位置，插入位置bisect.bisect(list, 3)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import bisect</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line">bisect.insort(4)</span><br><span class="line">bisect.insort(1)</span><br><span class="line">bisect.insort(3)</span><br><span class="line">bisect.insort(2)</span><br><span class="line">print(l) #[1,2,3,4]</span><br></pre></td></tr></table></figure>

<p>arrary和list重要区别，array只能存放指定的数据类型。布隆过滤器。<br>arrary是c中的数组，一串连续的内存块，性能高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import array</span><br><span class="line">_a = array.array(&apos;i&apos;) # int,参数查看文档</span><br><span class="line">_a.append()</span><br></pre></td></tr></table></figure>

<h3 id="列表推导式（生成式）-amp-生成器表达式"><a href="#列表推导式（生成式）-amp-生成器表达式" class="headerlink" title="列表推导式（生成式）&amp;生成器表达式"></a>列表推导式（生成式）&amp;生成器表达式</h3><p>通过一行代码生成列表。</p>
<p>列表生成式性能能高于列表操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odd_list = [i for i in range(21) if i%2 == 1]</span><br></pre></td></tr></table></figure>

<p>复杂情况的列表生成式，可以使用函数实现.（过于复杂就放弃吧，代码可读性更重要）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def sqrt(item):</span><br><span class="line">    return item*item</span><br><span class="line">odd_list = [sqrt(i) for i in range(21) if i%2 == 1]</span><br></pre></td></tr></table></figure>

<p>生成器表达式为小括号，type变为generator</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odd_list = (i for i in range(21) if i%2 == 1)</span><br></pre></td></tr></table></figure>

<p>字典推导式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dict =&#123;&apos;a&apos;:1, &apos;b&apos;:2&#125;</span><br><span class="line">_reversed = &#123;value:key for key, value in my_dict.items()&#125; # 交换value,key</span><br></pre></td></tr></table></figure>

<p>集合推导式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_set = &#123;key for key,value in my_dict.items()&#125;</span><br><span class="line">type(my_set)  # set</span><br></pre></td></tr></table></figure>

<h3 id="深入set和dict"><a href="#深入set和dict" class="headerlink" title="深入set和dict"></a>深入set和dict</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a.copy() #浅拷贝</span><br><span class="line"></span><br><span class="line">import copy </span><br><span class="line"></span><br><span class="line">copy.deepcopy(a) #深拷贝</span><br></pre></td></tr></table></figure>

<p>浅拷贝就是创建一个具有相同类型，相同值（值的id也相同）但不同id的新对象。</p>
<p>深拷贝值为list时，list的id不同。</p>
<p>深拷贝不仅仅拷贝了原始对象自身，也对其包含的值进行拷贝，它会递归的查找对象中包含的其他对象的引用，来完成更深层次拷贝。因此，深拷贝产生的副本可以随意修改而不需要担心会引起原始值的改变。</p>
<h4 id="dict的formkeys方法"><a href="#dict的formkeys方法" class="headerlink" title="dict的formkeys方法"></a>dict的formkeys方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [&apos;a&apos;, &apos;b&apos;]</span><br><span class="line">d = dict.fromkeys(l, &#123;&apos;c&apos;,&apos;d&apos;&#125;)</span><br><span class="line">print(d) #&#123;&apos;a&apos;: &#123;&apos;c&apos;, &apos;d&apos;&#125;, &apos;b&apos;: &#123;&apos;c&apos;, &apos;d&apos;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_d[&apos;key&apos;]  #key不存在会抛异常</span><br><span class="line">_dict.get(&quot;a&quot;, &#123;&#125;) #get方法非常实用！&#123;&#125;为默认值</span><br></pre></td></tr></table></figure>

<h4 id="items"><a href="#items" class="headerlink" title="items"></a>items</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for key, value in _d.items()：</span><br><span class="line">    print(k,v)   #烂大街的好方法</span><br></pre></td></tr></table></figure>

<h4 id="setdefault-增加get方法"><a href="#setdefault-增加get方法" class="headerlink" title="setdefault 增加get方法"></a>setdefault 增加get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setdefault(key, default)</span><br><span class="line"># 1.先调用get()</span><br><span class="line"># 2.没有则默认值</span><br><span class="line"># 3.再把默认值设置进dict</span><br></pre></td></tr></table></figure>

<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p>合并字典</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dict.update(&#123;&apos;c&apos;:1&#125;)</span><br><span class="line">_dict.update(&quot;a&quot;=1,&quot;b&quot;=2) #放iterm都可以</span><br><span class="line">_dict.update(（（’e‘,&apos;f&apos;），）) #传入tuple</span><br></pre></td></tr></table></figure>

<h3 id="dict子类"><a href="#dict子类" class="headerlink" title="dict子类"></a>dict子类</h3><p>写类不建议继承list和dict<br>某些时候c不会使用覆盖的方法，而是会用dict本身的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from collections import UserDict </span><br><span class="line">#推荐使用UserDict被python重写过</span><br><span class="line">class Mydict(UserDict):</span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        super().__setitem__(key, value*2)</span><br><span class="line"></span><br><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line"># 如果找不到key,就赋值</span><br><span class="line">my_dict = defaultdict(dict())</span><br><span class="line">my_value = my_dict[&apos;fank&apos;] #这里我的py3.7.1报错了</span><br></pre></td></tr></table></figure>

<h3 id="set-fronzenset"><a href="#set-fronzenset" class="headerlink" title="set fronzenset"></a>set fronzenset</h3><p>set和fronzenset(不可变)无序，不重复，在去重时用的很多，并且fronzenset是不可变类型，所以可以做为dict的key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = set(&apos;abcd&apos;)</span><br><span class="line">s1 = &#123;&apos;a&apos;, &apos;b&apos;&#125; #type是set</span><br><span class="line">s2 = frozenset(&apos;abcde&apos;) #无法add值，</span><br></pre></td></tr></table></figure>

<h4 id="set-difference"><a href="#set-difference" class="headerlink" title="set difference"></a>set difference</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;</span><br><span class="line">ans = set(&apos;cef&apos;)</span><br><span class="line">rs = s.difference(ans)</span><br><span class="line">print(rs) # &#123;&apos;a&apos;,&apos;b&apos;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dict和set实现原理"><a href="#dict和set实现原理" class="headerlink" title="dict和set实现原理"></a>dict和set实现原理</h4><p>dict 查哈希表，key必须为可哈希的值。str,fset,tuple,自己实现的类</p>
<p>dict的内存花销大，查询速度快</p>
<p>垃圾回收算法是采用引用计数 del</p>
<h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><p>property动态属性，User.age可以取属性，不用调函数，类似get，set为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class User:</span><br><span class="line">    def __init__(self, birthday):</span><br><span class="line">        self.birthday = birthday</span><br><span class="line">        self._age = 0</span><br><span class="line">    @propery  #装饰器。讲age变为属性描述符,直接调用</span><br><span class="line">    def age(self):</span><br><span class="line">        return datetime.now().year - self.birthday.year</span><br><span class="line">    @age.setter  #设置</span><br><span class="line">    def age(self, value):</span><br><span class="line">        self._age = value</span><br><span class="line">    </span><br><span class="line">user = User(year=&apos;1992&apos;)</span><br><span class="line">user.age</span><br><span class="line">user.age = 26  #属性赋值</span><br></pre></td></tr></table></figure>

<h3 id="getattr与getattribute的区别"><a href="#getattr与getattribute的区别" class="headerlink" title="getattr与getattribute的区别"></a><strong>getattr</strong>与<strong>getattribute</strong>的区别</h3><p><strong>getattr</strong>在查找不到属性的时候调用(写了就不会报错).维护dict动态访问key</p>
<p>def <strong>getattr</strong>(self, item): return “not find”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from datetime import date</span><br><span class="line">class User:</span><br><span class="line">    def __init__(self, name,info=&#123;&#125;):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.info = info</span><br><span class="line">        </span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">        return self.info[item]</span><br><span class="line">user = User(&apos;fank&apos;, info=&#123;&apos;a&apos;:1&#125;)</span><br><span class="line">user.a</span><br></pre></td></tr></table></figure>

<p>def <strong>getattribute</strong>(self, item): return “true”<br>优先级别高，无条件进入这个函数，它控制全局属性访问</p>
<h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>在赋值的时候检查属性<br>实现了<strong>get</strong>,<strong>set</strong>,<strong>delete</strong>三个中的任意一个的类都是属性描述符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class IntField:</span><br><span class="line">    def __get__(self, instance):</span><br><span class="line">        return self.value</span><br><span class="line">    def __set__(self, instance,value):</span><br><span class="line">        if isinstance(value, numbers.Interagral):</span><br><span class="line">            raise ValueError(&apos;int value need&apos;)</span><br><span class="line">        self.value = value</span><br><span class="line">    def __delete__(self, instance):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class User:</span><br><span class="line">    age = Intfield()</span><br></pre></td></tr></table></figure>

<p>数据描述符都实现<br>非数据描述符只实现<strong>get</strong></p>
<p>属性查找过程</p>
<p>传递方法为变化的user.age方式无法实现， 使用getattr(user, age)</p>
<h3 id="new和init区别"><a href="#new和init区别" class="headerlink" title="new和init区别"></a><strong>new</strong>和<strong>init</strong>区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class User:</span><br><span class="line">    def __new__(cls, *args, **kwargs): #写框架使用很频繁</span><br><span class="line">        pass</span><br><span class="line">        return super().__new__(cls)</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">user = User(&apos;fank&apos;)</span><br></pre></td></tr></table></figure>

<p>new传递类cls，在init之前，new控制对象的生成过程.<br>如果new不返回对象，不会调用init函数</p>
<p>type是默认元类，metaclass是自定义元类，可以控制实例化过程</p>
<h3 id="元类编程"><a href="#元类编程" class="headerlink" title="元类编程"></a>元类编程</h3><p>类也是对象，type是用来创建类的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def create_class(name):</span><br><span class="line">    if name == &quot;user&quot;:</span><br><span class="line">        class User:</span><br><span class="line">            def __str__(self):</span><br><span class="line">                return &apos;user&apos;</span><br><span class="line">        return User</span><br><span class="line">    elif name == &quot;company&quot;:</span><br><span class="line">        class Company:</span><br><span class="line">            def __str__(self):</span><br><span class="line">                return &apos;Company&apos;</span><br><span class="line">        return Company</span><br><span class="line"></span><br><span class="line">#type是可以创建类的。动态创建类</span><br><span class="line">User = type(&quot;User&quot;, (), &#123;&quot;name&quot;:&quot;user&quot;&#125;)  #第二个参数继承基类必写</span><br><span class="line">u = User()</span><br><span class="line">print(u.name)</span><br><span class="line"></span><br><span class="line">#如何给type写方法</span><br><span class="line">def say(self):</span><br><span class="line">    retun &quot;i am user&quot;</span><br><span class="line">User = type(&quot;User&quot;, (), &#123;&quot;name&quot;:&quot;user&quot;, &quot;say&quot;:say&#125;) </span><br><span class="line">u = User()</span><br><span class="line">print(u.say)</span><br><span class="line">#继承</span><br><span class="line">User = type(&quot;User&quot;, (Baseclass,), &#123;&quot;name&quot;:&quot;user&quot;, &quot;say&quot;:say&#125;)</span><br></pre></td></tr></table></figure>

<p>元类是创建类的类， 对象&lt;-class&lt;-type</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MetaClass(type):</span><br><span class="line">    def __new__(self, *args, **kwargs):</span><br><span class="line">        return super().__new__(cls, *args, **kwargs) #带*参数必传否则会报错</span><br><span class="line"></span><br><span class="line">class User(metaclass=MetaClass):  #当不写metaclass会默认调用type创建类对象</span><br><span class="line">    pass</span><br><span class="line">#python类的实例化过程中，会首先寻找metaclass,通过metaclass创建类，控制实例化过程</span><br></pre></td></tr></table></figure>

<h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><p>迭代器是访问集合内元素的一种方式，一般用来遍历数据。</p>
<p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。实现了<code>__iter__</code>和<code>__next__()</code>方法的对象都是迭代器。</p>
<p>可以使用isinstance()判断一个对象是否是Iterator对象。</p>
<p>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</p>
<p>python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
<p>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(iter([]), Iterator)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(iter(&apos;abc&apos;), Iterator)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>next(itor)接受迭代器，迭代器next无法切片。文件太大使用迭代器读数据</p>
<p><strong>iter</strong>迭代协议，可迭代的实现方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from collections.abc import Iterable,Iterator</span><br><span class="line"></span><br><span class="line">iter([_list]) #将list变为迭代器</span><br><span class="line"></span><br><span class="line">def __iter__(self) / def __getitem__(self, item)</span><br></pre></td></tr></table></figure>

<p>生成器函数，函数内有yield关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def gen_func(): </span><br><span class="line">    yield 1 yield2 yield3</span><br></pre></td></tr></table></figure>

<p>python在编译时字节码发现yield于是变为生成器<br>python查看字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import dis</span><br><span class="line">print(dis.dis(func))</span><br></pre></td></tr></table></figure>

<p>gen = gen_func() #gen生成器对象，不是值</p>
<p>for i in gen: print(i) 惰性求值提供了可能，比list好处是省内存</p>
<p>生成器读取大文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#数据在文件中只有1行</span><br><span class="line">f = open()</span><br><span class="line">f.read(4096) #一次读取的大小，偏移量</span><br><span class="line"></span><br><span class="line">def myreadlines(f, newline):</span><br><span class="line">    buf = &quot;&quot;</span><br><span class="line">    while True:</span><br><span class="line">        while newline in buf:</span><br><span class="line">            pos = buf.index(newline)</span><br><span class="line">            yield buf[:pos]</span><br><span class="line">            buf = buf[pos + len(newline):]</span><br><span class="line">        chunk = f.read(4096)</span><br><span class="line">        </span><br><span class="line">        if not chunk:</span><br><span class="line">            yield buf</span><br><span class="line">            break</span><br><span class="line">        buf += chunk</span><br></pre></td></tr></table></figure>

<h3 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h3><p>服务端socket</p>
<ol>
<li>bind(协议，地址，端口）</li>
<li>listen(监听客户端socket请求）</li>
<li>accept()</li>
<li>阻塞等待连接请求（新套接字）</li>
<li>recv()</li>
<li>send()</li>
<li>close()</li>
</ol>
<p>客户端socket</p>
<ol>
<li>connect() 三次握手 -&gt; 等待套接字</li>
<li>send() -&gt; recv() server #接受bytes类型需要编码</li>
<li>recv() -&gt; send() server</li>
<li>close()</li>
</ol>
<p>爬虫是典型的客户端socket<br>如果使得服务端可以多用户连接？<br>将每个socket做为线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">server = socket.socket()</span><br><span class="line"></span><br><span class="line">server.bind((&apos;0.0.0.0&apos;, 8000))</span><br><span class="line"></span><br><span class="line">server.listen()</span><br><span class="line"></span><br><span class="line">sock, addr = server.accept()</span><br><span class="line"></span><br><span class="line">data = server.recv(1024) #1kb</span><br></pre></td></tr></table></figure>

<p>socketHttp<br>reqeusts -&gt; urlib -&gt; socket</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">from urllib.parse import urlparse</span><br><span class="line"></span><br><span class="line">def get_url(url):</span><br><span class="line">    # get html by socket</span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    if path == &apos;&apos;:</span><br><span class="line">        path = &apos;/&apos;</span><br><span class="line">        </span><br><span class="line">    #connect socket</span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.connect((host, 80))</span><br><span class="line">    client.send(&quot;GET &#123;&#125; HTTP/1.1\r\nHOST:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode(&apos;utf8&apos;))</span><br><span class="line">    </span><br><span class="line">    data = b&apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        d = client.recv(1024)</span><br><span class="line">        if d:</span><br><span class="line">            data += d</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    data = data.decode(&apos;utf8&apos;)</span><br><span class="line">    htmldata = data.split(&apos;\r\n\r\n&apos;)[1]</span><br><span class="line">    print(htmldata)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    get_url(&apos;http://www.baidu.com&apos;)</span><br></pre></td></tr></table></figure>

<h3 id="线程-amp-进程"><a href="#线程-amp-进程" class="headerlink" title="线程&amp;进程"></a>线程&amp;进程</h3><p>GIL global interpreter lock GIL全局解释锁</p>
<p>python中一个线程对应于c中的线程</p>
<p>python是先将py文件编译为字节码</p>
<p>gil使得同一时刻只有一个线程在一个cpu上执行字节码，无法将多个线程映射到多个cpu上 </p>
<p>为了安全，但速度慢，无法体现多核优势。pypy是去gil化的。gil在遇到io操作会主动释放</p>
<p>操作系统调度的最小单元线程，对于io操作，多线程和多进程差别不大。</p>
<h4 id="通过thread类实例化"><a href="#通过thread类实例化" class="headerlink" title="通过thread类实例化"></a>通过thread类实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1 = threading.Thread(target=func, args=(&quot;&quot;,))</span><br><span class="line"></span><br><span class="line">thread1.setDaemon(True)#设置为守护线程。当主线程关闭时，子线程被kill</span><br><span class="line"></span><br><span class="line">thread1.join() #阻塞，等待thread1子线程执行完成</span><br></pre></td></tr></table></figure>

<h4 id="继承thread来实现多线程"><a href="#继承thread来实现多线程" class="headerlink" title="继承thread来实现多线程"></a>继承thread来实现多线程</h4><p>当代码量大，逻辑复杂时，推荐通过继承thread来实现多线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class GetDetailHtml(threading.Thread):</span><br><span class="line">    def __init__(self, name):   #为线程命名，好习惯</span><br><span class="line">        super().__init__(name=name)</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;get detail html&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&apos;get detail html done&apos;)</span><br><span class="line"></span><br><span class="line">class GetTitleHtml(threading.Thread):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        super().__init__(name=name)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;get title url&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&apos;get title url done&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    thread1 = GetTitleHtml(&apos;get title html&apos;)</span><br><span class="line">    thread2 = GetDetailHtml(&apos;get detail html&apos;)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line">    print(&apos;last time &#123;&#125;&apos;.format(time.time() - start_time))</span><br></pre></td></tr></table></figure>



<h3 id="线程之间的通信方式"><a href="#线程之间的通信方式" class="headerlink" title="线程之间的通信方式"></a>线程之间的通信方式</h3><h4 id="1-共享全局变量-list-（多线程可以，多进程不行）"><a href="#1-共享全局变量-list-（多线程可以，多进程不行）" class="headerlink" title="1.共享全局变量(list)（多线程可以，多进程不行）"></a>1.共享全局变量(list)（多线程可以，多进程不行）</h4><p>这种方法，线程并不安全，需要加gil锁，所以并不推荐用作通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">#1.共享全局变量</span><br><span class="line">detail_url_list = []</span><br><span class="line"></span><br><span class="line">def get_title_html(detail_url_list):</span><br><span class="line">    print(&apos;get title url&apos;)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    for i in range(20):</span><br><span class="line">        detail_url_list.append(&apos;http://www.test.com/id/&#123;&#125;/&apos;.format(i))</span><br><span class="line">    print(&apos;get title url done&apos;)</span><br><span class="line"></span><br><span class="line">def get_detail_html(detail_url_list):</span><br><span class="line">    print(&apos;get detail html&apos;)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    if len(detail_url_list):</span><br><span class="line">        url = detail_url_list.pop()</span><br><span class="line">        print(&apos;get detail html done&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    thread1 = threading.Thread(target=get_title_html, args=(detail_url_list,))</span><br><span class="line">    for i in range(10): #启动10个线程，太多线程操作系统切换会产生很大代价</span><br><span class="line">        html_thread = threading.Thread(target=get_detail_html, args=(detail_url_list,))</span><br><span class="line">        html_thread.start()</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    print(&apos;last time &#123;&#125;&apos;.format(time.time() - start_time))</span><br></pre></td></tr></table></figure>

<h4 id="2-通过queue方法进行线程间通讯-queue本身是线程安全的"><a href="#2-通过queue方法进行线程间通讯-queue本身是线程安全的" class="headerlink" title="2.通过queue方法进行线程间通讯,queue本身是线程安全的"></a>2.通过queue方法进行线程间通讯,queue本身是线程安全的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def get_title_html(queue):</span><br><span class="line">    while True:</span><br><span class="line">        print(&apos;get title url&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        for i in range(20):</span><br><span class="line">            queue.put(&apos;http://www.test.com/id/&#123;&#125;/&apos;.format(i))</span><br><span class="line">        print(&apos;get title url done&apos;)</span><br><span class="line"></span><br><span class="line">def get_detail_html(queue):</span><br><span class="line">    while True:</span><br><span class="line">        print(&apos;get detail html&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        url = queue.get()  #get方法是阻塞方法，如果queue为空就等待</span><br><span class="line">        print(&apos;get detail html done&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    detail_queue = Queue(maxsize=1000)</span><br><span class="line">    thread1 = threading.Thread(target=get_title_html, args=(detail_queue,))</span><br><span class="line">    for i in range(10): #启动10个线程，太多线程操作系统切换会产生很大代价</span><br><span class="line">        html_thread = threading.Thread(target=get_detail_html, args=(detail_queue,))</span><br><span class="line">        html_thread.start()</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    print(&apos;last time &#123;&#125;&apos;.format(time.time() - start_time))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">queue.get()#阻塞方法，如果为空就一直停顿等待</span><br><span class="line">queue.put_nowait()#设置为非阻塞</span><br><span class="line">queue.qsize() #获取长度，同样是线程安全的可以直接使用</span><br><span class="line">queue.empty()</span><br><span class="line">queue.full()</span><br><span class="line">queue.join()#阻塞直到执行到task_done()</span><br><span class="line">queue.task_done()</span><br></pre></td></tr></table></figure>

<p>.join()一直阻塞，想退出需要调用.task_down() #爬虫暂停</p>
<p>如果共用变量为dict或其他非队列数据，也可以考虑使用全局变量</p>
<h3 id="线程同步（lock-rlock）"><a href="#线程同步（lock-rlock）" class="headerlink" title="线程同步（lock, rlock）"></a>线程同步（lock, rlock）</h3><p>避免淘宝库存同时有人买<br>线程同步机制,lock锁，反正锁住的代码段都只能有一个在运行，释放之后才能让其他代码运行.</p>
<p>使用锁会出现的问题</p>
<ol>
<li>用锁会影响性能</li>
<li>锁会引起死锁（互相等待）,不能连续调用两次acquire</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from threading import Lock</span><br><span class="line"></span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line">global lock</span><br><span class="line"></span><br><span class="line">lock.acquire() #获取</span><br><span class="line"></span><br><span class="line">a += 1</span><br><span class="line"></span><br><span class="line">lock.release() #释放</span><br></pre></td></tr></table></figure>

<p>死锁情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A(a, b)</span><br><span class="line">acquire(a)</span><br><span class="line">acquire(b)</span><br><span class="line"></span><br><span class="line">B(a, b)</span><br><span class="line">acquire(b) # a,b同时等待</span><br><span class="line">acquire(a)</span><br></pre></td></tr></table></figure>

<h4 id="rlock可重入的锁"><a href="#rlock可重入的锁" class="headerlink" title="rlock可重入的锁"></a>rlock可重入的锁</h4><p>解决lock，不能连续调用acquire的问题。它可以在同一个线程里面，可以连续调用多次acquire，需要相等数量的release.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from threading import RLock</span><br><span class="line">lock = Rlock()</span><br><span class="line"></span><br><span class="line">lock.acquire()</span><br><span class="line">lock.acquire()</span><br><span class="line">lock.release()</span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure>

<h3 id="condition条件变量"><a href="#condition条件变量" class="headerlink" title="condition条件变量"></a>condition条件变量</h3><p>用于复杂的线程间同步锁</p>
<p>wait()允许等待某个条件变量的通知<br>notify()会通知调用了wait()方法的那个线程启动</p>
<ol>
<li>使用condition启动顺序非常重要</li>
<li>一定要先调用with方法或者acquire和release，之后再调用wait(),notify()</li>
<li>condition有两层锁，一把底层锁会在线程调用wait方法的时候释放，上面的锁会值每次调用wait时分配一把并放入到cond的等待队列中，等到notify方法唤醒</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">from threading import Condition</span><br><span class="line"></span><br><span class="line">class XiaAi(threading.Thread):</span><br><span class="line">    def __init__(self, cond):</span><br><span class="line">        super().__init__(name=&apos;小爱&apos;)</span><br><span class="line">        self.cond = cond</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        with self.cond:</span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(&apos;&#123;&#125;: 在&apos;.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line">            print(&apos;&#123;&#125;: 好啊&apos;.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">    </span><br><span class="line">class TianMao(threading.Thread):</span><br><span class="line">    def __init__(self, cond):</span><br><span class="line">        super().__init__(name=&apos;天猫&apos;)</span><br><span class="line">        self.cond = cond</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        with self.cond:</span><br><span class="line">            print(&apos;&#123;&#125;: 小爱同学&apos;.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">            print(&apos;&#123;&#125;: 我们来对古诗吧&apos;.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    cond = threading.Condition()</span><br><span class="line"></span><br><span class="line">    xiaoai = XiaAi(cond)</span><br><span class="line">    tianmao = TianMao(cond)</span><br><span class="line"></span><br><span class="line">    xiaoai.start()</span><br><span class="line">    tianmao.start()</span><br><span class="line">    xiaoai.join()</span><br><span class="line">    tianmao.join()</span><br></pre></td></tr></table></figure>



<h3 id="Semaphore-控制线程并发数量"><a href="#Semaphore-控制线程并发数量" class="headerlink" title="Semaphore 控制线程并发数量"></a>Semaphore 控制线程并发数量</h3><p>#文件读写，写一般只用一个线程，读可以允许有多个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HtmlSpider(threading.Thread):</span><br><span class="line">    def __init__(self, url, sem):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.url = url</span><br><span class="line">        self.sem = sem</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&apos;get html success&apos;)</span><br><span class="line">        self.sem.release()</span><br><span class="line"></span><br><span class="line">class UrlProducer(threading.Thread):</span><br><span class="line">    def __init__(self, sem):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.sem = sem</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        for i in range(10):</span><br><span class="line">            self.sem.acquire()</span><br><span class="line">            html_thread = HtmlSpider(&apos;http://www.baidu.com/id/&#123;&#125;/&apos;.format(i), self.sem)</span><br><span class="line">            html_thread.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sem = threading.Semaphore(3)</span><br><span class="line">    url_thread = UrlProducer(sem)</span><br><span class="line">    url_thread.start()</span><br></pre></td></tr></table></figure>



<h3 id="线程池concurrent-py3-2"><a href="#线程池concurrent-py3-2" class="headerlink" title="线程池concurrent #py3.2"></a>线程池concurrent #py3.2</h3><p>concurrent容易的编写多线程，多进程代码</p>
<p>为什么使用线程池？</p>
<p>1.主线程中可以获取某一个线程的状态或者某一个任务的状态，以及返回值</p>
<p>2.当一个线程完成的时候，主线程能立即知道</p>
<p>3.futures可以让多线程多进程编码接口一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor,as_completed,wait,FIRST_COMPLETED</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def get_html(times):</span><br><span class="line">    time.sleep(times)</span><br><span class="line">    print(&apos;get html &#123;&#125; success&apos;.format(times))</span><br><span class="line">    return times</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=2)</span><br><span class="line"></span><br><span class="line">#通过submit提交执行的函数到线程池中，submit是立即返回</span><br><span class="line">task1 = executor.submit(get_html, (3))</span><br><span class="line">task2 = executor.submit(get_html, (2))</span><br><span class="line">print(task1.done())</span><br><span class="line">#取消线程执行，状态done无论为true和false都不能取消执行。只有还没提交到线程池中的线程才能提交，与max_workers的设置有关</span><br><span class="line">print(task2.cancel(2))</span><br><span class="line">time.sleep(3.1)</span><br><span class="line">#done()查看该线程当前的执行状态</span><br><span class="line">print(task1.done())</span><br><span class="line">#result()获取该线程的返回结果</span><br><span class="line">print(task1.result())</span><br><span class="line"></span><br><span class="line">#as_completed获取已经成功的task的返回，如爬虫</span><br><span class="line">urls = [2,3,4,2]</span><br><span class="line">all_task = [executor.submit(get_html, (url)) for url in urls]</span><br><span class="line">for future in as_completed(all_task):</span><br><span class="line">    data = future.result()</span><br><span class="line">    print(&apos;get &#123;&#125; page success&apos;.format(data))</span><br><span class="line"></span><br><span class="line">#使用executor的map方法对as_completed进行简化.map的返回结果就是future.result()</span><br><span class="line">#map的返回顺序是按照list的顺序，并不是先执行完就返回</span><br><span class="line">for data in executor.map(get_html, urls):</span><br><span class="line">    print(&apos;get &#123;&#125; page success&apos;.format(data))</span><br><span class="line">#wait设置阻塞，参数可选择条件默认为ALL_COMPLETED</span><br><span class="line">wait(all_task, return_when=FIRST_COMPLETED)</span><br><span class="line">print(&apos;main&apos;)</span><br></pre></td></tr></table></figure>



<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>线程由于有gil无法并发，python多线程无法利用多cpu。</p>
<p>耗cpu的操作，多核cpu，计算，图像，挖矿多进程优于多线程。<br>io操作进程切换代价高于线程。</p>
<p>进程数据完全隔离,无法使用共享全局变量</p>
<p>子进程完全拷贝Fork之后的父进程代码运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor,as_completed</span><br><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">def fib(n):</span><br><span class="line">    if n &lt;=2:</span><br><span class="line">        return 1</span><br><span class="line">    return fib(n-1)+fib(n-2)</span><br><span class="line"></span><br><span class="line"># 耗cpu的操作多进程比多线程速度快</span><br><span class="line">with ProcessPoolExecutor(3) as executor:  #win使用多进程必须在__name==&apos;__main__&apos;下运行</span><br><span class="line"># with ThreadPoolExecutor(3) as executor:</span><br><span class="line">    alltask = [executor.submit(fib, (num)) for num in range(25,40)]</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    for future in as_completed(alltask):</span><br><span class="line">        data = future.result()</span><br><span class="line">        print(&apos;exec result &#123;&#125;&apos;.format(data))</span><br><span class="line">    </span><br><span class="line">    print(&apos;last time is :&#123;&#125;&apos;.format(time.time() - start_time))</span><br><span class="line"></span><br><span class="line"># io操作多线程比多进程快</span><br><span class="line">def random_sleep(n):</span><br><span class="line">    time.sleep(n)</span><br><span class="line">    return n</span><br></pre></td></tr></table></figure>

<h4 id="更加底层的多进程包"><a href="#更加底层的多进程包" class="headerlink" title="更加底层的多进程包"></a>更加底层的多进程包</h4><p>学习底层，生产环境还是推荐conncurrent</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line">print(&apos;fank&apos;)</span><br><span class="line">if pid == 0:  #pid=0 child pro</span><br><span class="line">    print(&apos;child process &#123;&#125;. parent process &#123;&#125;&apos;.format(os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">    print(&apos;parent process &#123;&#125;&apos;.format(pid))</span><br><span class="line"></span><br><span class="line">time.sleep(2)</span><br><span class="line"></span><br><span class="line">def get_html(n):</span><br><span class="line">    time.sleep(n)</span><br><span class="line">    print(&apos;sub progress success&apos;)</span><br><span class="line">    return n</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    program = multiprocessing.Process(target=get_html, args=(2,))</span><br><span class="line">    program.start()</span><br><span class="line">    program.join()</span><br><span class="line">    print(program.pid) #比线程多个pid属性</span><br><span class="line">    print(&apos;main progress end&apos;)</span><br><span class="line"></span><br><span class="line">    #进程池</span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    result = pool.apply_async(get_html,args=(3,))</span><br><span class="line"></span><br><span class="line">    #等待所有任务完成</span><br><span class="line">    pool.close()  #关闭接受新的进程</span><br><span class="line">    pool.join()</span><br><span class="line">    print(result.get())</span><br><span class="line"></span><br><span class="line">    #imap  按顺序输出</span><br><span class="line">    for result in pool.imap(get_html, [1,5,3]):</span><br><span class="line">        print(&apos;&#123;&#125; sleep success&apos;.format(result))</span><br><span class="line"></span><br><span class="line">    #imapunordered  按执行速度输出</span><br><span class="line">    for result in pool.imap_unordered(get_html, [1,5,3]):</span><br><span class="line">        print(&apos;&#123;&#125; sleep success&apos;.format(result))</span><br></pre></td></tr></table></figure>

<h3 id="进程间的通讯"><a href="#进程间的通讯" class="headerlink" title="进程间的通讯"></a>进程间的通讯</h3><p>共享全局变量在多进程中不适用</p>
<p>mutiprocessing.queue用于进程间的通讯</p>
<p>进程池中的通讯有3个queue需要区分</p>
<ol>
<li>系统from queue import Queue不能用于通讯</li>
<li>from mutiprocessing import Queue 不能用在进程池通讯</li>
<li>from mutiprocessing import Manager().queue 用于进程池pool中的通讯</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from multiprocessing import Process, Queue, Manager, Pipe</span><br><span class="line"></span><br><span class="line">def producer(queue):</span><br><span class="line">    queue.put(&apos;a&apos;)</span><br><span class="line">    time.sleep(2)</span><br><span class="line"></span><br><span class="line">def consumer(queue):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    queue = Queue(10)   #使用multi的queue</span><br><span class="line">    my_producer = Process(target=producer, args=(queue,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(queue,))</span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br><span class="line"></span><br><span class="line">    #manage 用于进程池中的通讯</span><br><span class="line">    queue = Manager().queue(10)</span><br><span class="line"></span><br><span class="line">    # pipe 用于两个进程间的通讯</span><br><span class="line">    # 通过pipe实现进程通信,pipe只适用与两个进程</span><br><span class="line">    # 为什么不直接用queue？因为pipe的性能高于queue</span><br><span class="line">    receiver_pipe, send_pipe = Pipe()</span><br><span class="line">    my_producer = Process(target=producer, args=(send_pipe,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(receiver_pipe,))</span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br><span class="line"></span><br><span class="line">    # 数据同步，以manager dict为例</span><br><span class="line">    def add_data(p_dict, key, value):</span><br><span class="line">        p_dict[key] = value</span><br><span class="line">    process_dict = Manager().dict()</span><br><span class="line">    first_progress = Process(target=add_data, args(process_dict,&apos;f&apos;,25))</span><br><span class="line">    second_progress = Process(target=add_data, args(process_dict,&apos;f2&apos;,27))</span><br><span class="line">    first_progress.start()</span><br><span class="line">    second_progress.start()</span><br><span class="line">    first_progress.join()</span><br><span class="line">    second_progress.join()</span><br></pre></td></tr></table></figure>

<h3 id="协程-（有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）"><a href="#协程-（有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）" class="headerlink" title="协程 （有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）"></a>协程 （有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>指在一个时间段内，有几个程序在同一个cpu上运行，但任意时刻只有一个程序在cpu上运行</p>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>指任意时刻有多个程序运行在多个cpu上</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>指代码调用io操作时，必须等待io操作完成才返回的调用方式</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>指代码调用io操作时，不必等待io操作完成就返回的调用方式（future）</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>指调用函数时，当前线程会被挂起（等待）</p>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><p>调用函数时，当前线程不会被挂起，而是立即返回</p>
<p>C10k问题，1999年被提出的一个挑战。要求在一颗1GHz CPU,2G内存,1gbps带宽，让单台服务器同时为1万个客户提供ftp服务。<br>如果为每个用户开一个线程，作为低配服务器做不到</p>
<h4 id="unix下五种io模型"><a href="#unix下五种io模型" class="headerlink" title="unix下五种io模型"></a>unix下五种io模型</h4><p>阻塞式io，在等待io操作时，cpu是空闲的</p>
<p>非阻塞式io，做计算任务或者单向发送请求，不需要等待返回的任务</p>
<p>I/O复用，select,poll,epoll由操作系统提供。<br>select查看那些socket或文件句柄已经准备好了，select可以同时监听多个socket</p>
<p>信号驱动式I/O,操作系统发起的用的较少</p>
<p>异步I/O(POSIX的aio_系列函数)，<br>其实很多并发框架都是使用io多路复用，用aio不多,aio与io复用并没有很明显的提升，编码难度比io复用高很多。</p>
<h3 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select,poll,epoll"></a>select,poll,epoll</h3><p>他们都是io多路复用机制。io多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般为读写就绪），能够通知程序进行相应的读写操作。但select,poll,epoll本质上都是同步io，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步io则无需自己负责进行读写，异步io的实现会负责把数据从内核拷贝到用户空间。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select函数监视的文件描述分3类，分别是writefds、readfds和exceptfds。调用后select函数会阻塞，知道有描述符就绪（数据可读可写，或有except),或者超时（timeout指定等待时间，如果立即返回设定为null）,函数返回。当select函数返回后，可以通过遍历fdset,来找到就绪的描述符。<br>select目前几乎在所有平台上支持。缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在linux上一般为1024，虽然可以修改，但是会造成效率降低。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。<br>pollfd没有最大数量限制。select和poll一样需要遍历文件描述符来获取已经就绪的socket，随着描述符数量增长，其效率也会下降。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>win不支持，linux2.6内核中提出，是select和poll的增强版。epoll查询使用性能很高的红黑树。<br>1.epoll并不代表一定比select好，在并发高的情况下，连接活跃度不高，epoll比较好（网站）。<br>并发性不高，同时连接活跃，select比较好（比如游戏）。</p>
<p>通过非阻塞io实现http请求</p>
<h4 id="C10M问题"><a href="#C10M问题" class="headerlink" title="C10M问题"></a>C10M问题</h4><p>如何利用8核心cpu，64G内存，在10gbps的网网上保持1000万并发连接</p>
<h4 id="协程解决的问题"><a href="#协程解决的问题" class="headerlink" title="协程解决的问题"></a>协程解决的问题</h4><p>主要是解决回调编写难的问题。保持性能+代码编写容易</p>
<p>1.采用同步的方式编写异步的代码<br>2.使用单线程去切换任务：<br>    1. 线程是由操作系统切换的，单线程切换意味着需要程序员去调度任务<br>    2. 不在需要锁，并发性高，如果单线程内切换函数，性能高于线程切换，</p>
<p>#传统函数调用方式 A-B-C,一旦调用其他函数，函数只运行一次然后退出<br>#我们需要一个可以暂停的函数，并且可以在适当的时候恢复该函数继续执行<br>#协程  -&gt; 有多个入口的函数，可以暂停的函数，并且可以向暂停的地方传入值<br>生成器就是可以暂停的函数</p>
<h3 id="生成器进阶send-close-throw"><a href="#生成器进阶send-close-throw" class="headerlink" title="生成器进阶send,close,throw"></a>生成器进阶send,close,throw</h3><p>send</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def gen_func():</span><br><span class="line">    #这种写法1.可以产出值 2.可以接受值</span><br><span class="line">    html = yield &quot;http://www.baidu.com&quot;</span><br><span class="line">    print(html)</span><br><span class="line">    yield 2</span><br><span class="line">    yield 3</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line">#生成器不仅可以产生值，还可以接受值</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    #启动生成器的方式有2种，1.next() 2.send</span><br><span class="line">    print(next(gen))</span><br><span class="line">    #send默认包含了next</span><br><span class="line">    print(gen.send(&apos;fank&apos;))</span><br><span class="line">    print(next(gen))</span><br></pre></td></tr></table></figure>

<p>close</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def gen_func():</span><br><span class="line">    #这种写法1.可以产出值 2.可以接受值</span><br><span class="line">    try:</span><br><span class="line">        yield &quot;http://www.baidu.com&quot;</span><br><span class="line">    except GeneratorExit:</span><br><span class="line">        pass</span><br><span class="line">    yield 2</span><br><span class="line">    yield 3</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line">#生成器不仅可以产生值，还可以接受值</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    #启动生成器的方式有2种，1.next() 2.send</span><br><span class="line">    print(next(gen))</span><br><span class="line">    gen.close()</span><br><span class="line">    print(next(gen))</span><br><span class="line"></span><br><span class="line">    #GeneratorExit是继承BaseException</span><br></pre></td></tr></table></figure>

<p>throw</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def gen_func():</span><br><span class="line">    #这种写法1.可以产出值 2.可以接受值</span><br><span class="line">    try:</span><br><span class="line">        yield &quot;http://www.baidu.com&quot;</span><br><span class="line">    except GeneratorExit:</span><br><span class="line">        pass</span><br><span class="line">    yield 2</span><br><span class="line">    yield 3</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line">#生成器不仅可以产生值，还可以接受值</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    #启动生成器的方式有2种，1.next() 2.send</span><br><span class="line">    print(next(gen))</span><br><span class="line">    gen.throw(Exception, &apos;download error&apos;) #没有向下执行，是当前yeild的异常</span><br></pre></td></tr></table></figure>

<h4 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h4><p>生成器实现协程是由程序员自己调度的，线程，进程由操作系统内核调度。协程是函数级别的</p>
<p>yield from是python3.3之后新加入的语法</p>
<p>python3.5之后的协程是原生协程，之前是利用生成器完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from itertools import chain</span><br><span class="line"></span><br><span class="line">my_list = [1,2,3]</span><br><span class="line">my_dict = &#123;</span><br><span class="line">    &apos;fank&apos;:&quot;fankcoder.com&quot;,</span><br><span class="line">    &apos;fank1&apos;:&quot;fankcoder1.com&quot;,</span><br><span class="line">    &apos;fank2&apos;:&quot;fankcoder2.com&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># yeild from 后面跟一个iterable</span><br><span class="line"># 但远不止这些，如果yeild from 跟生成器</span><br><span class="line">def my_chain(*args, **kwargs):</span><br><span class="line">    for item in args:</span><br><span class="line">        yield from item</span><br><span class="line">        # for each in item:</span><br><span class="line">        #     yield each</span><br><span class="line"></span><br><span class="line">for value in my_chain(my_list, my_dict, range(5,10)):</span><br><span class="line">    print(value)</span><br><span class="line"></span><br><span class="line">def g1(gen):</span><br><span class="line">    yield from gen</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    g = g1</span><br><span class="line">    g.send(None)</span><br><span class="line"></span><br><span class="line">#1. main调用生成器 2.g1委托生成器 3.gen子生成器</span><br><span class="line">#2. yield from 会在调用生成器和子生成器之间建立一个双向通道，</span><br><span class="line"># 两者可以互通，现在调用生成器可以直接发送close,throw到子生成器</span><br></pre></td></tr></table></figure>

<p>协程调度，事件循环+协程模式，协程是单线程模式.<br>编写时候凡是遇到耗io的操作，都用啥yield或yield from模式.<br>tornado是生成器生成的协程.</p>
<h4 id="async和await-原生协程"><a href="#async和await-原生协程" class="headerlink" title="async和await 原生协程"></a>async和await 原生协程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#python3.5以后为了将语义变得更加明确，就引入了async和await关键词来定义原生协程</span><br><span class="line"># async下不能再出现yield,同样await只能出现在async下</span><br><span class="line"># await 后面跟的函数必须是awaitable也就是加了async的函数</span><br><span class="line">import types</span><br><span class="line"></span><br><span class="line">async def downloader(url):</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line"># 另一种方法让函数变为awaitable，但是我没有试验成功。不过这种方法本来不推荐</span><br><span class="line">@types.coroutine</span><br><span class="line">def downloader2(url):</span><br><span class="line">    return &apos;fank2&apos;</span><br><span class="line"></span><br><span class="line">async def download_url(url):</span><br><span class="line">    # do something</span><br><span class="line">    # await对应生成器的yield from</span><br><span class="line">    html = await downloader2(url)</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    coro = download_url(&apos;http://www.google.com&apos;)</span><br><span class="line">    # next(coro)  原生协程不能这样调用</span><br><span class="line">    coro.send(None)</span><br></pre></td></tr></table></figure>

<h3 id="asyncio模块"><a href="#asyncio模块" class="headerlink" title="asyncio模块"></a>asyncio模块</h3><p>把它叫做异步Io库，并不叫协程库，这里包含了多线程，多进程，协程</p>
<ol>
<li>包含各种特定系统实现的模块化事件循环</li>
<li>传输和协议抽象</li>
<li>对tcp,udp,ssl,子进程，延时调用以及其他的具体支持</li>
<li>模仿Futures模块但适用于事件循环适用的Future类</li>
<li>基于yield from的协议和任务，可以让你用顺序的方式编写并发代码</li>
<li>必须使用一个将产生阻塞io的调用时，哟接口可以把这个事件转移到线程池</li>
<li>模仿threading模块中的同步原语，可以用在单线程内的协程之间</li>
</ol>
<p> asyncio 异步io并发编程 py3.4以后支持</p>
<p>事件循环</p>
<p>协程编码模式3个：1.事件循环 2.回调(驱动生成器) 3.epoll（io多路复用）</p>
<p>应用：tornado, gevent, twisted(scrapy, django channels)</p>
<p>ps: tornado不建议使用Pymysql,mysqlclient</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#事件循环+回调（驱动生成器）+epoll(IO多路复用)</span><br><span class="line">#asyncio是Python用于解决异步io的一整套解决方案</span><br><span class="line">#tornado,gevent,twisted(scrapy, dango channels(http2.0 websocket) 目前都是基于twisted)</span><br><span class="line">#tornado(实现了web服务器)，django+flask(uwsgi,gunicorn+nginx)</span><br><span class="line">#tornado可以直接部署，外加nginx</span><br><span class="line"></span><br><span class="line">#asyncio</span><br><span class="line">import asyncio</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">async def get_html(url):</span><br><span class="line">    print(&apos;start get html&apos;)</span><br><span class="line">    #time.sleep()  #不能使用同步阻塞的方法</span><br><span class="line">    await asyncio.sleep(2)  #耗时操作，io操作加await</span><br><span class="line">    print(&apos;end get url&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop  = asyncio.get_event_loop()  #事件循环，自动select</span><br><span class="line">    tasks = [get_html(&apos;http://www.google.com&apos;) for i in range(10)]</span><br><span class="line">    # loop.run_until_complete(get_html(&apos;http://www.google.com&apos;))</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(&apos;time:&apos;, time.time() - start_time)</span><br><span class="line"></span><br><span class="line">#获取协程的返回值</span><br><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line">async def get_html(url):</span><br><span class="line">    print(&apos;start get html&apos;)</span><br><span class="line">    #time.sleep()  #不能使用同步阻塞的方法</span><br><span class="line">    await asyncio.sleep(2)  #耗时操作，io操作加await</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line">def callback(url, future): #partial url 要写在前面</span><br><span class="line">    print(url)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop  = asyncio.get_event_loop()  #事件循环，自动select</span><br><span class="line">    # get_future = asyncio.ensure_future(get_html(&apos;http://www.google.com&apos;))  #一个线程只有一个loop，这里ensure_future自动帮我们获取loop</span><br><span class="line">    task = loop.create_task(get_html(&apos;http://www.google.com&apos;))  #和上一句等效</span><br><span class="line">    # loop.run_until_complete(get_html(&apos;http://www.google.com&apos;))</span><br><span class="line">    # task.add_done_callback(callback)</span><br><span class="line">    #如过callback需要传参</span><br><span class="line">    task.add_done_callback(partial(callback, &apos;http://www.googl.com&apos;))</span><br><span class="line"></span><br><span class="line">    # loop.run_until_complete(get_future)</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    # print(get_future.result())</span><br><span class="line">    print(&apos;time:&apos;, time.time() - start_time)</span><br><span class="line"></span><br><span class="line">#wait 和gather的用法和区别</span><br><span class="line">#gather更加高层，可以分组</span><br><span class="line">async def get_html(url):</span><br><span class="line">    print(&apos;start get html&apos;)</span><br><span class="line">    #time.sleep()  #不能使用同步阻塞的方法</span><br><span class="line">    await asyncio.sleep(2)  #耗时操作，io操作加await</span><br><span class="line">    print(&apos;end get url&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop  = asyncio.get_event_loop()  #事件循环，自动select</span><br><span class="line">    group1 = [get_html(&apos;http://www.google.com&apos;) for i in range(10)]</span><br><span class="line">    group2 = [get_html(&apos;http://www.google.com&apos;) for i in range(10)]</span><br><span class="line">    # loop.run_until_complete(get_html(&apos;http://www.google.com&apos;))</span><br><span class="line">    group2.cancel() #批量取消</span><br><span class="line">    loop.run_until_complete(asyncio.gather(*group1, *group2))</span><br><span class="line">    print(&apos;time:&apos;, time.time() - start_time)</span><br></pre></td></tr></table></figure>

<h4 id="取消task"><a href="#取消task" class="headerlink" title="取消task"></a>取消task</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># run_until_complete</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line"># loop = asyncio.get_event_loop()</span><br><span class="line"># loop.run_forever()  #不会停止，会一直运行</span><br><span class="line"># loop.run_until_complete()  #运行了指定的协程之后会停止</span><br><span class="line"></span><br><span class="line">async def get_html(sleep_times):</span><br><span class="line">    print(&apos;waiting&apos;)</span><br><span class="line">    await asyncio.sleep(sleep_times)</span><br><span class="line">    print(&apos;done after &#123;&#125;&apos;.format(sleep_times))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    task1 = get_html(2)</span><br><span class="line">    task2 = get_html(3)</span><br><span class="line">    task3 = get_html(3)</span><br><span class="line"></span><br><span class="line">    tasks = [task1, task2, task3]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    except KeyboardInterrupt as e:</span><br><span class="line">        all_tasks = asyncio.Task.all_tasks()</span><br><span class="line">        for task in all_tasks:</span><br><span class="line">            print(&apos;cancel task&apos;)</span><br><span class="line">            print(task.cancel())</span><br><span class="line">        loop.stop()</span><br><span class="line">        loop.run_forever()  #很关键，不加会报错</span><br><span class="line">    finally:</span><br><span class="line">        loop.close()</span><br></pre></td></tr></table></figure>

<h4 id="底层方法call-soon-call-later-call-at"><a href="#底层方法call-soon-call-later-call-at" class="headerlink" title="底层方法call_soon,call_later,call_at"></a>底层方法call_soon,call_later,call_at</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">#可以给asyncio直接传递函数（不是async函数）</span><br><span class="line">def callback(sleep_time):</span><br><span class="line">    print(&apos;sleep &#123;&#125; success&apos;.format(sleep_time))</span><br><span class="line"></span><br><span class="line">def stoploop(loop):</span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.call_soon(callback, 2)  #即刻执行，在队列里等到下一个循环立马执行</span><br><span class="line">    loop.call_soon(stoploop, loop)</span><br><span class="line"></span><br><span class="line">    loop.call_later(2,callback,2)  #在2秒钟之后运行callback</span><br><span class="line">    loop.call_later(1,callback,1)</span><br><span class="line">    loop.call_later(3,callback,3)</span><br><span class="line"></span><br><span class="line">    now = loop.time()  #loop的time</span><br><span class="line">    loop.call_at(now+2, callback, 2)</span><br><span class="line">    loop.call_at(now+3, callback, 3)</span><br><span class="line"></span><br><span class="line">    loop.call_soon_threadsafe()  #变量线程安全</span><br><span class="line"></span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure>

<h4 id="asyncio-ThreadPollExecutor"><a href="#asyncio-ThreadPollExecutor" class="headerlink" title="asyncio+ThreadPollExecutor"></a>asyncio+ThreadPollExecutor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#使用多线程:在协程中继承阻塞io(某些库就是阻塞的)</span><br><span class="line">import asyncio</span><br><span class="line">import socket</span><br><span class="line">from urllib.parse import urlparse</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">def get_url(url):</span><br><span class="line">    # get html by socket</span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    if path == &apos;&apos;:</span><br><span class="line">        path = &apos;/&apos;</span><br><span class="line">    </span><br><span class="line">    #connect socket</span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.connect((host, 80))</span><br><span class="line">    client.send(&quot;GET &#123;&#125; HTTP/1.1\r\nHOST:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode(&apos;utf8&apos;))</span><br><span class="line">    </span><br><span class="line">    data = b&apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        d = client.recv(1024)</span><br><span class="line">        if d:</span><br><span class="line">            data += d</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    data = data.decode(&apos;utf8&apos;)</span><br><span class="line">    htmldata = data.split(&apos;\r\n\r\n&apos;)[1]</span><br><span class="line">    print(htmldata)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    executor = ThreadPoolExecutor(3)</span><br><span class="line">    tasks = []</span><br><span class="line">    for i in range(20):</span><br><span class="line">        #参数1.线程池 2.函数名 3.函数参数</span><br><span class="line">       task = loop.run_in_executor(executor, get_url, &apos;http://www.baidu.com/&#123;&#125;&apos;.format(i))  #将某个阻塞Io函数放入executor中运行</span><br><span class="line">       tasks.append(task)</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>

<h4 id="同步的方式实现异步http模拟请"><a href="#同步的方式实现异步http模拟请" class="headerlink" title="同步的方式实现异步http模拟请"></a>同步的方式实现异步http模拟请</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#asyncio没有提供http协议的接口；aiohttp异步的requests，可以启动服务器，可以爬虫</span><br><span class="line">#同步的方式实现异步http模拟请求</span><br><span class="line">import asyncio</span><br><span class="line">import socket</span><br><span class="line">from urllib.parse import urlparse</span><br><span class="line"></span><br><span class="line">async def get_url(url):</span><br><span class="line">    # get html by socket</span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    if path == &apos;&apos;:</span><br><span class="line">        path = &apos;/&apos;</span><br><span class="line">    </span><br><span class="line">    #connect socket</span><br><span class="line">    reader, writer = await asyncio.open_connection(host, 80)  #线程</span><br><span class="line">    writer.write(&quot;GET &#123;&#125; HTTP/1.1\r\nHOST:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode(&apos;utf8&apos;))</span><br><span class="line">    </span><br><span class="line">    all_lines = []</span><br><span class="line">    async for raw_line in reader:  #异步化，因为内部有yield from语法</span><br><span class="line">        data = raw_line.decode(&apos;utf8&apos;)</span><br><span class="line">        all_lines.append(data)</span><br><span class="line"></span><br><span class="line">    html = &apos;\n&apos;.join(all_lines)</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = []</span><br><span class="line">    for i in range(20):</span><br><span class="line">        url = &apos;http://www.baidu.com/&#123;&#125;&apos;.format(i)</span><br><span class="line">        tasks.append(asyncio.ensure_future(get_url(url)))</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    for task in tasks:</span><br><span class="line">        print(task.result()</span><br></pre></td></tr></table></figure>

<h4 id="asyncio同步和通信"><a href="#asyncio同步和通信" class="headerlink" title="asyncio同步和通信"></a>asyncio同步和通信</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">from asyncio import Lock,Queue</span><br><span class="line">queue = Queue()</span><br><span class="line">await queue.get()</span><br><span class="line">queue1 = [] #普通的全局变量也能用，但是不能控制Size流量</span><br><span class="line"></span><br><span class="line">cache = &#123;&#125;</span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line">async def get_stuff(url):</span><br><span class="line">    async with lock:</span><br><span class="line">        # await lock.acquire()  #async </span><br><span class="line">        if url in cache:</span><br><span class="line">            return cache[url]</span><br><span class="line">        stuff = await aiohttp.request(&apos;get&apos;, url)</span><br><span class="line">        cache[url] = stuff</span><br><span class="line">        return stuff</span><br><span class="line">        # lock.release()  #不需要await</span><br><span class="line"></span><br><span class="line">async def parse_stuff():</span><br><span class="line">    stuff = await get_stuff()</span><br><span class="line"></span><br><span class="line">async def use_stuff():</span><br><span class="line">    stuff = await get_stuff()</span><br></pre></td></tr></table></figure>

<h3 id="aiohttp实现高并发爬虫"><a href="#aiohttp实现高并发爬虫" class="headerlink" title="aiohttp实现高并发爬虫"></a>aiohttp实现高并发爬虫</h3><h4 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h4><p>HTTP client/server framework for asyncio</p>
<p>server可以搭建http服务器</p>
<h3 id="client爬虫"><a href="#client爬虫" class="headerlink" title="client爬虫"></a>client爬虫</h3><p>爬取Url<br>抽取内部Url<br>过滤<br>反爬<br>分布式</p>
<h4 id="sanic"><a href="#sanic" class="headerlink" title="sanic"></a>sanic</h4><p>号称可以媲美go性能的高并发web服务器</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/python/" rel="tag"><i class="fa fa-tag"></i> python</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/03/08/technology-2019-03-08-appspider-tools/" rel="next" title="Ubuntu&OSX的app抓包方案">
                  <i class="fa fa-chevron-left"></i> Ubuntu&OSX的app抓包方案
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/04/02/tool-2019-04-02-ss-config/" rel="prev" title="vps上网">
                  vps上网 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
    
  <div class="comments" id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#collections"><span class="nav-number">1.</span> <span class="nav-text">collections</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tuple功能"><span class="nav-number">1.1.</span> <span class="nav-text">tuple功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tuple比list好的地方"><span class="nav-number">1.2.</span> <span class="nav-text">tuple比list好的地方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#namedtuple"><span class="nav-number">1.3.</span> <span class="nav-text">namedtuple</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#def-ask-args-kwargs"><span class="nav-number">1.4.</span> <span class="nav-text">def ask(args, *kwargs)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deque双端队列"><span class="nav-number">1.5.</span> <span class="nav-text">deque双端队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#counter"><span class="nav-number">1.6.</span> <span class="nav-text">counter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defaultdict"><span class="nav-number">1.7.</span> <span class="nav-text">defaultdict</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OrderDict是有序的"><span class="nav-number">1.8.</span> <span class="nav-text">OrderDict是有序的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ChainMap"><span class="nav-number">1.9.</span> <span class="nav-text">ChainMap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inspect"><span class="nav-number">2.</span> <span class="nav-text">inspect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-object和class的关系"><span class="nav-number">3.</span> <span class="nav-text">type,object和class的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内置类型"><span class="nav-number">4.</span> <span class="nav-text">内置类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#魔法函数"><span class="nav-number">5.</span> <span class="nav-text">魔法函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#鸭子类型和多态"><span class="nav-number">6.</span> <span class="nav-text">鸭子类型和多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象基类abc模块"><span class="nav-number">7.</span> <span class="nav-text">抽象基类abc模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象基类abc模块-1"><span class="nav-number">8.</span> <span class="nav-text">抽象基类abc模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类变量和实例变量"><span class="nav-number">8.1.</span> <span class="nav-text">类变量和实例变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的私有属性"><span class="nav-number">9.</span> <span class="nav-text">类的私有属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自省机制"><span class="nav-number">10.</span> <span class="nav-text">自省机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">11.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mixin模式"><span class="nav-number">12.</span> <span class="nav-text">mixin模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#with上下文管理器"><span class="nav-number">13.</span> <span class="nav-text">with上下文管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#contextlib简化上下文管理器"><span class="nav-number">14.</span> <span class="nav-text">contextlib简化上下文管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类和对象"><span class="nav-number">15.</span> <span class="nav-text">类和对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#is-和"><span class="nav-number">16.</span> <span class="nav-text">is 和 ==</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义序列类"><span class="nav-number">17.</span> <span class="nav-text">自定义序列类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extend"><span class="nav-number">18.</span> <span class="nav-text">+,+=,extend</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bisect二分查找"><span class="nav-number">19.</span> <span class="nav-text">bisect二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表推导式（生成式）-amp-生成器表达式"><span class="nav-number">20.</span> <span class="nav-text">列表推导式（生成式）&amp;生成器表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深入set和dict"><span class="nav-number">21.</span> <span class="nav-text">深入set和dict</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dict的formkeys方法"><span class="nav-number">21.1.</span> <span class="nav-text">dict的formkeys方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get方法"><span class="nav-number">21.2.</span> <span class="nav-text">get方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#items"><span class="nav-number">21.3.</span> <span class="nav-text">items</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setdefault-增加get方法"><span class="nav-number">21.4.</span> <span class="nav-text">setdefault 增加get方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#update"><span class="nav-number">21.5.</span> <span class="nav-text">update</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dict子类"><span class="nav-number">22.</span> <span class="nav-text">dict子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-fronzenset"><span class="nav-number">23.</span> <span class="nav-text">set fronzenset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#set-difference"><span class="nav-number">23.1.</span> <span class="nav-text">set difference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dict和set实现原理"><span class="nav-number">23.2.</span> <span class="nav-text">dict和set实现原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#property"><span class="nav-number">24.</span> <span class="nav-text">property</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getattr与getattribute的区别"><span class="nav-number">25.</span> <span class="nav-text">getattr与getattribute的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性描述符"><span class="nav-number">26.</span> <span class="nav-text">属性描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new和init区别"><span class="nav-number">27.</span> <span class="nav-text">new和init区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元类编程"><span class="nav-number">28.</span> <span class="nav-text">元类编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器和生成器"><span class="nav-number">29.</span> <span class="nav-text">迭代器和生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket编程"><span class="nav-number">30.</span> <span class="nav-text">socket编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程-amp-进程"><span class="nav-number">31.</span> <span class="nav-text">线程&amp;进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过thread类实例化"><span class="nav-number">31.1.</span> <span class="nav-text">通过thread类实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承thread来实现多线程"><span class="nav-number">31.2.</span> <span class="nav-text">继承thread来实现多线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程之间的通信方式"><span class="nav-number">32.</span> <span class="nav-text">线程之间的通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-共享全局变量-list-（多线程可以，多进程不行）"><span class="nav-number">32.1.</span> <span class="nav-text">1.共享全局变量(list)（多线程可以，多进程不行）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-通过queue方法进行线程间通讯-queue本身是线程安全的"><span class="nav-number">32.2.</span> <span class="nav-text">2.通过queue方法进行线程间通讯,queue本身是线程安全的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程同步（lock-rlock）"><span class="nav-number">33.</span> <span class="nav-text">线程同步（lock, rlock）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rlock可重入的锁"><span class="nav-number">33.1.</span> <span class="nav-text">rlock可重入的锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#condition条件变量"><span class="nav-number">34.</span> <span class="nav-text">condition条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore-控制线程并发数量"><span class="nav-number">35.</span> <span class="nav-text">Semaphore 控制线程并发数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池concurrent-py3-2"><span class="nav-number">36.</span> <span class="nav-text">线程池concurrent #py3.2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多进程"><span class="nav-number">37.</span> <span class="nav-text">多进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#更加底层的多进程包"><span class="nav-number">37.1.</span> <span class="nav-text">更加底层的多进程包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间的通讯"><span class="nav-number">38.</span> <span class="nav-text">进程间的通讯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程-（有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）"><span class="nav-number">39.</span> <span class="nav-text">协程 （有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#并发"><span class="nav-number">39.1.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行"><span class="nav-number">39.2.</span> <span class="nav-text">并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步"><span class="nav-number">39.3.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步"><span class="nav-number">39.4.</span> <span class="nav-text">异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞"><span class="nav-number">39.5.</span> <span class="nav-text">阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非阻塞"><span class="nav-number">39.6.</span> <span class="nav-text">非阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unix下五种io模型"><span class="nav-number">39.7.</span> <span class="nav-text">unix下五种io模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-poll-epoll"><span class="nav-number">40.</span> <span class="nav-text">select,poll,epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#select"><span class="nav-number">40.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poll"><span class="nav-number">40.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll"><span class="nav-number">40.3.</span> <span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C10M问题"><span class="nav-number">40.4.</span> <span class="nav-text">C10M问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协程解决的问题"><span class="nav-number">40.5.</span> <span class="nav-text">协程解决的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器进阶send-close-throw"><span class="nav-number">41.</span> <span class="nav-text">生成器进阶send,close,throw</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#yield-from"><span class="nav-number">41.1.</span> <span class="nav-text">yield from</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#async和await-原生协程"><span class="nav-number">41.2.</span> <span class="nav-text">async和await 原生协程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asyncio模块"><span class="nav-number">42.</span> <span class="nav-text">asyncio模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#取消task"><span class="nav-number">42.1.</span> <span class="nav-text">取消task</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#底层方法call-soon-call-later-call-at"><span class="nav-number">42.2.</span> <span class="nav-text">底层方法call_soon,call_later,call_at</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#asyncio-ThreadPollExecutor"><span class="nav-number">42.3.</span> <span class="nav-text">asyncio+ThreadPollExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步的方式实现异步http模拟请"><span class="nav-number">42.4.</span> <span class="nav-text">同步的方式实现异步http模拟请</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#asyncio同步和通信"><span class="nav-number">42.5.</span> <span class="nav-text">asyncio同步和通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aiohttp实现高并发爬虫"><span class="nav-number">43.</span> <span class="nav-text">aiohttp实现高并发爬虫</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#aiohttp"><span class="nav-number">43.1.</span> <span class="nav-text">aiohttp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#client爬虫"><span class="nav-number">44.</span> <span class="nav-text">client爬虫</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sanic"><span class="nav-number">44.1.</span> <span class="nav-text">sanic</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="fankcoder">
  <p class="site-author-name" itemprop="name">fankcoder</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/fankcoder" title="GitHub &rarr; https://github.com/fankcoder" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:fankcoder@gmail.com" title="E-Mail &rarr; mailto:fankcoder@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://weibo.com/u/2424646683" title="Weibo &rarr; https://weibo.com/u/2424646683" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://www.zhihu.com/people/si-xie-san-qiu/activities" title="Zhihu &rarr; https://www.zhihu.com/people/si-xie-san-qiu/activities" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>Zhihu</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://space.bilibili.com/38307214" title="Bilibili &rarr; https://space.bilibili.com/38307214" rel="noopener" target="_blank"><i class="fa fa-fw fa-tv"></i>Bilibili</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://steamcommunity.com/id/fankcoder" title="Steam &rarr; https://steamcommunity.com/id/fankcoder" rel="noopener" target="_blank"><i class="fa fa-fw fa-steam"></i>Steam</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://coolshell.cn/" title="https://coolshell.cn/" rel="noopener" target="_blank">coolshell</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="http://www.lining0806.com" title="http://www.lining0806.com" rel="noopener" target="_blank">lining0806</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fankcoder</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.1</div>

        












        
      </div>
    </footer>
  </div>

  
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>



  








  <script>
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','msMtA93nEGFTkf4tckPn','2.0.0');
</script>















  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/disqusjs@1/dist/disqusjs.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/disqusjs@1/dist/disqus.js', () => {
    window.dsqjs = new DisqusJS({
      api: '' || 'https://disqus.com/api/',
      apikey: 'ccFXs3SHC1xt1w3C801oWR1tIHF3IYsLNsbB6breN2uRt2bE1usUPCVbiH1PRRnT',
      shortname: 'fankcoder',
      url: "http://fankcoder.com/2019/03/08/technology-2019-03-08-python-deep/",
      identifier: "2019/03/08/technology-2019-03-08-python-deep/",
      title: 'Python深入学习笔记',
    });
  }, window.DisqusJS);
</script>

</body>
</html>
