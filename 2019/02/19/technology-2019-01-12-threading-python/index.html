<!DOCTYPE html>





<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/small.jpg?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="thread">
<meta name="keywords" content="thread">
<meta property="og:type" content="article">
<meta property="og:title" content="Python线程&amp;进程&amp;协程&amp;asyncio">
<meta property="og:url" content="http://fankcoder.com/2019/02/19/technology-2019-01-12-threading-python/index.html">
<meta property="og:site_name" content="三秋">
<meta property="og:description" content="thread">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-11T09:26:30.004Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python线程&amp;进程&amp;协程&amp;asyncio">
<meta name="twitter:description" content="thread">
  <link rel="canonical" href="http://fankcoder.com/2019/02/19/technology-2019-01-12-threading-python/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Python线程&进程&协程&asyncio | 三秋</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-149748039-1"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-149748039-1');
      }
    </script>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">三秋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Think twice, code onece.</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/fankcoder" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fankcoder.com/2019/02/19/technology-2019-01-12-threading-python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fankcoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三秋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Python线程&进程&协程&asyncio

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-02-19 16:07:56" itemprop="dateCreated datePublished" datetime="2019-02-19T16:07:56+08:00">2019-02-19</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-04-11 17:26:30" itemprop="dateModified" datetime="2019-04-11T17:26:30+08:00">2019-04-11</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            <div class="post-description">thread</div>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="线程-amp-进程"><a href="#线程-amp-进程" class="headerlink" title="线程&amp;进程"></a>线程&amp;进程</h3><p>GIL global interpreter lock GIL全局解释锁</p>
<p>python中一个线程对应于c中的线程</p>
<p>python是先将py文件编译为字节码</p>
<p>gil使得同一时刻只有一个线程在一个cpu上执行字节码，无法将多个线程映射到多个cpu上 </p>
<p>为了安全，但速度慢，无法体现多核优势。pypy是去gil化的。gil在遇到io操作会主动释放</p>
<p>操作系统调度的最小单元线程，对于io操作，多线程和多进程差别不大。</p>
<h4 id="通过thread类实例化"><a href="#通过thread类实例化" class="headerlink" title="通过thread类实例化"></a>通过thread类实例化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread1 = threading.Thread(target=func, args=(&quot;&quot;,))</span><br><span class="line"></span><br><span class="line">thread1.setDaemon(True)#设置为守护线程。当主线程关闭时，子线程被kill</span><br><span class="line"></span><br><span class="line">thread1.join() #阻塞，等待thread1子线程执行完成</span><br></pre></td></tr></table></figure>

<h4 id="继承thread来实现多线程"><a href="#继承thread来实现多线程" class="headerlink" title="继承thread来实现多线程"></a>继承thread来实现多线程</h4><p>当代码量大，逻辑复杂时，推荐通过继承thread来实现多线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class GetDetailHtml(threading.Thread):</span><br><span class="line">    def __init__(self, name):   #为线程命名，好习惯</span><br><span class="line">        super().__init__(name=name)</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;get detail html&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&apos;get detail html done&apos;)</span><br><span class="line"></span><br><span class="line">class GetTitleHtml(threading.Thread):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        super().__init__(name=name)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&apos;get title url&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&apos;get title url done&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    thread1 = GetTitleHtml(&apos;get title html&apos;)</span><br><span class="line">    thread2 = GetDetailHtml(&apos;get detail html&apos;)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line">    print(&apos;last time &#123;&#125;&apos;.format(time.time() - start_time))</span><br></pre></td></tr></table></figure>



<h3 id="线程之间的通信方式"><a href="#线程之间的通信方式" class="headerlink" title="线程之间的通信方式"></a>线程之间的通信方式</h3><h4 id="1-共享全局变量-list-（多线程可以，多进程不行）"><a href="#1-共享全局变量-list-（多线程可以，多进程不行）" class="headerlink" title="1.共享全局变量(list)（多线程可以，多进程不行）"></a>1.共享全局变量(list)（多线程可以，多进程不行）</h4><p>这种方法，线程并不安全，需要加gil锁，所以并不推荐用作通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">#1.共享全局变量</span><br><span class="line">detail_url_list = []</span><br><span class="line"></span><br><span class="line">def get_title_html(detail_url_list):</span><br><span class="line">    print(&apos;get title url&apos;)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    for i in range(20):</span><br><span class="line">        detail_url_list.append(&apos;http://www.test.com/id/&#123;&#125;/&apos;.format(i))</span><br><span class="line">    print(&apos;get title url done&apos;)</span><br><span class="line"></span><br><span class="line">def get_detail_html(detail_url_list):</span><br><span class="line">    print(&apos;get detail html&apos;)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    if len(detail_url_list):</span><br><span class="line">        url = detail_url_list.pop()</span><br><span class="line">        print(&apos;get detail html done&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    thread1 = threading.Thread(target=get_title_html, args=(detail_url_list,))</span><br><span class="line">    for i in range(10): #启动10个线程，太多线程操作系统切换会产生很大代价</span><br><span class="line">        html_thread = threading.Thread(target=get_detail_html, args=(detail_url_list,))</span><br><span class="line">        html_thread.start()</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    print(&apos;last time &#123;&#125;&apos;.format(time.time() - start_time))</span><br></pre></td></tr></table></figure>

<h4 id="2-通过queue方法进行线程间通讯-queue本身是线程安全的"><a href="#2-通过queue方法进行线程间通讯-queue本身是线程安全的" class="headerlink" title="2.通过queue方法进行线程间通讯,queue本身是线程安全的"></a>2.通过queue方法进行线程间通讯,queue本身是线程安全的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def get_title_html(queue):</span><br><span class="line">    while True:</span><br><span class="line">        print(&apos;get title url&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        for i in range(20):</span><br><span class="line">            queue.put(&apos;http://www.test.com/id/&#123;&#125;/&apos;.format(i))</span><br><span class="line">        print(&apos;get title url done&apos;)</span><br><span class="line"></span><br><span class="line">def get_detail_html(queue):</span><br><span class="line">    while True:</span><br><span class="line">        print(&apos;get detail html&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        url = queue.get()  #get方法是阻塞方法，如果queue为空就等待</span><br><span class="line">        print(&apos;get detail html done&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    detail_queue = Queue(maxsize=1000)</span><br><span class="line">    thread1 = threading.Thread(target=get_title_html, args=(detail_queue,))</span><br><span class="line">    for i in range(10): #启动10个线程，太多线程操作系统切换会产生很大代价</span><br><span class="line">        html_thread = threading.Thread(target=get_detail_html, args=(detail_queue,))</span><br><span class="line">        html_thread.start()</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    print(&apos;last time &#123;&#125;&apos;.format(time.time() - start_time))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">queue.get()#阻塞方法，如果为空就一直停顿等待</span><br><span class="line">queue.put_nowait()#设置为非阻塞</span><br><span class="line">queue.qsize() #获取长度，同样是线程安全的可以直接使用</span><br><span class="line">queue.empty()</span><br><span class="line">queue.full()</span><br><span class="line">queue.join()#阻塞直到执行到task_done()</span><br><span class="line">queue.task_done()</span><br></pre></td></tr></table></figure>

<p>.join()一直阻塞，想退出需要调用.task_down() #爬虫暂停</p>
<p>如果共用变量为dict或其他非队列数据，也可以考虑使用全局变量</p>
<h3 id="线程同步（lock-rlock）"><a href="#线程同步（lock-rlock）" class="headerlink" title="线程同步（lock, rlock）"></a>线程同步（lock, rlock）</h3><p>避免淘宝库存同时有人买<br>线程同步机制,lock锁，反正锁住的代码段都只能有一个在运行，释放之后才能让其他代码运行.</p>
<p>使用锁会出现的问题</p>
<ol>
<li>用锁会影响性能</li>
<li>锁会引起死锁（互相等待）,不能连续调用两次acquire</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from threading import Lock</span><br><span class="line"></span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line">global lock</span><br><span class="line"></span><br><span class="line">lock.acquire() #获取</span><br><span class="line"></span><br><span class="line">a += 1</span><br><span class="line"></span><br><span class="line">lock.release() #释放</span><br></pre></td></tr></table></figure>

<p>死锁情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A(a, b)</span><br><span class="line">acquire(a)</span><br><span class="line">acquire(b)</span><br><span class="line"></span><br><span class="line">B(a, b)</span><br><span class="line">acquire(b) # a,b同时等待</span><br><span class="line">acquire(a)</span><br></pre></td></tr></table></figure>

<h4 id="rlock可重入的锁"><a href="#rlock可重入的锁" class="headerlink" title="rlock可重入的锁"></a>rlock可重入的锁</h4><p>解决lock，不能连续调用acquire的问题。它可以在同一个线程里面，可以连续调用多次acquire，需要相等数量的release.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from threading import RLock</span><br><span class="line">lock = Rlock()</span><br><span class="line"></span><br><span class="line">lock.acquire()</span><br><span class="line">lock.acquire()</span><br><span class="line">lock.release()</span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure>

<h3 id="condition条件变量"><a href="#condition条件变量" class="headerlink" title="condition条件变量"></a>condition条件变量</h3><p>用于复杂的线程间同步锁</p>
<p>wait()允许等待某个条件变量的通知<br>notify()会通知调用了wait()方法的那个线程启动</p>
<ol>
<li>使用condition启动顺序非常重要</li>
<li>一定要先调用with方法或者acquire和release，之后再调用wait(),notify()</li>
<li>condition有两层锁，一把底层锁会在线程调用wait方法的时候释放，上面的锁会值每次调用wait时分配一把并放入到cond的等待队列中，等到notify方法唤醒</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">from threading import Condition</span><br><span class="line"></span><br><span class="line">class XiaAi(threading.Thread):</span><br><span class="line">    def __init__(self, cond):</span><br><span class="line">        super().__init__(name=&apos;小爱&apos;)</span><br><span class="line">        self.cond = cond</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        with self.cond:</span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(&apos;&#123;&#125;: 在&apos;.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(&apos;&#123;&#125;: 好啊&apos;.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">    </span><br><span class="line">class TianMao(threading.Thread):</span><br><span class="line">    def __init__(self, cond):</span><br><span class="line">        super().__init__(name=&apos;天猫&apos;)</span><br><span class="line">        self.cond = cond</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        with self.cond:</span><br><span class="line">            print(&apos;&#123;&#125;: 小爱同学&apos;.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">            print(&apos;&#123;&#125;: 我们来对古诗吧&apos;.format(self.name))</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    cond = threading.Condition()</span><br><span class="line"></span><br><span class="line">    xiaoai = XiaAi(cond)</span><br><span class="line">    tianmao = TianMao(cond)</span><br><span class="line"></span><br><span class="line">    xiaoai.start()</span><br><span class="line">    tianmao.start()</span><br><span class="line">    xiaoai.join()</span><br><span class="line">    tianmao.join()</span><br></pre></td></tr></table></figure>

<h3 id="Semaphore-控制线程并发数量"><a href="#Semaphore-控制线程并发数量" class="headerlink" title="Semaphore 控制线程并发数量"></a>Semaphore 控制线程并发数量</h3><p>(文件读写，写一般只用一个线程，读可以允许有多个线程)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HtmlSpider(threading.Thread):</span><br><span class="line">    def __init__(self, url, sem):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.url = url</span><br><span class="line">        self.sem = sem</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        print(&apos;get html success&apos;)</span><br><span class="line">        self.sem.release()</span><br><span class="line"></span><br><span class="line">class UrlProducer(threading.Thread):</span><br><span class="line">    def __init__(self, sem):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.sem = sem</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        for i in range(10):</span><br><span class="line">            self.sem.acquire()</span><br><span class="line">            html_thread = HtmlSpider(&apos;http://www.baidu.com/id/&#123;&#125;/&apos;.format(i), self.sem)</span><br><span class="line">            html_thread.start()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sem = threading.Semaphore(3)</span><br><span class="line">    url_thread = UrlProducer(sem)</span><br><span class="line">    url_thread.start()</span><br></pre></td></tr></table></figure>

<h3 id="线程池concurrent-py3-2"><a href="#线程池concurrent-py3-2" class="headerlink" title="线程池concurrent #py3.2"></a>线程池concurrent #py3.2</h3><p>concurrent容易的编写多线程，多进程代码</p>
<p>为什么使用线程池？</p>
<p>1.主线程中可以获取某一个线程的状态或者某一个任务的状态，以及返回值</p>
<p>2.当一个线程完成的时候，主线程能立即知道</p>
<p>3.futures可以让多线程多进程编码接口一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor,as_completed,wait,FIRST_COMPLETED</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def get_html(times):</span><br><span class="line">    time.sleep(times)</span><br><span class="line">    print(&apos;get html &#123;&#125; success&apos;.format(times))</span><br><span class="line">    return times</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=2)</span><br><span class="line"></span><br><span class="line">#通过submit提交执行的函数到线程池中，submit是立即返回</span><br><span class="line">task1 = executor.submit(get_html, (3))</span><br><span class="line">task2 = executor.submit(get_html, (2))</span><br><span class="line">print(task1.done())</span><br><span class="line">#取消线程执行，状态done无论为true和false都不能取消执行。只有还没提交到线程池中的线程才能提交，与max_workers的设置有关</span><br><span class="line">print(task2.cancel(2))</span><br><span class="line">time.sleep(3.1)</span><br><span class="line">#done()查看该线程当前的执行状态</span><br><span class="line">print(task1.done())</span><br><span class="line">#result()获取该线程的返回结果</span><br><span class="line">print(task1.result())</span><br><span class="line"></span><br><span class="line">#as_completed获取已经成功的task的返回，如爬虫</span><br><span class="line">urls = [2,3,4,2]</span><br><span class="line">all_task = [executor.submit(get_html, (url)) for url in urls]</span><br><span class="line">for future in as_completed(all_task):</span><br><span class="line">    data = future.result()</span><br><span class="line">    print(&apos;get &#123;&#125; page success&apos;.format(data))</span><br><span class="line"></span><br><span class="line">#使用executor的map方法对as_completed进行简化.map的返回结果就是future.result()</span><br><span class="line">#map的返回顺序是按照list的顺序，并不是先执行完就返回</span><br><span class="line">for data in executor.map(get_html, urls):</span><br><span class="line">    print(&apos;get &#123;&#125; page success&apos;.format(data))</span><br><span class="line">#wait设置阻塞，参数可选择条件默认为ALL_COMPLETED</span><br><span class="line">wait(all_task, return_when=FIRST_COMPLETED)</span><br><span class="line">print(&apos;main&apos;)</span><br></pre></td></tr></table></figure>

<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>线程由于有gil无法并发，python多线程无法利用多cpu。</p>
<p>耗cpu的操作，多核cpu，计算，图像，挖矿多进程优于多线程。<br>io操作进程切换代价高于线程。</p>
<p>进程数据完全隔离,无法使用共享全局变量</p>
<p>子进程完全拷贝Fork之后的父进程代码运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor,as_completed</span><br><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">def fib(n):</span><br><span class="line">    if n &lt;=2:</span><br><span class="line">        return 1</span><br><span class="line">    return fib(n-1)+fib(n-2)</span><br><span class="line"></span><br><span class="line"># 耗cpu的操作多进程比多线程速度快</span><br><span class="line">with ProcessPoolExecutor(3) as executor:  #win使用多进程必须在__name==&apos;__main__&apos;下运行</span><br><span class="line"># with ThreadPoolExecutor(3) as executor:</span><br><span class="line">    alltask = [executor.submit(fib, (num)) for num in range(25,40)]</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    for future in as_completed(alltask):</span><br><span class="line">        data = future.result()</span><br><span class="line">        print(&apos;exec result &#123;&#125;&apos;.format(data))</span><br><span class="line">    </span><br><span class="line">    print(&apos;last time is :&#123;&#125;&apos;.format(time.time() - start_time))</span><br><span class="line"></span><br><span class="line"># io操作多线程比多进程快</span><br><span class="line">def random_sleep(n):</span><br><span class="line">    time.sleep(n)</span><br><span class="line">    return n</span><br></pre></td></tr></table></figure>

<h4 id="更加底层的多进程包"><a href="#更加底层的多进程包" class="headerlink" title="更加底层的多进程包"></a>更加底层的多进程包</h4><p>学习底层，生产环境还是推荐conncurrent</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line">print(&apos;fank&apos;)</span><br><span class="line">if pid == 0:  #pid=0 child pro</span><br><span class="line">    print(&apos;child process &#123;&#125;. parent process &#123;&#125;&apos;.format(os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">    print(&apos;parent process &#123;&#125;&apos;.format(pid))</span><br><span class="line"></span><br><span class="line">time.sleep(2)</span><br><span class="line"></span><br><span class="line">def get_html(n):</span><br><span class="line">    time.sleep(n)</span><br><span class="line">    print(&apos;sub progress success&apos;)</span><br><span class="line">    return n</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    program = multiprocessing.Process(target=get_html, args=(2,))</span><br><span class="line">    program.start()</span><br><span class="line">    program.join()</span><br><span class="line">    print(program.pid) #比线程多个pid属性</span><br><span class="line">    print(&apos;main progress end&apos;)</span><br><span class="line"></span><br><span class="line">    #进程池</span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    result = pool.apply_async(get_html,args=(3,))</span><br><span class="line"></span><br><span class="line">    #等待所有任务完成</span><br><span class="line">    pool.close()  #关闭接受新的进程</span><br><span class="line">    pool.join()</span><br><span class="line">    print(result.get())</span><br><span class="line"></span><br><span class="line">    #imap  按顺序输出</span><br><span class="line">    for result in pool.imap(get_html, [1,5,3]):</span><br><span class="line">        print(&apos;&#123;&#125; sleep success&apos;.format(result))</span><br><span class="line"></span><br><span class="line">    #imapunordered  按执行速度输出</span><br><span class="line">    for result in pool.imap_unordered(get_html, [1,5,3]):</span><br><span class="line">        print(&apos;&#123;&#125; sleep success&apos;.format(result))</span><br></pre></td></tr></table></figure>

<h3 id="进程间的通讯"><a href="#进程间的通讯" class="headerlink" title="进程间的通讯"></a>进程间的通讯</h3><p>共享全局变量在多进程中不适用</p>
<p>mutiprocessing.queue用于进程间的通讯</p>
<p>进程池中的通讯有3个queue需要区分</p>
<ol>
<li>系统from queue import Queue不能用于通讯</li>
<li>from mutiprocessing import Queue 不能用在进程池通讯</li>
<li>from mutiprocessing import Manager().queue 用于进程池pool中的通讯</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from multiprocessing import Process, Queue, Manager, Pipe</span><br><span class="line"></span><br><span class="line">def producer(queue):</span><br><span class="line">    queue.put(&apos;a&apos;)</span><br><span class="line">    time.sleep(2)</span><br><span class="line"></span><br><span class="line">def consumer(queue):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    queue = Queue(10)   #使用multi的queue</span><br><span class="line">    my_producer = Process(target=producer, args=(queue,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(queue,))</span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br><span class="line"></span><br><span class="line">    #manage 用于进程池中的通讯</span><br><span class="line">    queue = Manager().queue(10)</span><br><span class="line"></span><br><span class="line">    # pipe 用于两个进程间的通讯</span><br><span class="line">    # 通过pipe实现进程通信,pipe只适用与两个进程</span><br><span class="line">    # 为什么不直接用queue？因为pipe的性能高于queue</span><br><span class="line">    receiver_pipe, send_pipe = Pipe()</span><br><span class="line">    my_producer = Process(target=producer, args=(send_pipe,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(receiver_pipe,))</span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br><span class="line"></span><br><span class="line">    # 数据同步，以manager dict为例</span><br><span class="line">    def add_data(p_dict, key, value):</span><br><span class="line">        p_dict[key] = value</span><br><span class="line">    process_dict = Manager().dict()</span><br><span class="line">    first_progress = Process(target=add_data, args(process_dict,&apos;f&apos;,25))</span><br><span class="line">    second_progress = Process(target=add_data, args(process_dict,&apos;f2&apos;,27))</span><br><span class="line">    first_progress.start()</span><br><span class="line">    second_progress.start()</span><br><span class="line">    first_progress.join()</span><br><span class="line">    second_progress.join()</span><br></pre></td></tr></table></figure>

<h3 id="协程-（有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）"><a href="#协程-（有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）" class="headerlink" title="协程 （有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）"></a>协程 （有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>指在一个时间段内，有几个程序在同一个cpu上运行，但任意时刻只有一个程序在cpu上运行</p>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>指任意时刻有多个程序运行在多个cpu上</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>指代码调用io操作时，必须等待io操作完成才返回的调用方式</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>指代码调用io操作时，不必等待io操作完成就返回的调用方式（future）</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>指调用函数时，当前线程会被挂起（等待）</p>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><p>调用函数时，当前线程不会被挂起，而是立即返回</p>
<p>C10k问题，1999年被提出的一个挑战。要求在一颗1GHz CPU,2G内存,1gbps带宽，让单台服务器同时为1万个客户提供ftp服务。<br>如果为每个用户开一个线程，作为低配服务器做不到</p>
<h4 id="unix下五种io模型"><a href="#unix下五种io模型" class="headerlink" title="unix下五种io模型"></a>unix下五种io模型</h4><p>阻塞式io，在等待io操作时，cpu是空闲的</p>
<p>非阻塞式io，做计算任务或者单向发送请求，不需要等待返回的任务</p>
<p>I/O复用，select,poll,epoll由操作系统提供。<br>select查看那些socket或文件句柄已经准备好了，select可以同时监听多个socket</p>
<p>信号驱动式I/O,操作系统发起的用的较少</p>
<p>异步I/O(POSIX的aio_系列函数)，<br>其实很多并发框架都是使用io多路复用，用aio不多,aio与io复用并没有很明显的提升，编码难度比io复用高很多。</p>
<h3 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select,poll,epoll"></a>select,poll,epoll</h3><p>他们都是io多路复用机制。io多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般为读写就绪），能够通知程序进行相应的读写操作。但select,poll,epoll本质上都是同步io，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步io则无需自己负责进行读写，异步io的实现会负责把数据从内核拷贝到用户空间。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select函数监视的文件描述分3类，分别是writefds、readfds和exceptfds。调用后select函数会阻塞，知道有描述符就绪（数据可读可写，或有except),或者超时（timeout指定等待时间，如果立即返回设定为null）,函数返回。当select函数返回后，可以通过遍历fdset,来找到就绪的描述符。<br>select目前几乎在所有平台上支持。缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在linux上一般为1024，虽然可以修改，但是会造成效率降低。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。<br>pollfd没有最大数量限制。select和poll一样需要遍历文件描述符来获取已经就绪的socket，随着描述符数量增长，其效率也会下降。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>win不支持，linux2.6内核中提出，是select和poll的增强版。epoll查询使用性能很高的红黑树。<br>1.epoll并不代表一定比select好，在并发高的情况下，连接活跃度不高，epoll比较好（网站）。<br>并发性不高，同时连接活跃，select比较好（比如游戏）。</p>
<p>通过非阻塞io实现http请求</p>
<h4 id="C10M问题"><a href="#C10M问题" class="headerlink" title="C10M问题"></a>C10M问题</h4><p>如何利用8核心cpu，64G内存，在10gbps的网网上保持1000万并发连接</p>
<h4 id="协程解决的问题"><a href="#协程解决的问题" class="headerlink" title="协程解决的问题"></a>协程解决的问题</h4><p>主要是解决回调编写难的问题。保持性能+代码编写容易</p>
<p>1.采用同步的方式编写异步的代码<br>2.使用单线程去切换任务：<br>    1. 线程是由操作系统切换的，单线程切换意味着需要程序员去调度任务<br>    2. 不在需要锁，并发性高，如果单线程内切换函数，性能高于线程切换，</p>
<p>#传统函数调用方式 A-B-C,一旦调用其他函数，函数只运行一次然后退出<br>#我们需要一个可以暂停的函数，并且可以在适当的时候恢复该函数继续执行<br>#协程  -&gt; 有多个入口的函数，可以暂停的函数，并且可以向暂停的地方传入值<br>生成器就是可以暂停的函数</p>
<h3 id="生成器进阶send-close-throw"><a href="#生成器进阶send-close-throw" class="headerlink" title="生成器进阶send,close,throw"></a>生成器进阶send,close,throw</h3><p>send</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def gen_func():</span><br><span class="line">    #这种写法1.可以产出值 2.可以接受值</span><br><span class="line">    html = yield &quot;http://www.baidu.com&quot;</span><br><span class="line">    print(html)</span><br><span class="line">    yield 2</span><br><span class="line">    yield 3</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line">#生成器不仅可以产生值，还可以接受值</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    #启动生成器的方式有2种，1.next() 2.send</span><br><span class="line">    print(next(gen))</span><br><span class="line">    #send默认包含了next</span><br><span class="line">    print(gen.send(&apos;fank&apos;))</span><br><span class="line">    print(next(gen))</span><br></pre></td></tr></table></figure>

<p>close</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def gen_func():</span><br><span class="line">    #这种写法1.可以产出值 2.可以接受值</span><br><span class="line">    try:</span><br><span class="line">        yield &quot;http://www.baidu.com&quot;</span><br><span class="line">    except GeneratorExit:</span><br><span class="line">        pass</span><br><span class="line">    yield 2</span><br><span class="line">    yield 3</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line">#生成器不仅可以产生值，还可以接受值</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    #启动生成器的方式有2种，1.next() 2.send</span><br><span class="line">    print(next(gen))</span><br><span class="line">    gen.close()</span><br><span class="line">    print(next(gen))</span><br><span class="line"></span><br><span class="line">    #GeneratorExit是继承BaseException</span><br></pre></td></tr></table></figure>

<p>throw</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def gen_func():</span><br><span class="line">    #这种写法1.可以产出值 2.可以接受值</span><br><span class="line">    try:</span><br><span class="line">        yield &quot;http://www.baidu.com&quot;</span><br><span class="line">    except GeneratorExit:</span><br><span class="line">        pass</span><br><span class="line">    yield 2</span><br><span class="line">    yield 3</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line">#生成器不仅可以产生值，还可以接受值</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    gen = gen_func()</span><br><span class="line">    #启动生成器的方式有2种，1.next() 2.send</span><br><span class="line">    print(next(gen))</span><br><span class="line">    gen.throw(Exception, &apos;download error&apos;) #没有向下执行，是当前yeild的异常</span><br></pre></td></tr></table></figure>

<h4 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h4><p>生成器实现协程是由程序员自己调度的，线程，进程由操作系统内核调度。协程是函数级别的</p>
<p>yield from是python3.3之后新加入的语法</p>
<p>python3.5之后的协程是原生协程，之前是利用生成器完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from itertools import chain</span><br><span class="line"></span><br><span class="line">my_list = [1,2,3]</span><br><span class="line">my_dict = &#123;</span><br><span class="line">    &apos;fank&apos;:&quot;fankcoder.com&quot;,</span><br><span class="line">    &apos;fank1&apos;:&quot;fankcoder1.com&quot;,</span><br><span class="line">    &apos;fank2&apos;:&quot;fankcoder2.com&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># yeild from 后面跟一个iterable</span><br><span class="line"># 但远不止这些，如果yeild from 跟生成器</span><br><span class="line">def my_chain(*args, **kwargs):</span><br><span class="line">    for item in args:</span><br><span class="line">        yield from item</span><br><span class="line">        # for each in item:</span><br><span class="line">        #     yield each</span><br><span class="line"></span><br><span class="line">for value in my_chain(my_list, my_dict, range(5,10)):</span><br><span class="line">    print(value)</span><br><span class="line"></span><br><span class="line">def g1(gen):</span><br><span class="line">    yield from gen</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    g = g1</span><br><span class="line">    g.send(None)</span><br><span class="line"></span><br><span class="line">#1. main调用生成器 2.g1委托生成器 3.gen子生成器</span><br><span class="line">#2. yield from 会在调用生成器和子生成器之间建立一个双向通道，</span><br><span class="line"># 两者可以互通，现在调用生成器可以直接发送close,throw到子生成器</span><br></pre></td></tr></table></figure>

<p>协程调度，事件循环+协程模式，协程是单线程模式.<br>编写时候凡是遇到耗io的操作，都用啥yield或yield from模式.<br>tornado是生成器生成的协程.</p>
<h4 id="async和await-原生协程"><a href="#async和await-原生协程" class="headerlink" title="async和await 原生协程"></a>async和await 原生协程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#python3.5以后为了将语义变得更加明确，就引入了async和await关键词来定义原生协程</span><br><span class="line"># async下不能再出现yield,同样await只能出现在async下</span><br><span class="line"># await 后面跟的函数必须是awaitable也就是加了async的函数</span><br><span class="line">import types</span><br><span class="line"></span><br><span class="line">async def downloader(url):</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line"># 另一种方法让函数变为awaitable，但是我没有试验成功。不过这种方法本来不推荐</span><br><span class="line">@types.coroutine</span><br><span class="line">def downloader2(url):</span><br><span class="line">    return &apos;fank2&apos;</span><br><span class="line"></span><br><span class="line">async def download_url(url):</span><br><span class="line">    # do something</span><br><span class="line">    # await对应生成器的yield from</span><br><span class="line">    html = await downloader2(url)</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    coro = download_url(&apos;http://www.google.com&apos;)</span><br><span class="line">    # next(coro)  原生协程不能这样调用</span><br><span class="line">    coro.send(None)</span><br></pre></td></tr></table></figure>

<h3 id="asyncio模块"><a href="#asyncio模块" class="headerlink" title="asyncio模块"></a>asyncio模块</h3><p>把它叫做异步Io库，并不叫协程库，这里包含了多线程，多进程，协程</p>
<ol>
<li>包含各种特定系统实现的模块化事件循环</li>
<li>传输和协议抽象</li>
<li>对tcp,udp,ssl,子进程，延时调用以及其他的具体支持</li>
<li>模仿Futures模块但适用于事件循环适用的Future类</li>
<li>基于yield from的协议和任务，可以让你用顺序的方式编写并发代码</li>
<li>必须使用一个将产生阻塞io的调用时，哟接口可以把这个事件转移到线程池</li>
<li>模仿threading模块中的同步原语，可以用在单线程内的协程之间</li>
</ol>
<p> asyncio 异步io并发编程 py3.4以后支持</p>
<p>事件循环</p>
<p>协程编码模式3个：1.事件循环 2.回调(驱动生成器) 3.epoll（io多路复用）</p>
<p>应用：tornado, gevent, twisted(scrapy, django channels)</p>
<p>ps: tornado不建议使用Pymysql,mysqlclient</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#事件循环+回调（驱动生成器）+epoll(IO多路复用)</span><br><span class="line">#asyncio是Python用于解决异步io的一整套解决方案</span><br><span class="line">#tornado,gevent,twisted(scrapy, dango channels(http2.0 websocket) 目前都是基于twisted)</span><br><span class="line">#tornado(实现了web服务器)，django+flask(uwsgi,gunicorn+nginx)</span><br><span class="line">#tornado可以直接部署，外加nginx</span><br><span class="line"></span><br><span class="line">#asyncio</span><br><span class="line">import asyncio</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">async def get_html(url):</span><br><span class="line">    print(&apos;start get html&apos;)</span><br><span class="line">    #time.sleep()  #不能使用同步阻塞的方法</span><br><span class="line">    await asyncio.sleep(2)  #耗时操作，io操作加await</span><br><span class="line">    print(&apos;end get url&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop  = asyncio.get_event_loop()  #事件循环，自动select</span><br><span class="line">    tasks = [get_html(&apos;http://www.google.com&apos;) for i in range(10)]</span><br><span class="line">    # loop.run_until_complete(get_html(&apos;http://www.google.com&apos;))</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(&apos;time:&apos;, time.time() - start_time)</span><br><span class="line"></span><br><span class="line">#获取协程的返回值</span><br><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line">async def get_html(url):</span><br><span class="line">    print(&apos;start get html&apos;)</span><br><span class="line">    #time.sleep()  #不能使用同步阻塞的方法</span><br><span class="line">    await asyncio.sleep(2)  #耗时操作，io操作加await</span><br><span class="line">    return &apos;fank&apos;</span><br><span class="line"></span><br><span class="line">def callback(url, future): #partial url 要写在前面</span><br><span class="line">    print(url)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop  = asyncio.get_event_loop()  #事件循环，自动select</span><br><span class="line">    # get_future = asyncio.ensure_future(get_html(&apos;http://www.google.com&apos;))  #一个线程只有一个loop，这里ensure_future自动帮我们获取loop</span><br><span class="line">    task = loop.create_task(get_html(&apos;http://www.google.com&apos;))  #和上一句等效</span><br><span class="line">    # loop.run_until_complete(get_html(&apos;http://www.google.com&apos;))</span><br><span class="line">    # task.add_done_callback(callback)</span><br><span class="line">    #如过callback需要传参</span><br><span class="line">    task.add_done_callback(partial(callback, &apos;http://www.googl.com&apos;))</span><br><span class="line"></span><br><span class="line">    # loop.run_until_complete(get_future)</span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    # print(get_future.result())</span><br><span class="line">    print(&apos;time:&apos;, time.time() - start_time)</span><br><span class="line"></span><br><span class="line">#wait 和gather的用法和区别</span><br><span class="line">#gather更加高层，可以分组</span><br><span class="line">async def get_html(url):</span><br><span class="line">    print(&apos;start get html&apos;)</span><br><span class="line">    #time.sleep()  #不能使用同步阻塞的方法</span><br><span class="line">    await asyncio.sleep(2)  #耗时操作，io操作加await</span><br><span class="line">    print(&apos;end get url&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    loop  = asyncio.get_event_loop()  #事件循环，自动select</span><br><span class="line">    group1 = [get_html(&apos;http://www.google.com&apos;) for i in range(10)]</span><br><span class="line">    group2 = [get_html(&apos;http://www.google.com&apos;) for i in range(10)]</span><br><span class="line">    # loop.run_until_complete(get_html(&apos;http://www.google.com&apos;))</span><br><span class="line">    group2.cancel() #批量取消</span><br><span class="line">    loop.run_until_complete(asyncio.gather(*group1, *group2))</span><br><span class="line">    print(&apos;time:&apos;, time.time() - start_time)</span><br></pre></td></tr></table></figure>

<h4 id="取消task"><a href="#取消task" class="headerlink" title="取消task"></a>取消task</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># run_until_complete</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line"># loop = asyncio.get_event_loop()</span><br><span class="line"># loop.run_forever()  #不会停止，会一直运行</span><br><span class="line"># loop.run_until_complete()  #运行了指定的协程之后会停止</span><br><span class="line"></span><br><span class="line">async def get_html(sleep_times):</span><br><span class="line">    print(&apos;waiting&apos;)</span><br><span class="line">    await asyncio.sleep(sleep_times)</span><br><span class="line">    print(&apos;done after &#123;&#125;&apos;.format(sleep_times))</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    task1 = get_html(2)</span><br><span class="line">    task2 = get_html(3)</span><br><span class="line">    task3 = get_html(3)</span><br><span class="line"></span><br><span class="line">    tasks = [task1, task2, task3]</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    except KeyboardInterrupt as e:</span><br><span class="line">        all_tasks = asyncio.Task.all_tasks()</span><br><span class="line">        for task in all_tasks:</span><br><span class="line">            print(&apos;cancel task&apos;)</span><br><span class="line">            print(task.cancel())</span><br><span class="line">        loop.stop()</span><br><span class="line">        loop.run_forever()  #很关键，不加会报错</span><br><span class="line">    finally:</span><br><span class="line">        loop.close()</span><br></pre></td></tr></table></figure>

<h4 id="底层方法call-soon-call-later-call-at"><a href="#底层方法call-soon-call-later-call-at" class="headerlink" title="底层方法call_soon,call_later,call_at"></a>底层方法call_soon,call_later,call_at</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">#可以给asyncio直接传递函数（不是async函数）</span><br><span class="line">def callback(sleep_time):</span><br><span class="line">    print(&apos;sleep &#123;&#125; success&apos;.format(sleep_time))</span><br><span class="line"></span><br><span class="line">def stoploop(loop):</span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.call_soon(callback, 2)  #即刻执行，在队列里等到下一个循环立马执行</span><br><span class="line">    loop.call_soon(stoploop, loop)</span><br><span class="line"></span><br><span class="line">    loop.call_later(2,callback,2)  #在2秒钟之后运行callback</span><br><span class="line">    loop.call_later(1,callback,1)</span><br><span class="line">    loop.call_later(3,callback,3)</span><br><span class="line"></span><br><span class="line">    now = loop.time()  #loop的time</span><br><span class="line">    loop.call_at(now+2, callback, 2)</span><br><span class="line">    loop.call_at(now+3, callback, 3)</span><br><span class="line"></span><br><span class="line">    loop.call_soon_threadsafe()  #变量线程安全</span><br><span class="line"></span><br><span class="line">    loop.run_forever()</span><br></pre></td></tr></table></figure>

<h4 id="asyncio-ThreadPollExecutor"><a href="#asyncio-ThreadPollExecutor" class="headerlink" title="asyncio+ThreadPollExecutor"></a>asyncio+ThreadPollExecutor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#使用多线程:在协程中继承阻塞io(某些库就是阻塞的)</span><br><span class="line">import asyncio</span><br><span class="line">import socket</span><br><span class="line">from urllib.parse import urlparse</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">def get_url(url):</span><br><span class="line">    # get html by socket</span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    if path == &apos;&apos;:</span><br><span class="line">        path = &apos;/&apos;</span><br><span class="line">    </span><br><span class="line">    #connect socket</span><br><span class="line">    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    client.connect((host, 80))</span><br><span class="line">    client.send(&quot;GET &#123;&#125; HTTP/1.1\r\nHOST:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode(&apos;utf8&apos;))</span><br><span class="line">    </span><br><span class="line">    data = b&apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        d = client.recv(1024)</span><br><span class="line">        if d:</span><br><span class="line">            data += d</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    data = data.decode(&apos;utf8&apos;)</span><br><span class="line">    htmldata = data.split(&apos;\r\n\r\n&apos;)[1]</span><br><span class="line">    print(htmldata)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    executor = ThreadPoolExecutor(3)</span><br><span class="line">    tasks = []</span><br><span class="line">    for i in range(20):</span><br><span class="line">        #参数1.线程池 2.函数名 3.函数参数</span><br><span class="line">       task = loop.run_in_executor(executor, get_url, &apos;http://www.baidu.com/&#123;&#125;&apos;.format(i))  #将某个阻塞Io函数放入executor中运行</span><br><span class="line">       tasks.append(task)</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>

<h4 id="同步的方式实现异步http模拟请"><a href="#同步的方式实现异步http模拟请" class="headerlink" title="同步的方式实现异步http模拟请"></a>同步的方式实现异步http模拟请</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#asyncio没有提供http协议的接口；aiohttp异步的requests，可以启动服务器，可以爬虫</span><br><span class="line">#同步的方式实现异步http模拟请求</span><br><span class="line">import asyncio</span><br><span class="line">import socket</span><br><span class="line">from urllib.parse import urlparse</span><br><span class="line"></span><br><span class="line">async def get_url(url):</span><br><span class="line">    # get html by socket</span><br><span class="line">    url = urlparse(url)</span><br><span class="line">    host = url.netloc</span><br><span class="line">    path = url.path</span><br><span class="line">    if path == &apos;&apos;:</span><br><span class="line">        path = &apos;/&apos;</span><br><span class="line">    </span><br><span class="line">    #connect socket</span><br><span class="line">    reader, writer = await asyncio.open_connection(host, 80)  #线程</span><br><span class="line">    writer.write(&quot;GET &#123;&#125; HTTP/1.1\r\nHOST:&#123;&#125;\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode(&apos;utf8&apos;))</span><br><span class="line">    </span><br><span class="line">    all_lines = []</span><br><span class="line">    async for raw_line in reader:  #异步化，因为内部有yield from语法</span><br><span class="line">        data = raw_line.decode(&apos;utf8&apos;)</span><br><span class="line">        all_lines.append(data)</span><br><span class="line"></span><br><span class="line">    html = &apos;\n&apos;.join(all_lines)</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = []</span><br><span class="line">    for i in range(20):</span><br><span class="line">        url = &apos;http://www.baidu.com/&#123;&#125;&apos;.format(i)</span><br><span class="line">        tasks.append(asyncio.ensure_future(get_url(url)))</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    for task in tasks:</span><br><span class="line">        print(task.result()</span><br></pre></td></tr></table></figure>

<h4 id="asyncio同步和通信"><a href="#asyncio同步和通信" class="headerlink" title="asyncio同步和通信"></a>asyncio同步和通信</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">from asyncio import Lock,Queue</span><br><span class="line">queue = Queue()</span><br><span class="line">await queue.get()</span><br><span class="line">queue1 = [] #普通的全局变量也能用，但是不能控制Size流量</span><br><span class="line"></span><br><span class="line">cache = &#123;&#125;</span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line">async def get_stuff(url):</span><br><span class="line">    async with lock:</span><br><span class="line">        # await lock.acquire()  #async </span><br><span class="line">        if url in cache:</span><br><span class="line">            return cache[url]</span><br><span class="line">        stuff = await aiohttp.request(&apos;get&apos;, url)</span><br><span class="line">        cache[url] = stuff</span><br><span class="line">        return stuff</span><br><span class="line">        # lock.release()  #不需要await</span><br><span class="line"></span><br><span class="line">async def parse_stuff():</span><br><span class="line">    stuff = await get_stuff()</span><br><span class="line"></span><br><span class="line">async def use_stuff():</span><br><span class="line">    stuff = await get_stuff()</span><br></pre></td></tr></table></figure>

<h3 id="aiohttp实现高并发爬虫"><a href="#aiohttp实现高并发爬虫" class="headerlink" title="aiohttp实现高并发爬虫"></a>aiohttp实现高并发爬虫</h3><h4 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h4><p>HTTP client/server framework for asyncio</p>
<p>server可以搭建http服务器</p>
<h3 id="client爬虫"><a href="#client爬虫" class="headerlink" title="client爬虫"></a>client爬虫</h3><p>爬取Url<br>抽取内部Url<br>过滤<br>反爬<br>分布式</p>
<h4 id="sanic"><a href="#sanic" class="headerlink" title="sanic"></a>sanic</h4><p>号称可以媲美go性能的高并发web服务器</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/python-thread/" rel="tag"><i class="fa fa-tag"></i> python,thread</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/02/19/technology-2016-01-11-encode-python/" rel="next" title="Python转码问题">
                  <i class="fa fa-chevron-left"></i> Python转码问题
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/02/19/technology-2016-01-25-amazon-spider-python/" rel="prev" title="爬虫防屏蔽">
                  爬虫防屏蔽 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
    
  <div class="comments" id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程-amp-进程"><span class="nav-number">1.</span> <span class="nav-text">线程&amp;进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#通过thread类实例化"><span class="nav-number">1.1.</span> <span class="nav-text">通过thread类实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承thread来实现多线程"><span class="nav-number">1.2.</span> <span class="nav-text">继承thread来实现多线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程之间的通信方式"><span class="nav-number">2.</span> <span class="nav-text">线程之间的通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-共享全局变量-list-（多线程可以，多进程不行）"><span class="nav-number">2.1.</span> <span class="nav-text">1.共享全局变量(list)（多线程可以，多进程不行）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-通过queue方法进行线程间通讯-queue本身是线程安全的"><span class="nav-number">2.2.</span> <span class="nav-text">2.通过queue方法进行线程间通讯,queue本身是线程安全的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程同步（lock-rlock）"><span class="nav-number">3.</span> <span class="nav-text">线程同步（lock, rlock）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rlock可重入的锁"><span class="nav-number">3.1.</span> <span class="nav-text">rlock可重入的锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#condition条件变量"><span class="nav-number">4.</span> <span class="nav-text">condition条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore-控制线程并发数量"><span class="nav-number">5.</span> <span class="nav-text">Semaphore 控制线程并发数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池concurrent-py3-2"><span class="nav-number">6.</span> <span class="nav-text">线程池concurrent #py3.2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多进程"><span class="nav-number">7.</span> <span class="nav-text">多进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#更加底层的多进程包"><span class="nav-number">7.1.</span> <span class="nav-text">更加底层的多进程包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间的通讯"><span class="nav-number">8.</span> <span class="nav-text">进程间的通讯</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程-（有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）"><span class="nav-number">9.</span> <span class="nav-text">协程 （有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#并发"><span class="nav-number">9.1.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行"><span class="nav-number">9.2.</span> <span class="nav-text">并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步"><span class="nav-number">9.3.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步"><span class="nav-number">9.4.</span> <span class="nav-text">异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞"><span class="nav-number">9.5.</span> <span class="nav-text">阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非阻塞"><span class="nav-number">9.6.</span> <span class="nav-text">非阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unix下五种io模型"><span class="nav-number">9.7.</span> <span class="nav-text">unix下五种io模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-poll-epoll"><span class="nav-number">10.</span> <span class="nav-text">select,poll,epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#select"><span class="nav-number">10.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poll"><span class="nav-number">10.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll"><span class="nav-number">10.3.</span> <span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C10M问题"><span class="nav-number">10.4.</span> <span class="nav-text">C10M问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协程解决的问题"><span class="nav-number">10.5.</span> <span class="nav-text">协程解决的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器进阶send-close-throw"><span class="nav-number">11.</span> <span class="nav-text">生成器进阶send,close,throw</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#yield-from"><span class="nav-number">11.1.</span> <span class="nav-text">yield from</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#async和await-原生协程"><span class="nav-number">11.2.</span> <span class="nav-text">async和await 原生协程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asyncio模块"><span class="nav-number">12.</span> <span class="nav-text">asyncio模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#取消task"><span class="nav-number">12.1.</span> <span class="nav-text">取消task</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#底层方法call-soon-call-later-call-at"><span class="nav-number">12.2.</span> <span class="nav-text">底层方法call_soon,call_later,call_at</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#asyncio-ThreadPollExecutor"><span class="nav-number">12.3.</span> <span class="nav-text">asyncio+ThreadPollExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步的方式实现异步http模拟请"><span class="nav-number">12.4.</span> <span class="nav-text">同步的方式实现异步http模拟请</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#asyncio同步和通信"><span class="nav-number">12.5.</span> <span class="nav-text">asyncio同步和通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aiohttp实现高并发爬虫"><span class="nav-number">13.</span> <span class="nav-text">aiohttp实现高并发爬虫</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#aiohttp"><span class="nav-number">13.1.</span> <span class="nav-text">aiohttp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#client爬虫"><span class="nav-number">14.</span> <span class="nav-text">client爬虫</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sanic"><span class="nav-number">14.1.</span> <span class="nav-text">sanic</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.jpg"
      alt="fankcoder">
  <p class="site-author-name" itemprop="name">fankcoder</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/fankcoder" title="GitHub &rarr; https://github.com/fankcoder" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:fankcoder@gmail.com" title="E-Mail &rarr; mailto:fankcoder@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://weibo.com/u/2424646683" title="Weibo &rarr; https://weibo.com/u/2424646683" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://www.zhihu.com/people/si-xie-san-qiu/activities" title="Zhihu &rarr; https://www.zhihu.com/people/si-xie-san-qiu/activities" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>Zhihu</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://space.bilibili.com/38307214" title="Bilibili &rarr; https://space.bilibili.com/38307214" rel="noopener" target="_blank"><i class="fa fa-fw fa-tv"></i>Bilibili</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://steamcommunity.com/id/fankcoder" title="Steam &rarr; https://steamcommunity.com/id/fankcoder" rel="noopener" target="_blank"><i class="fa fa-fw fa-steam"></i>Steam</a>
      </span>
    
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://coolshell.cn/" title="https://coolshell.cn/" rel="noopener" target="_blank">coolshell</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="http://www.lining0806.com" title="http://www.lining0806.com" rel="noopener" target="_blank">lining0806</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fankcoder</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.4.1</div>

        












        
      </div>
    </footer>
  </div>

  
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>



  








  <script>
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','msMtA93nEGFTkf4tckPn','2.0.0');
</script>















  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/disqusjs@1/dist/disqusjs.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/disqusjs@1/dist/disqus.js', () => {
    window.dsqjs = new DisqusJS({
      api: '' || 'https://disqus.com/api/',
      apikey: 'ccFXs3SHC1xt1w3C801oWR1tIHF3IYsLNsbB6breN2uRt2bE1usUPCVbiH1PRRnT',
      shortname: 'fankcoder',
      url: "http://fankcoder.com/2019/02/19/technology-2019-01-12-threading-python/",
      identifier: "2019/02/19/technology-2019-01-12-threading-python/",
      title: 'Python线程&进程&协程&asyncio',
    });
  }, window.DisqusJS);
</script>

</body>
</html>
