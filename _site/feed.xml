<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fank</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 27 Apr 2019 13:41:21 +0800</pubDate>
    <lastBuildDate>Sat, 27 Apr 2019 13:41:21 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Docker 常用</title>
        <description>&lt;h2 id=&quot;基础类&quot;&gt;基础类&lt;/h2&gt;
&lt;h3 id=&quot;查看docker信息&quot;&gt;查看docker信息&lt;/h3&gt;
&lt;h3 id=&quot;-查看docker版本&quot;&gt;# 查看docker版本&lt;/h3&gt;
&lt;p&gt;docker version&lt;/p&gt;
&lt;h4 id=&quot;显示docker系统的信息&quot;&gt;显示docker系统的信息&lt;/h4&gt;
&lt;p&gt;docker info&lt;/p&gt;
&lt;h4 id=&quot;日志信息&quot;&gt;日志信息&lt;/h4&gt;
&lt;p&gt;docker logs&lt;/p&gt;
&lt;h4 id=&quot;故障检查&quot;&gt;故障检查&lt;/h4&gt;
&lt;p&gt;service docker status&lt;/p&gt;
&lt;h4 id=&quot;启动关闭docker&quot;&gt;启动关闭docker&lt;/h4&gt;
&lt;p&gt;sudo service docker start|stop&lt;/p&gt;

&lt;h2 id=&quot;查看容器信息&quot;&gt;查看容器信息&lt;/h2&gt;
&lt;h4 id=&quot;查看当前运行的容器&quot;&gt;查看当前运行的容器&lt;/h4&gt;
&lt;p&gt;docker ps&lt;/p&gt;
&lt;h4 id=&quot;查看全部容器&quot;&gt;查看全部容器&lt;/h4&gt;
&lt;p&gt;docker ps -a&lt;/p&gt;
&lt;h4 id=&quot;查看全部容器的id和信息&quot;&gt;查看全部容器的id和信息&lt;/h4&gt;
&lt;p&gt;docker ps -a -q&lt;/p&gt;
&lt;h4 id=&quot;查看全部容器占用的空间&quot;&gt;查看全部容器占用的空间&lt;/h4&gt;
&lt;p&gt;docker ps -as&lt;/p&gt;
&lt;h4 id=&quot;查看一个正在运行容器进程支持-ps-命令参数&quot;&gt;查看一个正在运行容器进程，支持 ps 命令参数&lt;/h4&gt;
&lt;p&gt;docker top&lt;/p&gt;

&lt;h2 id=&quot;启动停止容器等操作&quot;&gt;启动停止容器等操作&lt;/h2&gt;
&lt;p&gt;docker start|stop|restart [id]&lt;/p&gt;
&lt;h4 id=&quot;暂停恢复-某一容器的所有进程&quot;&gt;暂停|恢复 某一容器的所有进程&lt;/h4&gt;
&lt;p&gt;docker pause|unpause [id]&lt;/p&gt;
&lt;h4 id=&quot;杀死一个或多个指定容器进程&quot;&gt;杀死一个或多个指定容器进程&lt;/h4&gt;
&lt;p&gt;docker kill -s KILL [id]&lt;/p&gt;
&lt;h4 id=&quot;停止全部运行的容器&quot;&gt;停止全部运行的容器&lt;/h4&gt;
&lt;p&gt;docker stop &lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps -q&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;杀掉全部运行的容器&quot;&gt;杀掉全部运行的容器&lt;/h4&gt;
&lt;p&gt;docker kill -s KILL &lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps -q&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;交互式进入容器&quot;&gt;交互式进入容器&lt;/h2&gt;
&lt;p&gt;sudo docker exec -it  bash&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%A4%87%E5%BF%98/2019/04/04/general-docker.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%A4%87%E5%BF%98/2019/04/04/general-docker.html</guid>
        
        <category>docker</category>
        
        
        <category>备忘</category>
        
      </item>
    
      <item>
        <title>第N次折腾vps科学上网，解决方案笔记</title>
        <description>&lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;
&lt;h2 id=&quot;过去&quot;&gt;过去&lt;/h2&gt;
&lt;p&gt;记得第一打开谷歌，是在初中的某一天，和当时的我熟悉的百度比较，除了它的Logo比较新颖之外，印象最深的就是这个网站，与国内所有的搜索引擎不同，它不能在线听歌，那时候正是国内盗版软件光盘盛行的时候，关心音乐的版权更是极少的。&lt;/p&gt;

&lt;h2 id=&quot;后来&quot;&gt;后来&lt;/h2&gt;
&lt;p&gt;有一天在大学机房做实验，老师闲聊说谷歌以后不能访问了，我听过也没太在意，因为在我意识中互联网世界就是同一个虚拟世界，可惜从那以后对我来说它就不再是了。之后的事大家都知道了，百度虚假广告越来越多，在当时我有很长一段时间都觉得，使用搜索引擎是一件极其痛苦的事，每当我在百度查找需要的东西，我大概需要过滤掉80%无用的信息，其中30%是广告，30%是色情信息，20%是无关信息。于是我将系统hosts替换，重新使用起了谷歌。&lt;/p&gt;

&lt;h2 id=&quot;再后来&quot;&gt;再后来&lt;/h2&gt;
&lt;p&gt;替换hosts这个方法我大概使用了2，3年之久（首先因为免费，其次它比某些收费vpn访问速度还快，缺点是不能看youtube视频）
这时候我已经是一名谷歌重度使用者了。
在2015年7月10号，那段时间hosts经常不稳定，找到了一篇用vps搭建ss的教程，在搬瓦工购入了一台vps，从此开始了vps搭建ss的折腾之旅&lt;/p&gt;

&lt;h1 id=&quot;目前的完美折腾方案&quot;&gt;目前的完美折腾方案&lt;/h1&gt;
&lt;p&gt;由于我的vps购入比较早，19.9$/Y（现在应该买不到了）它还是古老的OVZ架构，虽然便宜，但很遗憾它不能享用bbr加速方案。
我尝试切换过几个机房，洛杉矶的速度不错，可以在youtube看1080p的视频。&lt;/p&gt;

&lt;h3 id=&quot;已一台刚装好的centos65为例&quot;&gt;已一台刚装好的centOS6.5为例&lt;/h3&gt;

&lt;p&gt;安装git&amp;amp;ss&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt install git
pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置ss&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim /etc/shadowdowsocks.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;配置ss例子，端口写不常用的，并且的越随意越好，记得不要超过65535&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{                                  
    &quot;server&quot;:&quot;my_server_ip&quot;,          //服务器的IP地址
    &quot;server_port&quot;:7711,              //服务器的端口，
    &quot;local_address&quot;: &quot;127.0.0.1&quot;,       //本机IP地址
    &quot;local_port&quot;:1080,               //本机端口
    &quot;password&quot;:&quot;mypassword&quot;,        //自己设定的密码
    &quot;timeout&quot;:600,                  //超出时间
    &quot;method&quot;:&quot;chacha20-ietf&quot;,          //加密方法，推荐使用&quot;chacha20-ietf&quot;算法需要额外安装
    &quot;fast_open&quot;: false                //true 或 false}
}

# 若是多用户模式，将server_port和password合并为port_password：
&quot;port_password&quot;: {
         &quot;443&quot;: &quot; mypassword 1”,  //对应端口设定不同的密码
         &quot;8888&quot;: &quot; mypassword 2”
     },
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装gevent，如果使用Python2，高版本的gevent可能会安装失败，官方推荐1.1版本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ yum install -y libevent
$ pip install greenlet
$ pip install gevent==1.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;强烈使用推荐的chacha20-ietf算法。安装新算法需要先安装libsodium&lt;/p&gt;

&lt;p&gt;直接安装or编译安装随心情&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install epel-release
yum install libsodium
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum -y groupinstall &quot;Development Tools&quot;
wget https://github.com/jedisct1/libsodium/releases/download/1.0.15/libsodium-1.0.15.tar.gz
tar xf libsodium-1.0.15.tar.gz &amp;amp;&amp;amp; cd libsodium-1.0.15
./configure &amp;amp;&amp;amp; make -j2 &amp;amp;&amp;amp; make install
echo /usr/local/lib &amp;gt; /etc/ld.so.conf.d/usr_local_lib.conf
ldconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;启动ss服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssserver -c /etc/shadowsocks.json
# 若想让ss一直在后台运行，可运行：
nohup ssserver -c /etc/shadowsocks.json &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;客户端&lt;/p&gt;

&lt;p&gt;macos: ShadowsocksX-NG&lt;/p&gt;

&lt;p&gt;win: https://shadowsocks.org/en/download/clients.html&lt;/p&gt;

&lt;p&gt;android: 可以先从pc下个apk传到手机（或者免费vpn有很多临时用下不错）再用gg play更新/下载&lt;/p&gt;

&lt;p&gt;ios:wingy&lt;/p&gt;

&lt;h2 id=&quot;kcptun&quot;&gt;kcptun&lt;/h2&gt;

&lt;h4 id=&quot;参考文档&quot;&gt;参考文档&lt;/h4&gt;
&lt;p&gt;https://github.com/easonhuang123/blog/issues/1&lt;/p&gt;

&lt;p&gt;https://github.com/shadowsocksrr/shadowsocks-rss/wiki/libsodium&lt;/p&gt;

&lt;p&gt;下面是一篇升级glibc的文章，我的确升级成功了，但是bbr还是用不了，放弃了
https://cnodejs.org/topic/56dc21f1502596633dc2c3dc&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/04/02/ss_config.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/04/02/ss_config.html</guid>
        
        <category>ss</category>
        
        <category>google</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>vscode配置手册</title>
        <description>&lt;h2 id=&quot;vs-code&quot;&gt;VS Code&lt;/h2&gt;

&lt;h3 id=&quot;plugin&quot;&gt;Plugin&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim
atom dark theme
al code outline
python
django
sql server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;vim-插件不能响应长按的解决&quot;&gt;vim 插件不能响应长按的解决&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false # For VS Code

defaults write com.microsoft.VSCodeInsiders ApplePressAndHoldEnabled -bool false # For VS Code Insider
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用tab键切换提示&quot;&gt;使用tab键切换提示&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[{

&quot;key&quot;: &quot;tab&quot;,

&quot;command&quot;: &quot;-acceptSelectedSuggestion&quot;,

&quot;when&quot;: &quot;suggestWidgetVisible &amp;amp;&amp;amp; textInputFocus&quot;

},

{

&quot;key&quot;: &quot;tab&quot;,

&quot;command&quot;: &quot;selectNextSuggestion&quot;,

&quot;when&quot;: &quot;suggestWidgetMultipleSuggestions &amp;amp;&amp;amp; suggestWidgetVisible &amp;amp;&amp;amp; textInputFocus&quot;

}

]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 08 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/03/08/vscode.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/03/08/vscode.html</guid>
        
        <category>vscode</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>mac使用手册</title>
        <description>&lt;h2 id=&quot;iterm2&quot;&gt;iterm2&lt;/h2&gt;

&lt;h3 id=&quot;分屏&quot;&gt;分屏&lt;/h3&gt;

&lt;p&gt;快捷键“cmd+d”左右分屏，快捷键“^+cmd+d”上下分屏&lt;/p&gt;

&lt;p&gt;cmd+[ / ] 左右切换分屏 cmd+opt(alt)+上下左右切换分屏&lt;/p&gt;

&lt;h3 id=&quot;粘贴板&quot;&gt;粘贴板&lt;/h3&gt;

&lt;p&gt;调出复制过的文本历史 快捷键：“^+cmd+h”&lt;/p&gt;

&lt;h3 id=&quot;回放&quot;&gt;回放&lt;/h3&gt;

&lt;p&gt;按键回放 cmd+alt+b&lt;/p&gt;

&lt;h2 id=&quot;homebrew&quot;&gt;homebrew&lt;/h2&gt;

&lt;h2 id=&quot;git&quot;&gt;Git&lt;/h2&gt;

&lt;h2 id=&quot;oh-my-zsh&quot;&gt;oh my zsh&lt;/h2&gt;

&lt;h3 id=&quot;spaceship-theme&quot;&gt;spaceship theme&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/denysdovhan/spaceship-prompt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;meslo-font&quot;&gt;meslo font&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;fzf&quot;&gt;fzf&lt;/h3&gt;

&lt;p&gt;模糊搜索&lt;/p&gt;

&lt;h3 id=&quot;zsh-syntax-highlighting&quot;&gt;zsh-syntax-highlighting&lt;/h3&gt;
&lt;p&gt;语法高亮&lt;/p&gt;

&lt;h3 id=&quot;autojump&quot;&gt;autojump&lt;/h3&gt;

&lt;p&gt;快速跳转目录&lt;/p&gt;

&lt;h3 id=&quot;zsh个性化配置&quot;&gt;zsh个性化配置&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ZSH_THEME=&quot;spaceship&quot;
plugins=(robbyrussell git zsh-syntax-highlighting autojump)
 [[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;amp;&amp;amp; . $(brew --prefix)/etc/profile.d/autojump.sh
export GEM_HOME=$HOME/gems
export PATH=$HOME/gems/bin:$PATH
alias py3=&quot;source /Users/fank/code/py3.7/bin/activate&quot;
export PROMPT_COMMAND='echo -ne &quot;\033]0;$PWD\007&quot;'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;快捷键启动iterm2方案&quot;&gt;快捷键启动iterm2方案&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 编写mac启动脚本
2. alt+space 搜索iterm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;dash&quot;&gt;dash&lt;/h3&gt;
&lt;p&gt;文档查询工具&lt;/p&gt;

&lt;h3 id=&quot;sequel-pro&quot;&gt;Sequel pro&lt;/h3&gt;

&lt;h3 id=&quot;charles&quot;&gt;Charles&lt;/h3&gt;

&lt;h3 id=&quot;nomechine&quot;&gt;NoMechine&lt;/h3&gt;

&lt;p&gt;远程工具&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/03/08/mac-tools.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/03/08/mac-tools.html</guid>
        
        <category>mac,</category>
        
        <category>osx</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>Python深入学习笔记</title>
        <description>&lt;h3 id=&quot;collections&quot;&gt;collections&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections import *

from collections.abc import * #抽象基类
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;tuple功能&quot;&gt;tuple功能&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;不可变(不绝对)&lt;/li&gt;
  &lt;li&gt;iterable&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#拆包，方便找到对应关系
_tuple = ('fank', 26, 182)
name, age, height = _tuple
#name = _tuple[0] 不好的写法

#拆包加强
name, *other = _tuple
print(name, other)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;tuple比list好的地方&quot;&gt;tuple比list好的地方&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;immutable的重要性&lt;/li&gt;
  &lt;li&gt;性能优化，不可变对象在编译时作为常量，产生显著的速度差异&lt;/li&gt;
  &lt;li&gt;线程安全&lt;/li&gt;
  &lt;li&gt;可以作为dict的key&lt;/li&gt;
  &lt;li&gt;拆包特性&lt;/li&gt;
  &lt;li&gt;如果拿C来类比，tuple对应struct, 而list对应array&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;namedtuple&quot;&gt;namedtuple&lt;/h4&gt;
&lt;p&gt;可以生成类，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;User = namedtuple(&quot;User&quot;,['name','age'])
user = User(name='fank', age='27')
print（user.name, user.age）

_make()使用tuple初始化，_asdict()使用dict初始化
t = ('fank', 27)
user = User._make(t)
d = {'name':'fank','age':27}
user = User._asdict(d)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;节省空间，用于数据处理，从数据库取数据为tuple，直接赋值&lt;/p&gt;

&lt;h4 id=&quot;def-askargs-kwargs&quot;&gt;def ask(*args, **kwargs)&lt;/h4&gt;

&lt;p&gt;*args是个tuple, **kwargs是个dict&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def test(*args, **kwargs):
    print(*args)
    print(**kwargs)

test('f',25)
test({'name':'f','age':25}

# ask('f',25) 传给*args, ask(name='f', age=25)传给**kwargs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;deque双端队列&quot;&gt;deque双端队列&lt;/h4&gt;

&lt;p&gt;应用场景queue是由deque来完成的。deque是线程安全到，list不是线程安全的，由GIL保护。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections import deque
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;copy是浅拷贝，如果值为list会相互影响&lt;/p&gt;

&lt;h4 id=&quot;counter&quot;&gt;counter&lt;/h4&gt;

&lt;p&gt;统计&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections import Counter
users = ['fank','fank1','fank1','fank2','fank','fank3']
user_counter = Counter(users)
print(user_counter)
#Counter({'fank':2,'fank1':2,'fank3':1})

#追加统计
user_counter.update()
#前n个出现最多的,使用堆实现(完全二叉树)
user_counter.most_common(n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;defaultdict&quot;&gt;defaultdict&lt;/h4&gt;
&lt;p&gt;from collections import defaultdict C语言实现，性能高,比setdefault更强大&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;default_dict = defaultdict(int) #参数是一个可调用对象list,int,func..

default_dict['key'] #key=0 ,初始化成功后，直接访问不会报错，会默认生成

def gen_func():
    return {'fank':123,'code':321}
default_dict = defaultdict(gen_func) #生成默认值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;orderdict是有序的&quot;&gt;OrderDict是有序的&lt;/h4&gt;

&lt;p&gt;dict的子类，按照添加顺序排序。list+dict
py3的dict默认是有序的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_d = OrderedDict()
_d.popitem()  #不需要传key
_d.move_to_end()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;chainmap&quot;&gt;ChainMap&lt;/h4&gt;

&lt;p&gt;方便操作多个dict. 将dict连结,key相同只有一个。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections import ChainMap

new_dict = ChainMap(_d1, _d2)
new_dict.new_child({'name':'fank'})

new_dict.maps  #maps属性，以列表形式全部打印，同样可以修改
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;inspect&quot;&gt;inspect&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import inspect
inspect.getfile(obj)
inspect.getsource(obj)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;typeobject和class的关系&quot;&gt;type,object和class的关系&lt;/h3&gt;

&lt;p&gt;type(int) -&amp;gt; class type -&amp;gt; obj&lt;/p&gt;

&lt;p&gt;type -&amp;gt; int -&amp;gt; 1&lt;/p&gt;

&lt;p&gt;type生成类对象，类对象生成实例对象&lt;/p&gt;

&lt;p&gt;int.&lt;strong&gt;bases&lt;/strong&gt; class ‘object’&lt;/p&gt;

&lt;p&gt;基类均为class object, object是最顶层基类。&lt;/p&gt;

&lt;p&gt;type.&lt;strong&gt;bases&lt;/strong&gt; class ‘object’ type继承obj&lt;/p&gt;

&lt;p&gt;type(object) class ’type’ obj是type的实例, 形成环路&lt;/p&gt;

&lt;p&gt;object.&lt;strong&gt;bases&lt;/strong&gt; None&lt;/p&gt;

&lt;h3 id=&quot;内置类型&quot;&gt;内置类型&lt;/h3&gt;

&lt;p&gt;对象3个特征:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;身份id(a)&lt;/li&gt;
  &lt;li&gt;2.类型type&lt;/li&gt;
  &lt;li&gt;3.值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;None全局唯一&lt;/p&gt;

&lt;p&gt;数值int, float,complex复数,bool&lt;/p&gt;

&lt;p&gt;迭代类型&lt;/p&gt;

&lt;p&gt;序列类型 list,bytes,range,tuple,str,array&lt;/p&gt;

&lt;p&gt;映射类型 dict&lt;/p&gt;

&lt;p&gt;集合 set , frozenset&lt;/p&gt;

&lt;p&gt;上下文管理器 with&lt;/p&gt;

&lt;p&gt;其他 模块from import,class,object,type&lt;/p&gt;

&lt;h3 id=&quot;魔法函数&quot;&gt;魔法函数&lt;/h3&gt;

&lt;p&gt;以双下划线开头，双下划线结尾。可以定制类的特性&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;iter&lt;/strong&gt;,__getitem__实现了都是可迭代的&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;getitem&lt;/strong&gt;(self, item):&lt;/p&gt;

&lt;p&gt;return self._list[item]&lt;/p&gt;

&lt;p&gt;拆包，给长度数量的变量给他们赋值&lt;/p&gt;

&lt;h3 id=&quot;鸭子类型和多态&quot;&gt;鸭子类型和多态&lt;/h3&gt;
&lt;p&gt;当一只鸟，走路，游泳，叫起来都像鸭子，那么这只鸟就可以被叫做鸭子
都实现了同一种方法，所以可以归为一类，不需要继承，只需要实现同方法，就可以实现多态&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Cat(object):
    def say(self):
        print(‘im a cat’)

class Dog(object):
    def say(self):
        print(‘im a dog’)


animal = Cat
animal().say()

animal_list = [Cat, Dog]
for animal in animal_list:
    animal().say()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;抽象基类abc模块&quot;&gt;抽象基类abc模块&lt;/h3&gt;
&lt;p&gt;检查某个类是否有某种方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Company(object):
    def __init__(self, employee_list):
        self.employee = employee_list

    def __len__(self):
        return len(self.employee)

com = Company([‘bob1’,’bob2’])
print(hasattr(com, ‘__len__’) #检验类是否具有该方法
# print(len(com))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;抽象基类abc模块-1&quot;&gt;抽象基类abc模块&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections.abc import Sized
isinstance(com, Sized) # 判断类型
import abc

class CacheBase(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def get(self, key):
        pass

    @abc.abstractmethod
    def set(self, key, value):
        pass

class RedisCache(CacheBase):
    pass

redis_cache = REdisCache()  
#会报错。
#abstractmethod要求被继承的类，必须实现父类的方法，否则会报错
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;判断继承用isinstance()不要用type()&lt;/p&gt;

&lt;h4 id=&quot;类变量和实例变量&quot;&gt;类变量和实例变量&lt;/h4&gt;
&lt;p&gt;类中的self是类的实例&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class A:
    aa = 1 #类变量
    def __init__(self, x, y):
        self.x = x
        self.y = y  #实例变量
a = A(2,3)
A.aa = 11 #修改类变量
a.aa = 100 #新建变量
print(a.x, a.y, a.aa)
print(A.a)
print(A.x) #error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;self是类的实例，类变量和类实例变量的区别&lt;/p&gt;

&lt;p&gt;__mro__查找。DFS深度优先，对菱形继承有问题，BFS广度优先也有覆盖问题，py3用C3算法&lt;/p&gt;

&lt;p&gt;@staticmethod静态方法，传参和普通函数一样，&lt;strong&gt;不需要写self参数&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Data:
    @staticmethod
    def parse_from_string(date_str):
        year, month, day = tuple(date_str)
        return Date(year, month, day)  #静态方法硬编码，返回值必须与类名相同
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;@classmethod类方法，第一参数是类本身cls，返回值不需要与类同名&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @classmethod
    def from_string(cls, date_str):  #cls传递的是类本身，不是实例
        year, month, day = tuple(date_str)
        return cls(year, month, day)  #写为cls,变为动态不必与类名相同
#cls是习惯性写法，在这里甚至可以写为self
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;类的私有属性&quot;&gt;类的私有属性&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self.__birthday双下划线开头，但并不绝对安全，_User__birthday依然可以访问到
class User:
    def __init__(self):
        self.__birthday = birthday  #无法被访问
    def get_age(self):
        return 2019 - self.__birthday.year
    def __get_other(self):  #私有方法
        pass
user = User(Date(1992,9,28))
user._User__birthday  #py帮助我们使用这种简单方式封装，找到规律就可以访问
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;自省机制&quot;&gt;自省机制&lt;/h3&gt;
&lt;p&gt;自省是通过一定的机构查询到对象的内部结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Person:
    name = ‘user’

clss Student(Person):
    def __init__(self, school_name):
        self.school_name = ‘'
user = Student(‘abc’)
print(user.__dict__)  #打印实例属性，{’school_name’:abc}.c优化的魔法函数
print(Person.__dict__) #类属性
user.__dict__[’school_addr’] = ‘efg’  #甚至可以赋值
dir(user)  #更详细，功能更强
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;super&quot;&gt;super&lt;/h3&gt;
&lt;p&gt;获取父类init (其实是mro顺序的类，查看方法classname.&lt;strong&gt;mro&lt;/strong&gt;)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class A:
    def __init__(self):
        print(‘a’)

class B(A):
    def __init__(self):
        print(‘b’)
        super(b, self).__init__() # py2
        super().__init__() # py3

b = B()

from threading import Thread
class MyThread(Thread):
    def __init__(self, name, user):
        self.user = user
        super().__init__(name=name)  #重用父类代码
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;mixin模式&quot;&gt;mixin模式&lt;/h3&gt;
&lt;p&gt;多继承不推荐，mixin代替多继承
特点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Mixin类功能单一&lt;/li&gt;
  &lt;li&gt;不和基类关联，可以和任意基类组合&lt;/li&gt;
  &lt;li&gt;在mixin中不要使用supper&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;with上下文管理器&quot;&gt;with上下文管理器&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try:
    raise KeyError
except KeyError as e:
    print('e')
else:
    print('else') #当try正确运行时&amp;amp;except没有捕获到异常打印
finally:
    print('f') #始终运行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;with语句是为了简化try..finally诞生的&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Sample:
    def __enter__(self):
        #获取资源
        print('enter')
        return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        #释放资源
        print('exit')
    def do_something(self):
        print('do smt')

with Sample() as sample:
    sample.do_something() 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个类实现了上下文管理器协议，此协议非常好用。
with是对上下文管理器的支持。&lt;/p&gt;

&lt;h3 id=&quot;contextlib简化上下文管理器&quot;&gt;contextlib简化上下文管理器&lt;/h3&gt;
&lt;p&gt;进一步简化&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import contextlib

@contextlib.contextmanager
def file_open(file_name):
    print('file open')  # __enter__的位置
    yield {}
    print('file end')  # __exit__的位置
    
with file_open('text') as f:
    pass

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;类和对象&quot;&gt;类和对象&lt;/h3&gt;

&lt;p&gt;type() object&lt;/p&gt;

&lt;p&gt;魔法函数&lt;/p&gt;

&lt;p&gt;hasattr(param,”&lt;strong&gt;len&lt;/strong&gt;”) 判断是否有这个函数，用isinstance()更好&lt;/p&gt;

&lt;p&gt;希望用户继承时必须实现方法&lt;/p&gt;

&lt;p&gt;class CacheBase():&lt;/p&gt;

&lt;p&gt;def get(self, key):raise NotImplementedError&lt;/p&gt;

&lt;p&gt;def set(self, key, value):pass&lt;/p&gt;

&lt;h3 id=&quot;is-和-&quot;&gt;is 和 ==&lt;/h3&gt;

&lt;p&gt;is判断id是否相同&lt;/p&gt;

&lt;p&gt;==判断值&lt;/p&gt;

&lt;p&gt;isinstance 和type，判断类的类型尽量用isinstance&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [46]: a = 1
In [47]: b = 1
In [48]: a is b
Out[48]: True

In [49]: a = [1,2,3]
In [50]: b = [1,2,3]
In [51]: a is b
Out[51]: False

In [72]: a = &quot;hello world&quot;
In [73]: b = &quot;hello world&quot;
In [74]: a is b
Out[74]: False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;自定义序列类&quot;&gt;自定义序列类&lt;/h3&gt;

&lt;p&gt;容器序列，扁平序列，可变序列sequence，不可变序列mutable&lt;/p&gt;

&lt;p&gt;python面向协议编程 in可以作用于list&lt;/p&gt;

&lt;h3 id=&quot;extend&quot;&gt;+,+=,extend&lt;/h3&gt;
&lt;p&gt;+=（&lt;strong&gt;iadd&lt;/strong&gt;）的参数可以是序列，+必须两边同类型
a.extend(range(0,3)) #直接对值修改，不需要再赋值，参考apped
a.append([1,2])  #[1,2,[1,2]]注意和extend的区别&lt;/p&gt;

&lt;p&gt;参数可以为任意序列，通过for循环append&lt;/p&gt;

&lt;p&gt;切片[start : end : step]，默认值可省略[0,len(L),1].&lt;/p&gt;

&lt;p&gt;实现支持切片操作的类&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Group:
    def __init__(self, group_name, company_name, staffs):
        self.group_name = group_name
        self.company_name = company_name
        self.staffs = staffs
    
    def __reversed__(self):
        self.staffs.reversed()  #这种方式实现不了
        for each in self.staffs[::-1]:
            yield each
        
    # def __getitem__(self, item):
    #     return self.staff[item] #返回对象为list或单个元素
    import numbers
    def __getitem__(self, item):  #返回类对象
        cls = type(self)
        if isinstance(item, slice):
            return cls(group_name=self.group_name, company_name=self.company_name, staffs=self.staffs[item])
        elif isinstance(item, numbers.Interal):
            return cls(group_name=self.group_name, company_name=self.company_name, [staffs=self.staffs[item]])
    
    def __len__(self):
        return len(self.staffs)
        
    def __iter__(self):
        return iter(self.staffs)
    
    def __contains__(self, item):
        if item in self.staffs:
            return True
        else:
            return False
        
staffs = ['a', 'b', 'c']
group = Group(group_name='gname', company_name='cname', staff=staffs)
group[:2]
for user in group:
    print(user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;bisect二分查找&quot;&gt;bisect二分查找&lt;/h3&gt;
&lt;p&gt;bisect处理已排序序列，二分查找。插入排序好的数列，升序bisect.insort(list, 5).
二分法查找位置，插入位置bisect.bisect(list, 3)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import bisect

l = []
bisect.insort(4)
bisect.insort(1)
bisect.insort(3)
bisect.insort(2)
print(l) #[1,2,3,4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;arrary和list重要区别，array只能存放指定的数据类型。布隆过滤器。
arrary是c中的数组，一串连续的内存块，性能高。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import array
_a = array.array('i') # int,参数查看文档
_a.append()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;列表推导式生成式生成器表达式&quot;&gt;列表推导式（生成式）&amp;amp;生成器表达式&lt;/h3&gt;
&lt;p&gt;通过一行代码生成列表。&lt;/p&gt;

&lt;p&gt;列表生成式性能能高于列表操作&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;odd_list = [i for i in range(21) if i%2 == 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;复杂情况的列表生成式，可以使用函数实现.（过于复杂就放弃吧，代码可读性更重要）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def sqrt(item):
    return item*item
odd_list = [sqrt(i) for i in range(21) if i%2 == 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;生成器表达式为小括号，type变为generator&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;odd_list = (i for i in range(21) if i%2 == 1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;字典推导式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my_dict ={'a':1, 'b':2}
_reversed = {value:key for key, value in my_dict.items()} # 交换value,key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;集合推导式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my_set = {key for key,value in my_dict.items()}
type(my_set)  # set
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;深入set和dict&quot;&gt;深入set和dict&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a.copy() #浅拷贝

import copy 

copy.deepcopy(a) #深拷贝
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;浅拷贝就是创建一个具有相同类型，相同值但不同id的新对象。
深拷贝不仅仅拷贝了原始对象自身，也对其包含的值进行拷贝，它会递归的查找对象中包含的其他对象的引用，来完成更深层次拷贝。因此，深拷贝产生的副本可以随意修改而不需要担心会引起原始值的改变。&lt;/p&gt;

&lt;h4 id=&quot;dict的formkeys方法&quot;&gt;dict的formkeys方法&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;l = ['a', 'b']
d = dict.fromkeys(l, {'c','d'})
print(d) #{'a': {'c', 'd'}, 'b': {'c', 'd'}}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;get方法&quot;&gt;get方法&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_d['key']  #key不存在会抛异常
_dict.get(&quot;a&quot;, {}) #get方法非常实用！{}为默认值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;items&quot;&gt;items&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for key, value in _d.items()：
    print(k,v)   #烂大街的好方法
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;setdefault-增加get方法&quot;&gt;setdefault 增加get方法&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;setdefault(key, default)
# 1.先调用get()
# 2.没有则默认值
# 3.再把默认值设置进dict
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;update&quot;&gt;update&lt;/h4&gt;
&lt;p&gt;合并字典&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_dict.update({'c':1})
_dict.update(&quot;a&quot;=1,&quot;b&quot;=2) #放iterm都可以
_dict.update(（（’e‘,'f'），）) #传入tuple
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;dict子类&quot;&gt;dict子类&lt;/h3&gt;
&lt;p&gt;写类不建议继承list和dict
某些时候c不会使用覆盖的方法，而是会用dict本身的方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections import UserDict 
#推荐使用UserDict被python重写过
class Mydict(UserDict):
    def __setitem__(self, key, value):
        super().__setitem__(key, value*2)

from collections import defaultdict

# 如果找不到key,就赋值
my_dict = defaultdict(dict())
my_value = my_dict['fank'] #这里我的py3.7.1报错了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;set-fronzenset&quot;&gt;set fronzenset&lt;/h3&gt;

&lt;p&gt;set和fronzenset(不可变)无序，不重复，在去重时用的很多，并且fronzenset是不可变类型，所以可以做为dict的key&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s = set('abcd')
s1 = {'a', 'b'} #type是set
s2 = frozenset('abcde') #无法add值，
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;set-difference&quot;&gt;set difference&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s = {'a','b','c'}
ans = set('cef')
rs = s.difference(ans)
print(rs) # {'a','b'}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;dict和set实现原理&quot;&gt;dict和set实现原理&lt;/h4&gt;

&lt;p&gt;dict 查哈希表，key必须为可哈希的值。str,fset,tuple,自己实现的类&lt;/p&gt;

&lt;p&gt;dict的内存花销大，查询速度快&lt;/p&gt;

&lt;p&gt;垃圾回收算法是采用引用计数 del&lt;/p&gt;

&lt;h3 id=&quot;property&quot;&gt;property&lt;/h3&gt;

&lt;p&gt;property动态属性，User.age可以取属性，不用调函数，类似get，set为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class User:
    def __init__(self, birthday):
        self.birthday = birthday
        self._age = 0
    @propery  #装饰器。讲age变为属性描述符,直接调用
    def age(self):
        return datetime.now().year - self.birthday.year
    @age.setter  #设置
    def age(self, value):
        self._age = value
    
user = User(year='1992')
user.age
user.age = 26  #属性赋值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;__getattr__与__getattribute__的区别&quot;&gt;__getattr__与__getattribute__的区别&lt;/h3&gt;

&lt;p&gt;__getattr__在查找不到属性的时候调用(写了就不会报错).维护dict动态访问key&lt;/p&gt;

&lt;p&gt;def &lt;strong&gt;getattr&lt;/strong&gt;(self, item): return “not find”&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from datetime import date
class User:
    def __init__(self, name,info={}):
        self.name = name
        self.info = info
        
    def __getattr__(self, item):
        return self.info[item]
user = User('fank', info={'a':1})
user.a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;def &lt;strong&gt;getattribute&lt;/strong&gt;(self, item): return “true” 
优先级别高，无条件进入这个函数，它控制全局属性访问&lt;/p&gt;

&lt;h3 id=&quot;属性描述符&quot;&gt;属性描述符&lt;/h3&gt;
&lt;p&gt;在赋值的时候检查属性
实现了__get__,&lt;strong&gt;set&lt;/strong&gt;,__delete__三个中的任意一个的类都是属性描述符&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class IntField:
    def __get__(self, instance):
        return self.value
    def __set__(self, instance,value):
        if isinstance(value, numbers.Interagral):
            raise ValueError('int value need')
        self.value = value
    def __delete__(self, instance):
        pass

class User:
    age = Intfield()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;数据描述符都实现
非数据描述符只实现__get__&lt;/p&gt;

&lt;p&gt;属性查找过程&lt;/p&gt;

&lt;p&gt;传递方法为变化的user.age方式无法实现， 使用getattr(user, age)&lt;/p&gt;

&lt;h3 id=&quot;__new__和__init__区别&quot;&gt;__new__和__init__区别&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class User:
    def __new__(cls, *args, **kwargs): #写框架使用很频繁
        pass
        return super().__new__(cls)
    def __init__(self, name):
        self.name = name
user = User('fank')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;new传递类cls，在init之前，new控制对象的生成过程.
如果new不返回对象，不会调用init函数&lt;/p&gt;

&lt;p&gt;type是默认元类，metaclass是自定义元类，可以控制实例化过程&lt;/p&gt;

&lt;h3 id=&quot;元类编程&quot;&gt;元类编程&lt;/h3&gt;
&lt;p&gt;类也是对象，type是用来创建类的类&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def create_class(name):
    if name == &quot;user&quot;:
        class User:
            def __str__(self):
                return 'user'
        return User
    elif name == &quot;company&quot;:
        class Company:
            def __str__(self):
                return 'Company'
        return Company

#type是可以创建类的。动态创建类
User = type(&quot;User&quot;, (), {&quot;name&quot;:&quot;user&quot;})  #第二个参数继承基类必写
u = User()
print(u.name)

#如何给type写方法
def say(self):
    retun &quot;i am user&quot;
User = type(&quot;User&quot;, (), {&quot;name&quot;:&quot;user&quot;, &quot;say&quot;:say}) 
u = User()
print(u.say)
#继承
User = type(&quot;User&quot;, (Baseclass,), {&quot;name&quot;:&quot;user&quot;, &quot;say&quot;:say})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;元类是创建类的类， 对象&amp;lt;-class&amp;lt;-type&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MetaClass(type):
    def __new__(self, *args, **kwargs):
        return super().__new__(cls, *args, **kwargs) #带*参数必传否则会报错

class User(metaclass=MetaClass):  #当不写metaclass会默认调用type创建类对象
    pass
#python类的实例化过程中，会首先寻找metaclass,通过metaclass创建类，控制实例化过程
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;迭代器和生成器&quot;&gt;迭代器和生成器&lt;/h3&gt;

&lt;p&gt;迭代器是访问集合内元素的一种方式，一般用来遍历数据。&lt;/p&gt;

&lt;p&gt;可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。&lt;/p&gt;

&lt;p&gt;可以使用isinstance()判断一个对象是否是Iterator对象。&lt;/p&gt;

&lt;p&gt;生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。&lt;/p&gt;

&lt;p&gt;python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。&lt;/p&gt;

&lt;p&gt;把list、dict、str等Iterable变成Iterator可以使用iter()函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(iter([]), Iterator)
True
&amp;gt;&amp;gt;&amp;gt; isinstance(iter('abc'), Iterator)
True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;next(itor)接受迭代器，迭代器next无法切片。文件太大使用迭代器读数据&lt;/p&gt;

&lt;p&gt;__iter__迭代协议，可迭代的实现方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections.abc import Iterable,Iterator

iter([_list]) #将list变为迭代器

def __iter__(self) / def __getitem__(self, item)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;生成器函数，函数内有yield关键字&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def gen_func(): 
    yield 1 yield2 yield3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;python在编译时字节码发现yield于是变为生成器
python查看字节码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import dis
print(dis.dis(func))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;gen = gen_func() #gen生成器对象，不是值&lt;/p&gt;

&lt;p&gt;for i in gen: print(i) 惰性求值提供了可能，比list好处是省内存&lt;/p&gt;

&lt;p&gt;生成器读取大文件&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#数据在文件中只有1行
f = open()
f.read(4096) #一次读取的大小，偏移量

def myreadlines(f, newline):
    buf = &quot;&quot;
    while True:
        while newline in buf:
            pos = buf.index(newline)
            yield buf[:pos]
            buf = buf[pos + len(newline):]
        chunk = f.read(4096)
        
        if not chunk:
            yield buf
            break
        buf += chunk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;socket编程&quot;&gt;socket编程&lt;/h3&gt;
&lt;p&gt;服务端socket&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;bind(协议，地址，端口）&lt;/li&gt;
  &lt;li&gt;listen(监听客户端socket请求）&lt;/li&gt;
  &lt;li&gt;accept()&lt;/li&gt;
  &lt;li&gt;阻塞等待连接请求（新套接字）&lt;/li&gt;
  &lt;li&gt;recv()&lt;/li&gt;
  &lt;li&gt;send()&lt;/li&gt;
  &lt;li&gt;close()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;客户端socket&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;connect() 三次握手 -&amp;gt; 等待套接字&lt;/li&gt;
  &lt;li&gt;send() -&amp;gt; recv() server #接受bytes类型需要编码&lt;/li&gt;
  &lt;li&gt;recv() -&amp;gt; send() server
4.close()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;爬虫是典型的客户端socket
如果使得服务端可以多用户连接？
将每个socket做为线程&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import socket

server = socket.socket()

server.bind(('0.0.0.0', 8000))

server.listen()

sock, addr = server.accept()

data = server.recv(1024) #1kb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;socketHttp
reqeusts -&amp;gt; urlib -&amp;gt; socket&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import socket
from urllib.parse import urlparse

def get_url(url):
    # get html by socket
    url = urlparse(url)
    host = url.netloc
    path = url.path
    if path == '':
        path = '/'
        
    #connect socket
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.connect((host, 80))
    client.send(&quot;GET {} HTTP/1.1\r\nHOST:{}\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode('utf8'))
    
    data = b''
    while True:
        d = client.recv(1024)
        if d:
            data += d
        else:
            break
    data = data.decode('utf8')
    htmldata = data.split('\r\n\r\n')[1]
    print(htmldata)

if __name__ == '__main__':
    get_url('http://www.baidu.com')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;线程进程&quot;&gt;线程&amp;amp;进程&lt;/h3&gt;

&lt;p&gt;GIL global interpreter lock GIL全局解释锁&lt;/p&gt;

&lt;p&gt;python中一个线程对应于c中的线程&lt;/p&gt;

&lt;p&gt;python是先将py文件编译为字节码&lt;/p&gt;

&lt;p&gt;gil使得同一时刻只有一个线程在一个cpu上执行字节码，无法将多个线程映射到多个cpu上&lt;/p&gt;

&lt;p&gt;为了安全，但速度慢，无法体现多核优势。pypy是去gil化的。gil在遇到io操作会主动释放&lt;/p&gt;

&lt;p&gt;操作系统调度的最小单元线程，对于io操作，多线程和多进程差别不大。&lt;/p&gt;

&lt;h4 id=&quot;通过thread类实例化&quot;&gt;通过thread类实例化&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;thread1 = threading.Thread(target=func, args=(&quot;&quot;,))

thread1.setDaemon(True)#设置为守护线程。当主线程关闭时，子线程被kill

thread1.join() #阻塞，等待thread1子线程执行完成
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;继承thread来实现多线程&quot;&gt;继承thread来实现多线程&lt;/h4&gt;
&lt;p&gt;当代码量大，逻辑复杂时，推荐通过继承thread来实现多线程&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class GetDetailHtml(threading.Thread):
    def __init__(self, name):   #为线程命名，好习惯
        super().__init__(name=name)
    
    def run(self):
        print('get detail html')
        time.sleep(2)
        print('get detail html done')

class GetTitleHtml(threading.Thread):
    def __init__(self, name):
        super().__init__(name=name)

    def run(self):
        print('get title url')
        time.sleep(2)
        print('get title url done')


if __name__ == '__main__':
    thread1 = GetTitleHtml('get title html')
    thread2 = GetDetailHtml('get detail html')
    start_time = time.time()
    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()
    print('last time {}'.format(time.time() - start_time))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;线程之间的通信方式&quot;&gt;线程之间的通信方式&lt;/h3&gt;

&lt;h4 id=&quot;1共享全局变量list多线程可以多进程不行&quot;&gt;1.共享全局变量(list)（多线程可以，多进程不行）&lt;/h4&gt;

&lt;p&gt;这种方法，线程并不安全，需要加gil锁，所以并不推荐用作通信&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time
import threading

#1.共享全局变量
detail_url_list = []

def get_title_html(detail_url_list):
    print('get title url')
    time.sleep(2)
    for i in range(20):
        detail_url_list.append('http://www.test.com/id/{}/'.format(i))
    print('get title url done')

def get_detail_html(detail_url_list):
    print('get detail html')
    time.sleep(2)
    if len(detail_url_list):
        url = detail_url_list.pop()
        print('get detail html done')

if __name__ == '__main__':
    thread1 = threading.Thread(target=get_title_html, args=(detail_url_list,))
    for i in range(10): #启动10个线程，太多线程操作系统切换会产生很大代价
        html_thread = threading.Thread(target=get_detail_html, args=(detail_url_list,))
        html_thread.start()
    start_time = time.time()
    thread1.start()
    thread1.join()
    print('last time {}'.format(time.time() - start_time))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2通过queue方法进行线程间通讯queue本身是线程安全的&quot;&gt;2.通过queue方法进行线程间通讯,queue本身是线程安全的&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from queue import Queue
import time
import threading

def get_title_html(queue):
    while True:
        print('get title url')
        time.sleep(2)
        for i in range(20):
            queue.put('http://www.test.com/id/{}/'.format(i))
        print('get title url done')

def get_detail_html(queue):
    while True:
        print('get detail html')
        time.sleep(2)
        url = queue.get()  #get方法是阻塞方法，如果queue为空就等待
        print('get detail html done')

if __name__ == '__main__':
    detail_queue = Queue(maxsize=1000)
    thread1 = threading.Thread(target=get_title_html, args=(detail_queue,))
    for i in range(10): #启动10个线程，太多线程操作系统切换会产生很大代价
        html_thread = threading.Thread(target=get_detail_html, args=(detail_queue,))
        html_thread.start()
    start_time = time.time()
    thread1.start()
    thread1.join()
    print('last time {}'.format(time.time() - start_time))


queue.get()#阻塞方法，如果为空就一直停顿等待
queue.put_nowait()#设置为非阻塞
queue.qsize() #获取长度，同样是线程安全的可以直接使用
queue.empty()
queue.full()
queue.join()#阻塞直到执行到task_done()
queue.task_done()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;.join()一直阻塞，想退出需要调用.task_down() #爬虫暂停&lt;/p&gt;

&lt;p&gt;如果共用变量为dict或其他非队列数据，也可以考虑使用全局变量&lt;/p&gt;

&lt;h3 id=&quot;线程同步lock-rlock&quot;&gt;线程同步（lock, rlock）&lt;/h3&gt;

&lt;p&gt;避免淘宝库存同时有人买
线程同步机制,lock锁，反正锁住的代码段都只能有一个在运行，释放之后才能让其他代码运行.&lt;/p&gt;

&lt;p&gt;使用锁会出现的问题&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;用锁会影响性能&lt;/li&gt;
  &lt;li&gt;锁会引起死锁（互相等待）,不能连续调用两次acquire&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from threading import Lock

lock = Lock()

global lock

lock.acquire() #获取

a += 1

lock.release() #释放
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;死锁情况&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A(a, b)
acquire(a)
acquire(b)

B(a, b)
acquire(b) # a,b同时等待
acquire(a)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;rlock可重入的锁&quot;&gt;rlock可重入的锁&lt;/h4&gt;
&lt;p&gt;解决lock，不能连续调用acquire的问题。它可以在同一个线程里面，可以连续调用多次acquire，需要相等数量的release.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from threading import RLock
lock = Rlock()

lock.acquire()
lock.acquire()
lock.release()
lock.release()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;condition条件变量&quot;&gt;condition条件变量&lt;/h3&gt;

&lt;p&gt;用于复杂的线程间同步锁&lt;/p&gt;

&lt;p&gt;wait()允许等待某个条件变量的通知
notify()会通知调用了wait()方法的那个线程启动&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用condition启动顺序非常重要&lt;/li&gt;
  &lt;li&gt;一定要先调用with方法或者acquire和release，之后再调用wait(),notify()&lt;/li&gt;
  &lt;li&gt;condition有两层锁，一把底层锁会在线程调用wait方法的时候释放，上面的锁会值每次调用wait时分配一把并放入到cond的等待队列中，等到notify方法唤醒&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import threading
from threading import Condition

class XiaAi(threading.Thread):
    def __init__(self, cond):
        super().__init__(name='小爱')
        self.cond = cond
    
    def run(self):
        with self.cond:
            self.cond.wait()
            print('{}: 在'.format(self.name))
            self.cond.notify()

            print('{}: 好啊'.format(self.name))
            self.cond.notify()
    
class TianMao(threading.Thread):
    def __init__(self, cond):
        super().__init__(name='天猫')
        self.cond = cond
    
    def run(self):
        with self.cond:
            print('{}: 小爱同学'.format(self.name))
            self.cond.notify()
            self.cond.wait()

            print('{}: 我们来对古诗吧'.format(self.name))
            self.cond.notify()
            self.cond.wait()

if __name__ == '__main__':
    cond = threading.Condition()

    xiaoai = XiaAi(cond)
    tianmao = TianMao(cond)

    xiaoai.start()
    tianmao.start()
    xiaoai.join()
    tianmao.join()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;semaphore-控制线程并发数量&quot;&gt;Semaphore 控制线程并发数量&lt;/h3&gt;

&lt;p&gt;#文件读写，写一般只用一个线程，读可以允许有多个线程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import threading
import time


class HtmlSpider(threading.Thread):
    def __init__(self, url, sem):
        super().__init__()
        self.url = url
        self.sem = sem
    
    def run(self):
        time.sleep(2)
        print('get html success')
        self.sem.release()

class UrlProducer(threading.Thread):
    def __init__(self, sem):
        super().__init__()
        self.sem = sem
    
    def run(self):
        for i in range(10):
            self.sem.acquire()
            html_thread = HtmlSpider('http://www.baidu.com/id/{}/'.format(i), self.sem)
            html_thread.start()

if __name__ == '__main__':
    sem = threading.Semaphore(3)
    url_thread = UrlProducer(sem)
    url_thread.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;线程池concurrent-py32&quot;&gt;线程池concurrent #py3.2&lt;/h3&gt;
&lt;p&gt;concurrent容易的编写多线程，多进程代码&lt;/p&gt;

&lt;p&gt;为什么使用线程池？&lt;/p&gt;

&lt;p&gt;1.主线程中可以获取某一个线程的状态或者某一个任务的状态，以及返回值&lt;/p&gt;

&lt;p&gt;2.当一个线程完成的时候，主线程能立即知道&lt;/p&gt;

&lt;p&gt;3.futures可以让多线程多进程编码接口一致&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from concurrent.futures import ThreadPoolExecutor,as_completed,wait,FIRST_COMPLETED
import time

def get_html(times):
    time.sleep(times)
    print('get html {} success'.format(times))
    return times

executor = ThreadPoolExecutor(max_workers=2)

#通过submit提交执行的函数到线程池中，submit是立即返回
task1 = executor.submit(get_html, (3))
task2 = executor.submit(get_html, (2))
print(task1.done())
#取消线程执行，状态done无论为true和false都不能取消执行。只有还没提交到线程池中的线程才能提交，与max_workers的设置有关
print(task2.cancel(2))
time.sleep(3.1)
#done()查看该线程当前的执行状态
print(task1.done())
#result()获取该线程的返回结果
print(task1.result())

#as_completed获取已经成功的task的返回，如爬虫
urls = [2,3,4,2]
all_task = [executor.submit(get_html, (url)) for url in urls]
for future in as_completed(all_task):
    data = future.result()
    print('get {} page success'.format(data))

#使用executor的map方法对as_completed进行简化.map的返回结果就是future.result()
#map的返回顺序是按照list的顺序，并不是先执行完就返回
for data in executor.map(get_html, urls):
    print('get {} page success'.format(data))
#wait设置阻塞，参数可选择条件默认为ALL_COMPLETED
wait(all_task, return_when=FIRST_COMPLETED)
print('main')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;多进程&quot;&gt;多进程&lt;/h3&gt;

&lt;p&gt;线程由于有gil无法并发，python多线程无法利用多cpu。&lt;/p&gt;

&lt;p&gt;耗cpu的操作，多核cpu，计算，图像，挖矿多进程优于多线程。
io操作进程切换代价高于线程。&lt;/p&gt;

&lt;p&gt;进程数据完全隔离,无法使用共享全局变量&lt;/p&gt;

&lt;p&gt;子进程完全拷贝Fork之后的父进程代码运行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time
from concurrent.futures import ThreadPoolExecutor,as_completed
from concurrent.futures import ProcessPoolExecutor

def fib(n):
    if n &amp;lt;=2:
        return 1
    return fib(n-1)+fib(n-2)

# 耗cpu的操作多进程比多线程速度快
with ProcessPoolExecutor(3) as executor:  #win使用多进程必须在__name=='__main__'下运行
# with ThreadPoolExecutor(3) as executor:
    alltask = [executor.submit(fib, (num)) for num in range(25,40)]
    start_time = time.time()
    for future in as_completed(alltask):
        data = future.result()
        print('exec result {}'.format(data))
    
    print('last time is :{}'.format(time.time() - start_time))

# io操作多线程比多进程快
def random_sleep(n):
    time.sleep(n)
    return n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;更加底层的多进程包&quot;&gt;更加底层的多进程包&lt;/h4&gt;
&lt;p&gt;学习底层，生产环境还是推荐conncurrent&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import os
import time
import multiprocessing

pid = os.fork()
print('fank')
if pid == 0:  #pid=0 child pro
    print('child process {}. parent process {}'.format(os.getpid(), os.getppid()))
else:
    print('parent process {}'.format(pid))

time.sleep(2)

def get_html(n):
    time.sleep(n)
    print('sub progress success')
    return n

if __name__ == '__main__':
    program = multiprocessing.Process(target=get_html, args=(2,))
    program.start()
    program.join()
    print(program.pid) #比线程多个pid属性
    print('main progress end')

    #进程池
    pool = multiprocessing.Pool(multiprocessing.cpu_count())
    result = pool.apply_async(get_html,args=(3,))

    #等待所有任务完成
    pool.close()  #关闭接受新的进程
    pool.join()
    print(result.get())

    #imap  按顺序输出
    for result in pool.imap(get_html, [1,5,3]):
        print('{} sleep success'.format(result))

    #imapunordered  按执行速度输出
    for result in pool.imap_unordered(get_html, [1,5,3]):
        print('{} sleep success'.format(result))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;进程间的通讯&quot;&gt;进程间的通讯&lt;/h3&gt;

&lt;p&gt;共享全局变量在多进程中不适用&lt;/p&gt;

&lt;p&gt;mutiprocessing.queue用于进程间的通讯&lt;/p&gt;

&lt;p&gt;进程池中的通讯有3个queue需要区分&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;系统from queue import Queue不能用于通讯&lt;/li&gt;
  &lt;li&gt;from mutiprocessing import Queue 不能用在进程池通讯&lt;/li&gt;
  &lt;li&gt;from mutiprocessing import Manager().queue 用于进程池pool中的通讯&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time
from multiprocessing import Process, Queue, Manager, Pipe

def producer(queue):
    queue.put('a')
    time.sleep(2)

def consumer(queue):
    time.sleep(2)
    data = queue.get()
    print(data)

if __name__ == '__main__':
    queue = Queue(10)   #使用multi的queue
    my_producer = Process(target=producer, args=(queue,))
    my_consumer = Process(target=consumer, args=(queue,))
    my_producer.start()
    my_consumer.start()
    my_producer.join()
    my_consumer.join()

    #manage 用于进程池中的通讯
    queue = Manager().queue(10)

    # pipe 用于两个进程间的通讯
    # 通过pipe实现进程通信,pipe只适用与两个进程
    # 为什么不直接用queue？因为pipe的性能高于queue
    receiver_pipe, send_pipe = Pipe()
    my_producer = Process(target=producer, args=(send_pipe,))
    my_consumer = Process(target=consumer, args=(receiver_pipe,))
    my_producer.start()
    my_consumer.start()
    my_producer.join()
    my_consumer.join()

    # 数据同步，以manager dict为例
    def add_data(p_dict, key, value):
        p_dict[key] = value
    process_dict = Manager().dict()
    first_progress = Process(target=add_data, args(process_dict,'f',25))
    second_progress = Process(target=add_data, args(process_dict,'f2',27))
    first_progress.start()
    second_progress.start()
    first_progress.join()
    second_progress.join()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;协程-有多个入口的函数可以暂停的函数可以向暂停的地方传值&quot;&gt;协程 （有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）&lt;/h3&gt;

&lt;h4 id=&quot;并发&quot;&gt;并发&lt;/h4&gt;
&lt;p&gt;指在一个时间段内，有几个程序在同一个cpu上运行，但任意时刻只有一个程序在cpu上运行&lt;/p&gt;

&lt;h4 id=&quot;并行&quot;&gt;并行&lt;/h4&gt;
&lt;p&gt;指任意时刻有多个程序运行在多个cpu上&lt;/p&gt;

&lt;h4 id=&quot;同步&quot;&gt;同步&lt;/h4&gt;
&lt;p&gt;指代码调用io操作时，必须等待io操作完成才返回的调用方式&lt;/p&gt;

&lt;h4 id=&quot;异步&quot;&gt;异步&lt;/h4&gt;
&lt;p&gt;指代码调用io操作时，不必等待io操作完成就返回的调用方式（future）&lt;/p&gt;

&lt;h4 id=&quot;阻塞&quot;&gt;阻塞&lt;/h4&gt;
&lt;p&gt;指调用函数时，当前线程会被挂起（等待）&lt;/p&gt;

&lt;h4 id=&quot;非阻塞&quot;&gt;非阻塞&lt;/h4&gt;
&lt;p&gt;调用函数时，当前线程不会被挂起，而是立即返回&lt;/p&gt;

&lt;p&gt;C10k问题，1999年被提出的一个挑战。要求在一颗1GHz CPU,2G内存,1gbps带宽，让单台服务器同时为1万个客户提供ftp服务。
如果为每个用户开一个线程，作为低配服务器做不到&lt;/p&gt;

&lt;h4 id=&quot;unix下五种io模型&quot;&gt;unix下五种io模型&lt;/h4&gt;
&lt;p&gt;阻塞式io，在等待io操作时，cpu是空闲的&lt;/p&gt;

&lt;p&gt;非阻塞式io，做计算任务或者单向发送请求，不需要等待返回的任务&lt;/p&gt;

&lt;p&gt;I/O复用，select,poll,epoll由操作系统提供。
select查看那些socket或文件句柄已经准备好了，select可以同时监听多个socket&lt;/p&gt;

&lt;p&gt;信号驱动式I/O,操作系统发起的用的较少&lt;/p&gt;

&lt;p&gt;异步I/O(POSIX的aio_系列函数)，
其实很多并发框架都是使用io多路复用，用aio不多,aio与io复用并没有很明显的提升，编码难度比io复用高很多。&lt;/p&gt;

&lt;h3 id=&quot;selectpollepoll&quot;&gt;select,poll,epoll&lt;/h3&gt;

&lt;p&gt;他们都是io多路复用机制。io多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般为读写就绪），能够通知程序进行相应的读写操作。但select,poll,epoll本质上都是同步io，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步io则无需自己负责进行读写，异步io的实现会负责把数据从内核拷贝到用户空间。&lt;/p&gt;

&lt;h4 id=&quot;select&quot;&gt;select&lt;/h4&gt;
&lt;p&gt;select函数监视的文件描述分3类，分别是writefds、readfds和exceptfds。调用后select函数会阻塞，知道有描述符就绪（数据可读可写，或有except),或者超时（timeout指定等待时间，如果立即返回设定为null）,函数返回。当select函数返回后，可以通过遍历fdset,来找到就绪的描述符。
select目前几乎在所有平台上支持。缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在linux上一般为1024，虽然可以修改，但是会造成效率降低。&lt;/p&gt;

&lt;h4 id=&quot;poll&quot;&gt;poll&lt;/h4&gt;
&lt;p&gt;不同与select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。
pollfd没有最大数量限制。select和poll一样需要遍历文件描述符来获取已经就绪的socket，随着描述符数量增长，其效率也会下降。&lt;/p&gt;

&lt;h4 id=&quot;epoll&quot;&gt;epoll&lt;/h4&gt;
&lt;p&gt;win不支持，linux2.6内核中提出，是select和poll的增强版。epoll查询使用性能很高的红黑树。
1.epoll并不代表一定比select好，在并发高的情况下，连接活跃度不高，epoll比较好（网站）。
并发性不高，同时连接活跃，select比较好（比如游戏）。&lt;/p&gt;

&lt;p&gt;通过非阻塞io实现http请求&lt;/p&gt;

&lt;h4 id=&quot;c10m问题&quot;&gt;C10M问题&lt;/h4&gt;
&lt;p&gt;如何利用8核心cpu，64G内存，在10gbps的网网上保持1000万并发连接&lt;/p&gt;

&lt;h4 id=&quot;协程解决的问题&quot;&gt;协程解决的问题&lt;/h4&gt;
&lt;p&gt;主要是解决回调编写难的问题。保持性能+代码编写容易&lt;/p&gt;

&lt;p&gt;1.采用同步的方式编写异步的代码
2.使用单线程去切换任务：
    1. 线程是由操作系统切换的，单线程切换意味着需要程序员去调度任务
    2. 不在需要锁，并发性高，如果单线程内切换函数，性能高于线程切换，&lt;/p&gt;

&lt;p&gt;#传统函数调用方式 A-B-C,一旦调用其他函数，函数只运行一次然后退出
#我们需要一个可以暂停的函数，并且可以在适当的时候恢复该函数继续执行
#协程  -&amp;gt; 有多个入口的函数，可以暂停的函数，并且可以向暂停的地方传入值
生成器就是可以暂停的函数&lt;/p&gt;

&lt;h3 id=&quot;生成器进阶sendclosethrow&quot;&gt;生成器进阶send,close,throw&lt;/h3&gt;

&lt;p&gt;send&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def gen_func():
    #这种写法1.可以产出值 2.可以接受值
    html = yield &quot;http://www.baidu.com&quot;
    print(html)
    yield 2
    yield 3
    return 'fank'

#生成器不仅可以产生值，还可以接受值
if __name__ == '__main__':
    gen = gen_func()
    #启动生成器的方式有2种，1.next() 2.send
    print(next(gen))
    #send默认包含了next
    print(gen.send('fank'))
    print(next(gen))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;close&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def gen_func():
    #这种写法1.可以产出值 2.可以接受值
    try:
        yield &quot;http://www.baidu.com&quot;
    except GeneratorExit:
        pass
    yield 2
    yield 3
    return 'fank'

#生成器不仅可以产生值，还可以接受值
if __name__ == '__main__':
    gen = gen_func()
    #启动生成器的方式有2种，1.next() 2.send
    print(next(gen))
    gen.close()
    print(next(gen))

    #GeneratorExit是继承BaseException
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;throw&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def gen_func():
    #这种写法1.可以产出值 2.可以接受值
    try:
        yield &quot;http://www.baidu.com&quot;
    except GeneratorExit:
        pass
    yield 2
    yield 3
    return 'fank'

#生成器不仅可以产生值，还可以接受值
if __name__ == '__main__':
    gen = gen_func()
    #启动生成器的方式有2种，1.next() 2.send
    print(next(gen))
    gen.throw(Exception, 'download error') #没有向下执行，是当前yeild的异常
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;yield-from&quot;&gt;yield from&lt;/h4&gt;
&lt;p&gt;生成器实现协程是由程序员自己调度的，线程，进程由操作系统内核调度。协程是函数级别的&lt;/p&gt;

&lt;p&gt;yield from是python3.3之后新加入的语法&lt;/p&gt;

&lt;p&gt;python3.5之后的协程是原生协程，之前是利用生成器完成&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from itertools import chain

my_list = [1,2,3]
my_dict = {
    'fank':&quot;fankcoder.com&quot;,
    'fank1':&quot;fankcoder1.com&quot;,
    'fank2':&quot;fankcoder2.com&quot;
}

# yeild from 后面跟一个iterable
# 但远不止这些，如果yeild from 跟生成器
def my_chain(*args, **kwargs):
    for item in args:
        yield from item
        # for each in item:
        #     yield each

for value in my_chain(my_list, my_dict, range(5,10)):
    print(value)

def g1(gen):
    yield from gen

def main():
    g = g1
    g.send(None)

#1. main调用生成器 2.g1委托生成器 3.gen子生成器
#2. yield from 会在调用生成器和子生成器之间建立一个双向通道，
# 两者可以互通，现在调用生成器可以直接发送close,throw到子生成器

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;协程调度，事件循环+协程模式，协程是单线程模式.
编写时候凡是遇到耗io的操作，都用啥yield或yield from模式.
tornado是生成器生成的协程.&lt;/p&gt;

&lt;h4 id=&quot;async和await-原生协程&quot;&gt;async和await 原生协程&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#python3.5以后为了将语义变得更加明确，就引入了async和await关键词来定义原生协程
# async下不能再出现yield,同样await只能出现在async下
# await 后面跟的函数必须是awaitable也就是加了async的函数
import types

async def downloader(url):
    return 'fank'

# 另一种方法让函数变为awaitable，但是我没有试验成功。不过这种方法本来不推荐
@types.coroutine
def downloader2(url):
    return 'fank2'

async def download_url(url):
    # do something
    # await对应生成器的yield from
    html = await downloader2(url)
    return html

if __name__ == &quot;__main__&quot;:
    coro = download_url('http://www.google.com')
    # next(coro)  原生协程不能这样调用
    coro.send(None)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;asyncio模块&quot;&gt;asyncio模块&lt;/h3&gt;
&lt;p&gt;把它叫做异步Io库，并不叫协程库，这里包含了多线程，多进程，协程&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;包含各种特定系统实现的模块化事件循环&lt;/li&gt;
  &lt;li&gt;传输和协议抽象&lt;/li&gt;
  &lt;li&gt;对tcp,udp,ssl,子进程，延时调用以及其他的具体支持&lt;/li&gt;
  &lt;li&gt;模仿Futures模块但适用于事件循环适用的Future类&lt;/li&gt;
  &lt;li&gt;基于yield from的协议和任务，可以让你用顺序的方式编写并发代码&lt;/li&gt;
  &lt;li&gt;必须使用一个将产生阻塞io的调用时，哟接口可以把这个事件转移到线程池&lt;/li&gt;
  &lt;li&gt;模仿threading模块中的同步原语，可以用在单线程内的协程之间&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;asyncio 异步io并发编程 py3.4以后支持&lt;/p&gt;

&lt;p&gt;事件循环&lt;/p&gt;

&lt;p&gt;协程编码模式3个：1.事件循环 2.回调(驱动生成器) 3.epoll（io多路复用）&lt;/p&gt;

&lt;p&gt;应用：tornado, gevent, twisted(scrapy, django channels)&lt;/p&gt;

&lt;p&gt;ps: tornado不建议使用Pymysql,mysqlclient&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#事件循环+回调（驱动生成器）+epoll(IO多路复用)
#asyncio是Python用于解决异步io的一整套解决方案
#tornado,gevent,twisted(scrapy, dango channels(http2.0 websocket) 目前都是基于twisted)
#tornado(实现了web服务器)，django+flask(uwsgi,gunicorn+nginx)
#tornado可以直接部署，外加nginx

#asyncio
import asyncio
import time

async def get_html(url):
    print('start get html')
    #time.sleep()  #不能使用同步阻塞的方法
    await asyncio.sleep(2)  #耗时操作，io操作加await
    print('end get url')

if __name__ == &quot;__main__&quot;:
    start_time = time.time()
    loop  = asyncio.get_event_loop()  #事件循环，自动select
    tasks = [get_html('http://www.google.com') for i in range(10)]
    # loop.run_until_complete(get_html('http://www.google.com'))
    loop.run_until_complete(asyncio.wait(tasks))
    print('time:', time.time() - start_time)

#获取协程的返回值
from functools import partial

async def get_html(url):
    print('start get html')
    #time.sleep()  #不能使用同步阻塞的方法
    await asyncio.sleep(2)  #耗时操作，io操作加await
    return 'fank'

def callback(url, future): #partial url 要写在前面
    print(url)

if __name__ == &quot;__main__&quot;:
    start_time = time.time()
    loop  = asyncio.get_event_loop()  #事件循环，自动select
    # get_future = asyncio.ensure_future(get_html('http://www.google.com'))  #一个线程只有一个loop，这里ensure_future自动帮我们获取loop
    task = loop.create_task(get_html('http://www.google.com'))  #和上一句等效
    # loop.run_until_complete(get_html('http://www.google.com'))
    # task.add_done_callback(callback)
    #如过callback需要传参
    task.add_done_callback(partial(callback, 'http://www.googl.com'))

    # loop.run_until_complete(get_future)
    loop.run_until_complete(task)
    # print(get_future.result())
    print('time:', time.time() - start_time)

#wait 和gather的用法和区别
#gather更加高层，可以分组
async def get_html(url):
    print('start get html')
    #time.sleep()  #不能使用同步阻塞的方法
    await asyncio.sleep(2)  #耗时操作，io操作加await
    print('end get url')

if __name__ == &quot;__main__&quot;:
    start_time = time.time()
    loop  = asyncio.get_event_loop()  #事件循环，自动select
    group1 = [get_html('http://www.google.com') for i in range(10)]
    group2 = [get_html('http://www.google.com') for i in range(10)]
    # loop.run_until_complete(get_html('http://www.google.com'))
    group2.cancel() #批量取消
    loop.run_until_complete(asyncio.gather(*group1, *group2))
    print('time:', time.time() - start_time)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;取消task&quot;&gt;取消task&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# run_until_complete
import asyncio

# loop = asyncio.get_event_loop()
# loop.run_forever()  #不会停止，会一直运行
# loop.run_until_complete()  #运行了指定的协程之后会停止

async def get_html(sleep_times):
    print('waiting')
    await asyncio.sleep(sleep_times)
    print('done after {}'.format(sleep_times))

if __name__ == &quot;__main__&quot;:
    task1 = get_html(2)
    task2 = get_html(3)
    task3 = get_html(3)

    tasks = [task1, task2, task3]
    loop = asyncio.get_event_loop()

    try:
        loop.run_until_complete(asyncio.wait(tasks))
    except KeyboardInterrupt as e:
        all_tasks = asyncio.Task.all_tasks()
        for task in all_tasks:
            print('cancel task')
            print(task.cancel())
        loop.stop()
        loop.run_forever()  #很关键，不加会报错
    finally:
        loop.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;底层方法call_sooncall_latercall_at&quot;&gt;底层方法call_soon,call_later,call_at&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import asyncio

#可以给asyncio直接传递函数（不是async函数）
def callback(sleep_time):
    print('sleep {} success'.format(sleep_time))

def stoploop(loop):
    loop.stop()

if __name__ == &quot;__main__&quot;:
    loop = asyncio.get_event_loop()
    loop.call_soon(callback, 2)  #即刻执行，在队列里等到下一个循环立马执行
    loop.call_soon(stoploop, loop)

    loop.call_later(2,callback,2)  #在2秒钟之后运行callback
    loop.call_later(1,callback,1)
    loop.call_later(3,callback,3)

    now = loop.time()  #loop的time
    loop.call_at(now+2, callback, 2)
    loop.call_at(now+3, callback, 3)

    loop.call_soon_threadsafe()  #变量线程安全

    loop.run_forever()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;asynciothreadpollexecutor&quot;&gt;asyncio+ThreadPollExecutor&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#使用多线程:在协程中继承阻塞io(某些库就是阻塞的)
import asyncio
import socket
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor

def get_url(url):
    # get html by socket
    url = urlparse(url)
    host = url.netloc
    path = url.path
    if path == '':
        path = '/'
    
    #connect socket
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.connect((host, 80))
    client.send(&quot;GET {} HTTP/1.1\r\nHOST:{}\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode('utf8'))
    
    data = b''
    while True:
        d = client.recv(1024)
        if d:
            data += d
        else:
            break
    data = data.decode('utf8')
    htmldata = data.split('\r\n\r\n')[1]
    print(htmldata)

if __name__ == &quot;__main__&quot;:
    loop = asyncio.get_event_loop()
    executor = ThreadPoolExecutor(3)
    tasks = []
    for i in range(20):
        #参数1.线程池 2.函数名 3.函数参数
       task = loop.run_in_executor(executor, get_url, 'http://www.baidu.com/{}'.format(i))  #将某个阻塞Io函数放入executor中运行
       tasks.append(task)
    loop.run_until_complete(asyncio.wait(tasks))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;同步的方式实现异步http模拟请&quot;&gt;同步的方式实现异步http模拟请&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#asyncio没有提供http协议的接口；aiohttp异步的requests，可以启动服务器，可以爬虫
#同步的方式实现异步http模拟请求
import asyncio
import socket
from urllib.parse import urlparse

async def get_url(url):
    # get html by socket
    url = urlparse(url)
    host = url.netloc
    path = url.path
    if path == '':
        path = '/'
    
    #connect socket
    reader, writer = await asyncio.open_connection(host, 80)  #线程
    writer.write(&quot;GET {} HTTP/1.1\r\nHOST:{}\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode('utf8'))
    
    all_lines = []
    async for raw_line in reader:  #异步化，因为内部有yield from语法
        data = raw_line.decode('utf8')
        all_lines.append(data)

    html = '\n'.join(all_lines)
    return html

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    tasks = []
    for i in range(20):
        url = 'http://www.baidu.com/{}'.format(i)
        tasks.append(asyncio.ensure_future(get_url(url)))
    loop.run_until_complete(asyncio.wait(tasks))
    for task in tasks:
        print(task.result()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;asyncio同步和通信&quot;&gt;asyncio同步和通信&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import asyncio
from asyncio import Lock,Queue
queue = Queue()
await queue.get()
queue1 = [] #普通的全局变量也能用，但是不能控制Size流量

cache = {}
lock = Lock()

async def get_stuff(url):
    async with lock:
        # await lock.acquire()  #async 
        if url in cache:
            return cache[url]
        stuff = await aiohttp.request('get', url)
        cache[url] = stuff
        return stuff
        # lock.release()  #不需要await

async def parse_stuff():
    stuff = await get_stuff()

async def use_stuff():
    stuff = await get_stuff()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;aiohttp实现高并发爬虫&quot;&gt;aiohttp实现高并发爬虫&lt;/h3&gt;

&lt;h4 id=&quot;aiohttp&quot;&gt;aiohttp&lt;/h4&gt;
&lt;p&gt;HTTP client/server framework for asyncio&lt;/p&gt;

&lt;p&gt;server可以搭建http服务器&lt;/p&gt;

&lt;h3 id=&quot;client爬虫&quot;&gt;client爬虫&lt;/h3&gt;
&lt;p&gt;爬取Url
抽取内部Url
过滤
反爬
分布式&lt;/p&gt;

&lt;h4 id=&quot;sanic&quot;&gt;sanic&lt;/h4&gt;
&lt;p&gt;号称可以媲美go性能的高并发web服务器&lt;/p&gt;

</description>
        <pubDate>Fri, 08 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2019/03/08/python-deep.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2019/03/08/python-deep.html</guid>
        
        <category>python</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Ubuntu&amp;OSX的app抓包方案</title>
        <description>&lt;h2 id=&quot;ubuntu抓包方案&quot;&gt;Ubuntu抓包方案&lt;/h2&gt;

&lt;h2 id=&quot;必备条件&quot;&gt;必备条件&lt;/h2&gt;
&lt;p&gt;电脑手机同一wifi (如果pc做了ip端口映射也可以使用广域网ip抓包)&lt;/p&gt;

&lt;h2 id=&quot;方案1&quot;&gt;方案1&lt;/h2&gt;

&lt;h3 id=&quot;fiddler&quot;&gt;Fiddler&lt;/h3&gt;

&lt;p&gt;Fiddler在Ubuntu上基于mono运行&lt;/p&gt;

&lt;p&gt;Fiddler &amp;amp; mono 下载地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://fiddler.wikidot.com/mono
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;下载并装成功&lt;/li&gt;
  &lt;li&gt;打开Fiddler-&amp;gt; tools-&amp;gt;options -&amp;gt; connections  查看Port选项，记录下来&lt;/li&gt;
  &lt;li&gt;手机连接wifi并选择代理，方式手动代理&lt;/li&gt;
  &lt;li&gt;填写主机名为PC本地ip地址，端口填写刚刚记录的Port&lt;/li&gt;
  &lt;li&gt;打开手机app，观察Fiddler接受\发送的请求&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;方案2&quot;&gt;方案2&lt;/h2&gt;

&lt;h3 id=&quot;charles&quot;&gt;Charles&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;下载安装
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://www.charlesproxy.com/download/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;打开charles在Proxy-&amp;gt;ProxySetting设置一个端口号，并勾选Enable&lt;/li&gt;
  &lt;li&gt;设置手机代理&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果手机包出现乱码情况，请安装charles证书（安装方法在最后）。如果手机无法安装.pem修改为.crt
（小米手机进入到设置-wifi，点击高级，安装证书）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;打开手机app，观察charles接受\发送的请求&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;mac-osx抓包方案&quot;&gt;mac osx抓包方案&lt;/h2&gt;

&lt;h3 id=&quot;charles-1&quot;&gt;Charles&lt;/h3&gt;

&lt;p&gt;使用手机安装SSL证书&lt;/p&gt;

&lt;p&gt;在help-&amp;gt;SSL Proxying-&amp;gt; “nstall Charles Root Certificate on a Mobile Device or remote Browser”&lt;/p&gt;

&lt;p&gt;然后根据提示访问安装&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2019/03/08/appspider-tools.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2019/03/08/appspider-tools.html</guid>
        
        <category>app,</category>
        
        <category>抓包</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Hey, U find me!</title>
        <description>&lt;h3 id=&quot;我&quot;&gt;我&lt;/h3&gt;

&lt;p&gt;网名：三秋，取自《滕王阁序》“时维九月，序属三秋。” 九月生，天秤座。&lt;/p&gt;

&lt;p&gt;十分热爱思考，善于分析、判断、总结和预测。&lt;/p&gt;

&lt;h3 id=&quot;计算机&quot;&gt;计算机&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;通过解决问题学习计算机&lt;/li&gt;
  &lt;li&gt;通过学习计算机解决问题&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在很久以前使用计算机解决了问题，从此便对计算机产生了浓厚兴趣。&lt;/p&gt;

&lt;h3 id=&quot;如何找到我&quot;&gt;如何找到我&lt;/h3&gt;

&lt;p&gt;GitHub: &lt;a href=&quot;https://github.com/fankcoder&quot;&gt;fankcoder&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;微博: &lt;a href=&quot;https://weibo.com/u/2424646683&quot;&gt;似叶三秋&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;知乎: &lt;a href=&quot;https://www.zhihu.com/people/si-xie-san-qiu/activities&quot;&gt;似叶三秋&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bilibili: &lt;a href=&quot;https://space.bilibili.com/38307214&quot;&gt;三秋Q3Q&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Email: fankcoder#gmail.com&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/about/2019/03/08/HeyUFindMe.html</link>
        <guid isPermaLink="true">http://localhost:4000/about/2019/03/08/HeyUFindMe.html</guid>
        
        <category>me</category>
        
        
        <category>About</category>
        
      </item>
    
      <item>
        <title>vim使用手册</title>
        <description>&lt;h2 id=&quot;我爱vim&quot;&gt;我爱Vim&lt;/h2&gt;

&lt;p&gt;Vim极大的提高了我编码时的快感，使用了几年vim，已然是一名忠实用户了，不管切换什么编辑器第一时间就是找vim插件，当然chrome也不会放过，整理一下vim技巧。&lt;/p&gt;

&lt;h3 id=&quot;基础&quot;&gt;基础&lt;/h3&gt;

&lt;p&gt;把基础操作放在一起，造福他人。请在Normal模式下操作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;i → Insert 模式，按 ESC 回到 Normal 模式.
x → 删当前光标所在的一个字符。
:wq → 存盘 + 退出 (:w 存盘, :q 退出) 
dd → 删除当前行，并把删除的行存到剪贴板里
p → 粘贴剪贴板

hjkl (←↓↑→). 注: j 就像下箭头。
:help &amp;lt;command&amp;gt; → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;加强&quot;&gt;加强&lt;/h3&gt;

&lt;p&gt;比基础稍强点的操作&lt;/p&gt;

&lt;h4 id=&quot;插入&quot;&gt;插入&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a → 在光标后插入
o → 在当前行后插入一个新行
O → 在当前行前插入一个新行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;移动光标&quot;&gt;移动光标&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 → 数字零，到行头
^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）
$ → 到本行行尾
g_ → 到本行最后一个不是blank字符的位置。
/pattern → 搜索 pattern 的字符串
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;拷贝粘贴&quot;&gt;拷贝/粘贴&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;P → 粘贴
yy → 拷贝当前行当行于 ddP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;撤销重做&quot;&gt;撤销/重做&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;u → undo
&amp;lt;C-r&amp;gt; → redo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;打开保存退出改变文件&quot;&gt;打开/保存/退出/改变文件&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:e &amp;lt;path/to/file&amp;gt; → 打开一个文件
:w → 存盘
:saveas &amp;lt;path/to/file&amp;gt; → 另存为 &amp;lt;path/to/file&amp;gt;
:x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车)
:q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。
:bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;技巧&quot;&gt;技巧&lt;/h3&gt;

&lt;p&gt;我非常爱用的一些技巧，会不断补充&lt;/p&gt;

&lt;h4 id=&quot;tabe&quot;&gt;tabe&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tabe file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;切换tab&quot;&gt;切换tab&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gt  #前面可加数字指定
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;翻页&quot;&gt;翻页&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c-l + f
c-l + b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;移动光标-1&quot;&gt;移动光标&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;w → 到下一个单词的开头。
e → 到下一个单词的结尾。
% : 匹配括号移动，包括 (, {, [. 
* 和 #:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）
0 行首
^到本行的第一个非blank字符
$行尾
t, → 到逗号前的第一个字符。逗号可以变成其它字符。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;重复操作&quot;&gt;重复操作&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;. 重复之前的操作
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;视图模式&quot;&gt;视图模式&lt;/h3&gt;

&lt;p&gt;视图模式侧重选择&lt;/p&gt;

&lt;h4 id=&quot;块操作-&quot;&gt;块操作: &lt;C-v&gt;&lt;/C-v&gt;&lt;/h4&gt;

&lt;p&gt;常用于多行编辑&lt;/p&gt;

&lt;h4 id=&quot;自动提示--和-&quot;&gt;自动提示： &lt;C-n&gt; 和 &lt;C-p&gt;&lt;/C-p&gt;&lt;/C-n&gt;&lt;/h4&gt;

&lt;p&gt;编辑模式，手动补全&lt;/p&gt;

&lt;h4 id=&quot;缩进&quot;&gt;缩进&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt; 或 &amp;gt; → 左右缩进
= → 自动给缩进 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;分屏&quot;&gt;分屏&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:split
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://coolshell.cn/articles/5426.html&quot;&gt;参考文献&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/02/01/vim.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/02/01/vim.html</guid>
        
        <category>vim</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>JavaScript 常用资源</title>
        <description>&lt;h2 id=&quot;常用代码&quot;&gt;常用代码&lt;/h2&gt;

&lt;h3 id=&quot;交互&quot;&gt;交互&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alert();

prompt();
result = prompt(title[, default]);
浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定/取消按钮。

confirm
result = confirm(question);
confirm 函数显示一个带有 question 和两个按钮的模态窗口：确定和取消。
点击确定返回 true，点击取消返回 false。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;多个条件else-if&quot;&gt;多个条件：“else if”&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (year &amp;lt; 2015) {
  alert( 'Too early...' );
} else if (year &amp;gt; 2015) {
  alert( 'Too late' );
} else {
  alert( 'Exactly!' );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;三元运算符-&quot;&gt;三元运算符 ‘?’&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let result = condition ? value1 : value2
计算条件结果，如果结果为真，则返回 value1，否则返回 value2。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;逻辑运算符-或--与--非&quot;&gt;逻辑运算符：|| (或), &amp;amp;&amp;amp; (与), ! (非)。&lt;/h3&gt;

&lt;h3 id=&quot;while&quot;&gt;while&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (condition) {
  // 代码
  // 所谓的“循环体”
}

“do…while” 循环
do {
  // 循环体
} while (condition);
循环首先执行循环体，然后检查条件，当条件为真时，重复执行循环体。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;for-循环&quot;&gt;“for” 循环&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (begin; condition; step) {
  // ... loop body ...
}

通过示例来了解这部分的含义。下述循环运行从 i 等于 0 到 3（但不包括 3）的 alert(i)：
for (let i = 0; i &amp;lt; 3; i++) { // 结果为 0、1、2
  alert(i);
}

跳过
for 循环的任何部分都可以被跳过。

let i = 0; // 我们已经声明并分配了
for (; i &amp;lt; 3; i++) { // &quot;begin&quot; 部分不再需要
  alert( i ); // 0, 1, 2
}

也可以移除 step 部分：
let i = 0;
for (; i &amp;lt; 3;) {
  alert( i++ );
}

实际上我们可以删除所有内容，从而创建一个无限循环：
for (;;) {
  // 无限循环
}
请注意 for 的两个 ; 必须存在，否则会出现语法错误。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;continue--break&quot;&gt;continue;  break;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;跳到标签
outer: for (let i = 0; i &amp;lt; 3; i++) {
for (let j = 0; j &amp;lt; 3; j++) {
    let input = prompt(`Value at coords (${i},${j})`, '');
    // 如果是空字符串或已取消，则中断这两个循环。
    if (!input) break outer; // (*)
    // 做些有价值的事
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;switch-语句&quot;&gt;“switch” 语句&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;函数声明&quot;&gt;函数声明&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function showMessage(text = &quot;no text given&quot;) {
  alert( 'Hello everyone!' );
  return;
}

命名技巧
showMessage(..)     // 显示信息
getAge(..)          // 返回 age (gets it somehow)
calcSum(..)         // 计算求和并返回结果
createForm(..)      // 创建表格 (通常会返回它)
checkPermission(..) // 检查权限并返回 true/false

PS:当 JavaScript 准备运行脚本或代码块时，它首先在其中查找函数声明并创建函数。我们可以将其视为“初始化阶段”.
因此，声明为函数声明的函数可以比定义的更早调用。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;powxn&quot;&gt;pow(x,n)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;将 x 与自身相乘 n 次，然后返回结果。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;函数表达式&quot;&gt;函数表达式&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let sayHi = function() {
  alert( &quot;Hello&quot; );
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;回调函数匿名函数&quot;&gt;回调函数&amp;amp;匿名函数&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  &quot;Do you agree?&quot;,
  function() { alert(&quot;You agreed.&quot;); },
  function() { alert(&quot;You canceled the execution.&quot;); }
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;箭头函数&quot;&gt;箭头函数&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let func = function(arg1, arg2, ...argN) {
  return expression;
}

let sum = (a, b) =&amp;gt; a + b;
/* 箭头函数更短：
let sum = function(a, b) {
  return a + b;
};*/

let double = n =&amp;gt; n * 2; 只有一个参数，那么括号可以省略
let sayHi = () =&amp;gt; alert(&quot;Hello!&quot;); 没有参数，括号应该是空的
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;编码风格&quot;&gt;编码风格&lt;/h3&gt;

&lt;p&gt;![avatar](https://raw.githubusercontent.com/fankcoder/fankcoder.github.io/master/static/code-style-js.png&lt;/p&gt;

&lt;h3 id=&quot;figure-brackets大括号&quot;&gt;Figure brackets（大括号）&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (condition) {
  // do this
  // ...and that
  // ...and that
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;forin-循环&quot;&gt;“for…in” 循环&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;为了使用对象所有的属性，就可以利用 for..in 循环。这跟 for(;;) 是完全不一样的东西。
let user = {
  name: &quot;John&quot;,
  age: 30,
  isAdmin: true
};

for(let key in user) {
  // keys
  alert( key );  // name, age, isAdmin
  // 属性键的值
  alert( user[key] ); // John, 30, true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;symbol-是唯一标识符的基本类型&quot;&gt;Symbol 是唯一标识符的基本类型&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Symbol 使用 Symbol() 创建的，调用带有一个可选的描述。

let id1 = Symbol(&quot;id&quot;);
let id2 = Symbol(&quot;id&quot;);
alert(id1 == id2); // false

Symbol 总是不同的值，即使它们有相同的名称。如果我们希望同名 Symbol 相等，那么我们应该使用全局注册表：Symbol.for(key) 返回（如果需要的话创建）一个以 key 作为名称的全局 Symbol。Symbol.for 的多次调用完全返回相同的 Symbol。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;方法中的-this&quot;&gt;方法中的 “this”&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;对象方法需要访问对象中的存储的信息来完成其工作。为了访问该对象，方法中可以使用 this 关键字。
let user = {
  name: &quot;John&quot;,
  age: 30,
  sayHi() {
    alert(this.name);
  }
};
user.sayHi(); // John
this 的值就是在点之前的这个对象，即调用该方法的对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;构造函数&quot;&gt;构造函数&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;构造函数在技术上是常规函数。不过有两个约定：
他们首先用大写字母命名。
它们只能用 &quot;new&quot; 操作符来执行。这样的调用意味着在开始时创建空的 this，并在最后返回填充的对象。

例如：
function User(name) {
  this.name = name;
  this.isAdmin = false;
}
let user = new User(&quot;Jack&quot;);
alert(user.name); // Jack
alert(user.isAdmin); // false

当一个函数作为 new User(...)执行时，它执行以下步骤：
一个新的空对象被创建并分配给 this。
函数体执行。通常它会修改 this，为其添加新的属性。返回 this 的值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;字符串&quot;&gt;字符串&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;字符串可以包含在单引号、双引号或反引号中.
单引号和双引号本质上是一样的。但是，反引号允许我们将任何表达式嵌入到字符串中，包括函数调用.
反引号的另一个优点是它们允许字符串跨行

alert( `My\n`.length );   //length 属性有字符串长度

let str = `Hello`;
alert( str[1000] ); // undefined
alert( str.charAt(1000) ); // '' (an empty string)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数组&quot;&gt;数组&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let arr = new Array();
let arr = [];

push 在末端添加一个元素.pop 从末端取出一个元素.

shift取出数组的第一个元素并返回它.unshift在数组的前端添加元素

性能push/pop 方法运行的比较快，而 shift/unshift 比较慢。

遍历
let fruits = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Plum&quot;];

// 迭代数组元素
for (let fruit of fruits) {
  alert( fruit );
}

let arr = [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;];

for (let i = 0; i &amp;lt; arr.length; i++) {
  alert( arr[i] );
}

alert( arr.length );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;delete&quot;&gt;delete&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;元素被删除，但数组长度不变
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;splice&quot;&gt;splice&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arr.splice(index[, deleteCount, elem1, ..., elemN])
索引，删除个数，替换。并且返回删除的元素
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;slice&quot;&gt;slice&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arr.slice(start, end)
它从所有元素的开始索引 &quot;start&quot; 复制到 &quot;end&quot; (不包括 &quot;end&quot;) 返回一个新的数组。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;concat&quot;&gt;concat&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arr.concat(arg1, arg2...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;查询数组&quot;&gt;查询数组&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这些是在数组中查询某些内容的方法。

indexOf/lastIndexOf 和 includes
arr.indexOf、arr.lastIndexOf 和 arr.includes 方法与字符串操作具有相同的语法，只不过这里是对数组元素而不是字符进行操作：

arr.indexOf(item, from) 从索引 from 查询 item，如果找到返回索引，否则返回 -1。
arr.lastIndexOf(item, from) — 和上面相同，只是从尾部开始查询。
arr.includes(item, from) — 从索引 from 查询 item，如果找到则返回 true。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 15 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E5%A4%87%E5%BF%98/2019/01/15/general-javascript-resources.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E5%A4%87%E5%BF%98/2019/01/15/general-javascript-resources.html</guid>
        
        <category>JavaScript</category>
        
        
        <category>备忘</category>
        
      </item>
    
      <item>
        <title>Python线程&amp;进程&amp;协程&amp;asyncio</title>
        <description>&lt;h3 id=&quot;线程进程&quot;&gt;线程&amp;amp;进程&lt;/h3&gt;

&lt;p&gt;GIL global interpreter lock GIL全局解释锁&lt;/p&gt;

&lt;p&gt;python中一个线程对应于c中的线程&lt;/p&gt;

&lt;p&gt;python是先将py文件编译为字节码&lt;/p&gt;

&lt;p&gt;gil使得同一时刻只有一个线程在一个cpu上执行字节码，无法将多个线程映射到多个cpu上&lt;/p&gt;

&lt;p&gt;为了安全，但速度慢，无法体现多核优势。pypy是去gil化的。gil在遇到io操作会主动释放&lt;/p&gt;

&lt;p&gt;操作系统调度的最小单元线程，对于io操作，多线程和多进程差别不大。&lt;/p&gt;

&lt;h4 id=&quot;通过thread类实例化&quot;&gt;通过thread类实例化&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;thread1 = threading.Thread(target=func, args=(&quot;&quot;,))

thread1.setDaemon(True)#设置为守护线程。当主线程关闭时，子线程被kill

thread1.join() #阻塞，等待thread1子线程执行完成
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;继承thread来实现多线程&quot;&gt;继承thread来实现多线程&lt;/h4&gt;
&lt;p&gt;当代码量大，逻辑复杂时，推荐通过继承thread来实现多线程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class GetDetailHtml(threading.Thread):
    def __init__(self, name):   #为线程命名，好习惯
        super().__init__(name=name)
    
    def run(self):
        print('get detail html')
        time.sleep(2)
        print('get detail html done')

class GetTitleHtml(threading.Thread):
    def __init__(self, name):
        super().__init__(name=name)

    def run(self):
        print('get title url')
        time.sleep(2)
        print('get title url done')


if __name__ == '__main__':
    thread1 = GetTitleHtml('get title html')
    thread2 = GetDetailHtml('get detail html')
    start_time = time.time()
    thread1.start()
    thread2.start()
    thread1.join()
    thread2.join()
    print('last time {}'.format(time.time() - start_time))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;线程之间的通信方式&quot;&gt;线程之间的通信方式&lt;/h3&gt;

&lt;h4 id=&quot;1共享全局变量list多线程可以多进程不行&quot;&gt;1.共享全局变量(list)（多线程可以，多进程不行）&lt;/h4&gt;

&lt;p&gt;这种方法，线程并不安全，需要加gil锁，所以并不推荐用作通信&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time
import threading

#1.共享全局变量
detail_url_list = []

def get_title_html(detail_url_list):
    print('get title url')
    time.sleep(2)
    for i in range(20):
        detail_url_list.append('http://www.test.com/id/{}/'.format(i))
    print('get title url done')

def get_detail_html(detail_url_list):
    print('get detail html')
    time.sleep(2)
    if len(detail_url_list):
        url = detail_url_list.pop()
        print('get detail html done')

if __name__ == '__main__':
    thread1 = threading.Thread(target=get_title_html, args=(detail_url_list,))
    for i in range(10): #启动10个线程，太多线程操作系统切换会产生很大代价
        html_thread = threading.Thread(target=get_detail_html, args=(detail_url_list,))
        html_thread.start()
    start_time = time.time()
    thread1.start()
    thread1.join()
    print('last time {}'.format(time.time() - start_time))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2通过queue方法进行线程间通讯queue本身是线程安全的&quot;&gt;2.通过queue方法进行线程间通讯,queue本身是线程安全的&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from queue import Queue
import time
import threading

def get_title_html(queue):
    while True:
        print('get title url')
        time.sleep(2)
        for i in range(20):
            queue.put('http://www.test.com/id/{}/'.format(i))
        print('get title url done')

def get_detail_html(queue):
    while True:
        print('get detail html')
        time.sleep(2)
        url = queue.get()  #get方法是阻塞方法，如果queue为空就等待
        print('get detail html done')

if __name__ == '__main__':
    detail_queue = Queue(maxsize=1000)
    thread1 = threading.Thread(target=get_title_html, args=(detail_queue,))
    for i in range(10): #启动10个线程，太多线程操作系统切换会产生很大代价
        html_thread = threading.Thread(target=get_detail_html, args=(detail_queue,))
        html_thread.start()
    start_time = time.time()
    thread1.start()
    thread1.join()
    print('last time {}'.format(time.time() - start_time))


queue.get()#阻塞方法，如果为空就一直停顿等待
queue.put_nowait()#设置为非阻塞
queue.qsize() #获取长度，同样是线程安全的可以直接使用
queue.empty()
queue.full()
queue.join()#阻塞直到执行到task_done()
queue.task_done()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;.join()一直阻塞，想退出需要调用.task_down() #爬虫暂停&lt;/p&gt;

&lt;p&gt;如果共用变量为dict或其他非队列数据，也可以考虑使用全局变量&lt;/p&gt;

&lt;h3 id=&quot;线程同步lock-rlock&quot;&gt;线程同步（lock, rlock）&lt;/h3&gt;

&lt;p&gt;避免淘宝库存同时有人买
线程同步机制,lock锁，反正锁住的代码段都只能有一个在运行，释放之后才能让其他代码运行.&lt;/p&gt;

&lt;p&gt;使用锁会出现的问题&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;用锁会影响性能&lt;/li&gt;
  &lt;li&gt;锁会引起死锁（互相等待）,不能连续调用两次acquire&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from threading import Lock

lock = Lock()

global lock

lock.acquire() #获取

a += 1

lock.release() #释放
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;死锁情况&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A(a, b)
acquire(a)
acquire(b)

B(a, b)
acquire(b) # a,b同时等待
acquire(a)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;rlock可重入的锁&quot;&gt;rlock可重入的锁&lt;/h4&gt;

&lt;p&gt;解决lock，不能连续调用acquire的问题。它可以在同一个线程里面，可以连续调用多次acquire，需要相等数量的release.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from threading import RLock
lock = Rlock()

lock.acquire()
lock.acquire()
lock.release()
lock.release()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;condition条件变量&quot;&gt;condition条件变量&lt;/h3&gt;

&lt;p&gt;用于复杂的线程间同步锁&lt;/p&gt;

&lt;p&gt;wait()允许等待某个条件变量的通知
notify()会通知调用了wait()方法的那个线程启动&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用condition启动顺序非常重要&lt;/li&gt;
  &lt;li&gt;一定要先调用with方法或者acquire和release，之后再调用wait(),notify()&lt;/li&gt;
  &lt;li&gt;condition有两层锁，一把底层锁会在线程调用wait方法的时候释放，上面的锁会值每次调用wait时分配一把并放入到cond的等待队列中，等到notify方法唤醒&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import threading
from threading import Condition

class XiaAi(threading.Thread):
    def __init__(self, cond):
        super().__init__(name='小爱')
        self.cond = cond
    
    def run(self):
        with self.cond:
            self.cond.wait()
            print('{}: 在'.format(self.name))
            self.cond.notify()

            self.cond.wait()
            print('{}: 好啊'.format(self.name))
            self.cond.notify()
    
class TianMao(threading.Thread):
    def __init__(self, cond):
        super().__init__(name='天猫')
        self.cond = cond
    
    def run(self):
        with self.cond:
            print('{}: 小爱同学'.format(self.name))
            self.cond.notify()
            self.cond.wait()

            print('{}: 我们来对古诗吧'.format(self.name))
            self.cond.notify()
            self.cond.wait()

if __name__ == '__main__':
    cond = threading.Condition()

    xiaoai = XiaAi(cond)
    tianmao = TianMao(cond)

    xiaoai.start()
    tianmao.start()
    xiaoai.join()
    tianmao.join()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;semaphore-控制线程并发数量&quot;&gt;Semaphore 控制线程并发数量&lt;/h3&gt;

&lt;p&gt;(文件读写，写一般只用一个线程，读可以允许有多个线程)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import threading
import time


class HtmlSpider(threading.Thread):
    def __init__(self, url, sem):
        super().__init__()
        self.url = url
        self.sem = sem
    
    def run(self):
        time.sleep(2)
        print('get html success')
        self.sem.release()

class UrlProducer(threading.Thread):
    def __init__(self, sem):
        super().__init__()
        self.sem = sem
    
    def run(self):
        for i in range(10):
            self.sem.acquire()
            html_thread = HtmlSpider('http://www.baidu.com/id/{}/'.format(i), self.sem)
            html_thread.start()

if __name__ == '__main__':
    sem = threading.Semaphore(3)
    url_thread = UrlProducer(sem)
    url_thread.start()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;线程池concurrent-py32&quot;&gt;线程池concurrent #py3.2&lt;/h3&gt;
&lt;p&gt;concurrent容易的编写多线程，多进程代码&lt;/p&gt;

&lt;p&gt;为什么使用线程池？&lt;/p&gt;

&lt;p&gt;1.主线程中可以获取某一个线程的状态或者某一个任务的状态，以及返回值&lt;/p&gt;

&lt;p&gt;2.当一个线程完成的时候，主线程能立即知道&lt;/p&gt;

&lt;p&gt;3.futures可以让多线程多进程编码接口一致&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from concurrent.futures import ThreadPoolExecutor,as_completed,wait,FIRST_COMPLETED
import time

def get_html(times):
    time.sleep(times)
    print('get html {} success'.format(times))
    return times

executor = ThreadPoolExecutor(max_workers=2)

#通过submit提交执行的函数到线程池中，submit是立即返回
task1 = executor.submit(get_html, (3))
task2 = executor.submit(get_html, (2))
print(task1.done())
#取消线程执行，状态done无论为true和false都不能取消执行。只有还没提交到线程池中的线程才能提交，与max_workers的设置有关
print(task2.cancel(2))
time.sleep(3.1)
#done()查看该线程当前的执行状态
print(task1.done())
#result()获取该线程的返回结果
print(task1.result())

#as_completed获取已经成功的task的返回，如爬虫
urls = [2,3,4,2]
all_task = [executor.submit(get_html, (url)) for url in urls]
for future in as_completed(all_task):
    data = future.result()
    print('get {} page success'.format(data))

#使用executor的map方法对as_completed进行简化.map的返回结果就是future.result()
#map的返回顺序是按照list的顺序，并不是先执行完就返回
for data in executor.map(get_html, urls):
    print('get {} page success'.format(data))
#wait设置阻塞，参数可选择条件默认为ALL_COMPLETED
wait(all_task, return_when=FIRST_COMPLETED)
print('main')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;多进程&quot;&gt;多进程&lt;/h3&gt;

&lt;p&gt;线程由于有gil无法并发，python多线程无法利用多cpu。&lt;/p&gt;

&lt;p&gt;耗cpu的操作，多核cpu，计算，图像，挖矿多进程优于多线程。
io操作进程切换代价高于线程。&lt;/p&gt;

&lt;p&gt;进程数据完全隔离,无法使用共享全局变量&lt;/p&gt;

&lt;p&gt;子进程完全拷贝Fork之后的父进程代码运行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time
from concurrent.futures import ThreadPoolExecutor,as_completed
from concurrent.futures import ProcessPoolExecutor

def fib(n):
    if n &amp;lt;=2:
        return 1
    return fib(n-1)+fib(n-2)

# 耗cpu的操作多进程比多线程速度快
with ProcessPoolExecutor(3) as executor:  #win使用多进程必须在__name=='__main__'下运行
# with ThreadPoolExecutor(3) as executor:
    alltask = [executor.submit(fib, (num)) for num in range(25,40)]
    start_time = time.time()
    for future in as_completed(alltask):
        data = future.result()
        print('exec result {}'.format(data))
    
    print('last time is :{}'.format(time.time() - start_time))

# io操作多线程比多进程快
def random_sleep(n):
    time.sleep(n)
    return n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;更加底层的多进程包&quot;&gt;更加底层的多进程包&lt;/h4&gt;
&lt;p&gt;学习底层，生产环境还是推荐conncurrent&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import os
import time
import multiprocessing

pid = os.fork()
print('fank')
if pid == 0:  #pid=0 child pro
    print('child process {}. parent process {}'.format(os.getpid(), os.getppid()))
else:
    print('parent process {}'.format(pid))

time.sleep(2)

def get_html(n):
    time.sleep(n)
    print('sub progress success')
    return n

if __name__ == '__main__':
    program = multiprocessing.Process(target=get_html, args=(2,))
    program.start()
    program.join()
    print(program.pid) #比线程多个pid属性
    print('main progress end')

    #进程池
    pool = multiprocessing.Pool(multiprocessing.cpu_count())
    result = pool.apply_async(get_html,args=(3,))

    #等待所有任务完成
    pool.close()  #关闭接受新的进程
    pool.join()
    print(result.get())

    #imap  按顺序输出
    for result in pool.imap(get_html, [1,5,3]):
        print('{} sleep success'.format(result))

    #imapunordered  按执行速度输出
    for result in pool.imap_unordered(get_html, [1,5,3]):
        print('{} sleep success'.format(result))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;进程间的通讯&quot;&gt;进程间的通讯&lt;/h3&gt;

&lt;p&gt;共享全局变量在多进程中不适用&lt;/p&gt;

&lt;p&gt;mutiprocessing.queue用于进程间的通讯&lt;/p&gt;

&lt;p&gt;进程池中的通讯有3个queue需要区分&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;系统from queue import Queue不能用于通讯&lt;/li&gt;
  &lt;li&gt;from mutiprocessing import Queue 不能用在进程池通讯&lt;/li&gt;
  &lt;li&gt;from mutiprocessing import Manager().queue 用于进程池pool中的通讯&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import time
from multiprocessing import Process, Queue, Manager, Pipe

def producer(queue):
    queue.put('a')
    time.sleep(2)

def consumer(queue):
    time.sleep(2)
    data = queue.get()
    print(data)

if __name__ == '__main__':
    queue = Queue(10)   #使用multi的queue
    my_producer = Process(target=producer, args=(queue,))
    my_consumer = Process(target=consumer, args=(queue,))
    my_producer.start()
    my_consumer.start()
    my_producer.join()
    my_consumer.join()

    #manage 用于进程池中的通讯
    queue = Manager().queue(10)

    # pipe 用于两个进程间的通讯
    # 通过pipe实现进程通信,pipe只适用与两个进程
    # 为什么不直接用queue？因为pipe的性能高于queue
    receiver_pipe, send_pipe = Pipe()
    my_producer = Process(target=producer, args=(send_pipe,))
    my_consumer = Process(target=consumer, args=(receiver_pipe,))
    my_producer.start()
    my_consumer.start()
    my_producer.join()
    my_consumer.join()

    # 数据同步，以manager dict为例
    def add_data(p_dict, key, value):
        p_dict[key] = value
    process_dict = Manager().dict()
    first_progress = Process(target=add_data, args(process_dict,'f',25))
    second_progress = Process(target=add_data, args(process_dict,'f2',27))
    first_progress.start()
    second_progress.start()
    first_progress.join()
    second_progress.join()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;协程-有多个入口的函数可以暂停的函数可以向暂停的地方传值&quot;&gt;协程 （有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）&lt;/h3&gt;

&lt;h4 id=&quot;并发&quot;&gt;并发&lt;/h4&gt;
&lt;p&gt;指在一个时间段内，有几个程序在同一个cpu上运行，但任意时刻只有一个程序在cpu上运行&lt;/p&gt;

&lt;h4 id=&quot;并行&quot;&gt;并行&lt;/h4&gt;
&lt;p&gt;指任意时刻有多个程序运行在多个cpu上&lt;/p&gt;

&lt;h4 id=&quot;同步&quot;&gt;同步&lt;/h4&gt;
&lt;p&gt;指代码调用io操作时，必须等待io操作完成才返回的调用方式&lt;/p&gt;

&lt;h4 id=&quot;异步&quot;&gt;异步&lt;/h4&gt;
&lt;p&gt;指代码调用io操作时，不必等待io操作完成就返回的调用方式（future）&lt;/p&gt;

&lt;h4 id=&quot;阻塞&quot;&gt;阻塞&lt;/h4&gt;
&lt;p&gt;指调用函数时，当前线程会被挂起（等待）&lt;/p&gt;

&lt;h4 id=&quot;非阻塞&quot;&gt;非阻塞&lt;/h4&gt;
&lt;p&gt;调用函数时，当前线程不会被挂起，而是立即返回&lt;/p&gt;

&lt;p&gt;C10k问题，1999年被提出的一个挑战。要求在一颗1GHz CPU,2G内存,1gbps带宽，让单台服务器同时为1万个客户提供ftp服务。
如果为每个用户开一个线程，作为低配服务器做不到&lt;/p&gt;

&lt;h4 id=&quot;unix下五种io模型&quot;&gt;unix下五种io模型&lt;/h4&gt;
&lt;p&gt;阻塞式io，在等待io操作时，cpu是空闲的&lt;/p&gt;

&lt;p&gt;非阻塞式io，做计算任务或者单向发送请求，不需要等待返回的任务&lt;/p&gt;

&lt;p&gt;I/O复用，select,poll,epoll由操作系统提供。
select查看那些socket或文件句柄已经准备好了，select可以同时监听多个socket&lt;/p&gt;

&lt;p&gt;信号驱动式I/O,操作系统发起的用的较少&lt;/p&gt;

&lt;p&gt;异步I/O(POSIX的aio_系列函数)，
其实很多并发框架都是使用io多路复用，用aio不多,aio与io复用并没有很明显的提升，编码难度比io复用高很多。&lt;/p&gt;

&lt;h3 id=&quot;selectpollepoll&quot;&gt;select,poll,epoll&lt;/h3&gt;

&lt;p&gt;他们都是io多路复用机制。io多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般为读写就绪），能够通知程序进行相应的读写操作。但select,poll,epoll本质上都是同步io，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步io则无需自己负责进行读写，异步io的实现会负责把数据从内核拷贝到用户空间。&lt;/p&gt;

&lt;h4 id=&quot;select&quot;&gt;select&lt;/h4&gt;
&lt;p&gt;select函数监视的文件描述分3类，分别是writefds、readfds和exceptfds。调用后select函数会阻塞，知道有描述符就绪（数据可读可写，或有except),或者超时（timeout指定等待时间，如果立即返回设定为null）,函数返回。当select函数返回后，可以通过遍历fdset,来找到就绪的描述符。
select目前几乎在所有平台上支持。缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在linux上一般为1024，虽然可以修改，但是会造成效率降低。&lt;/p&gt;

&lt;h4 id=&quot;poll&quot;&gt;poll&lt;/h4&gt;
&lt;p&gt;不同与select使用三个位图来表示三个fdset的方式，poll使用一个pollfd的指针实现。
pollfd没有最大数量限制。select和poll一样需要遍历文件描述符来获取已经就绪的socket，随着描述符数量增长，其效率也会下降。&lt;/p&gt;

&lt;h4 id=&quot;epoll&quot;&gt;epoll&lt;/h4&gt;
&lt;p&gt;win不支持，linux2.6内核中提出，是select和poll的增强版。epoll查询使用性能很高的红黑树。
1.epoll并不代表一定比select好，在并发高的情况下，连接活跃度不高，epoll比较好（网站）。
并发性不高，同时连接活跃，select比较好（比如游戏）。&lt;/p&gt;

&lt;p&gt;通过非阻塞io实现http请求&lt;/p&gt;

&lt;h4 id=&quot;c10m问题&quot;&gt;C10M问题&lt;/h4&gt;
&lt;p&gt;如何利用8核心cpu，64G内存，在10gbps的网网上保持1000万并发连接&lt;/p&gt;

&lt;h4 id=&quot;协程解决的问题&quot;&gt;协程解决的问题&lt;/h4&gt;
&lt;p&gt;主要是解决回调编写难的问题。保持性能+代码编写容易&lt;/p&gt;

&lt;p&gt;1.采用同步的方式编写异步的代码
2.使用单线程去切换任务：
    1. 线程是由操作系统切换的，单线程切换意味着需要程序员去调度任务
    2. 不在需要锁，并发性高，如果单线程内切换函数，性能高于线程切换，&lt;/p&gt;

&lt;p&gt;#传统函数调用方式 A-B-C,一旦调用其他函数，函数只运行一次然后退出
#我们需要一个可以暂停的函数，并且可以在适当的时候恢复该函数继续执行
#协程  -&amp;gt; 有多个入口的函数，可以暂停的函数，并且可以向暂停的地方传入值
生成器就是可以暂停的函数&lt;/p&gt;

&lt;h3 id=&quot;生成器进阶sendclosethrow&quot;&gt;生成器进阶send,close,throw&lt;/h3&gt;

&lt;p&gt;send&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def gen_func():
    #这种写法1.可以产出值 2.可以接受值
    html = yield &quot;http://www.baidu.com&quot;
    print(html)
    yield 2
    yield 3
    return 'fank'

#生成器不仅可以产生值，还可以接受值
if __name__ == '__main__':
    gen = gen_func()
    #启动生成器的方式有2种，1.next() 2.send
    print(next(gen))
    #send默认包含了next
    print(gen.send('fank'))
    print(next(gen))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;close&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def gen_func():
    #这种写法1.可以产出值 2.可以接受值
    try:
        yield &quot;http://www.baidu.com&quot;
    except GeneratorExit:
        pass
    yield 2
    yield 3
    return 'fank'

#生成器不仅可以产生值，还可以接受值
if __name__ == '__main__':
    gen = gen_func()
    #启动生成器的方式有2种，1.next() 2.send
    print(next(gen))
    gen.close()
    print(next(gen))

    #GeneratorExit是继承BaseException
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;throw&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def gen_func():
    #这种写法1.可以产出值 2.可以接受值
    try:
        yield &quot;http://www.baidu.com&quot;
    except GeneratorExit:
        pass
    yield 2
    yield 3
    return 'fank'

#生成器不仅可以产生值，还可以接受值
if __name__ == '__main__':
    gen = gen_func()
    #启动生成器的方式有2种，1.next() 2.send
    print(next(gen))
    gen.throw(Exception, 'download error') #没有向下执行，是当前yeild的异常
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;yield-from&quot;&gt;yield from&lt;/h4&gt;
&lt;p&gt;生成器实现协程是由程序员自己调度的，线程，进程由操作系统内核调度。协程是函数级别的&lt;/p&gt;

&lt;p&gt;yield from是python3.3之后新加入的语法&lt;/p&gt;

&lt;p&gt;python3.5之后的协程是原生协程，之前是利用生成器完成&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from itertools import chain

my_list = [1,2,3]
my_dict = {
    'fank':&quot;fankcoder.com&quot;,
    'fank1':&quot;fankcoder1.com&quot;,
    'fank2':&quot;fankcoder2.com&quot;
}

# yeild from 后面跟一个iterable
# 但远不止这些，如果yeild from 跟生成器
def my_chain(*args, **kwargs):
    for item in args:
        yield from item
        # for each in item:
        #     yield each

for value in my_chain(my_list, my_dict, range(5,10)):
    print(value)

def g1(gen):
    yield from gen

def main():
    g = g1
    g.send(None)

#1. main调用生成器 2.g1委托生成器 3.gen子生成器
#2. yield from 会在调用生成器和子生成器之间建立一个双向通道，
# 两者可以互通，现在调用生成器可以直接发送close,throw到子生成器

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;协程调度，事件循环+协程模式，协程是单线程模式.
编写时候凡是遇到耗io的操作，都用啥yield或yield from模式.
tornado是生成器生成的协程.&lt;/p&gt;

&lt;h4 id=&quot;async和await-原生协程&quot;&gt;async和await 原生协程&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#python3.5以后为了将语义变得更加明确，就引入了async和await关键词来定义原生协程
# async下不能再出现yield,同样await只能出现在async下
# await 后面跟的函数必须是awaitable也就是加了async的函数
import types

async def downloader(url):
    return 'fank'

# 另一种方法让函数变为awaitable，但是我没有试验成功。不过这种方法本来不推荐
@types.coroutine
def downloader2(url):
    return 'fank2'

async def download_url(url):
    # do something
    # await对应生成器的yield from
    html = await downloader2(url)
    return html

if __name__ == &quot;__main__&quot;:
    coro = download_url('http://www.google.com')
    # next(coro)  原生协程不能这样调用
    coro.send(None)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;asyncio模块&quot;&gt;asyncio模块&lt;/h3&gt;
&lt;p&gt;把它叫做异步Io库，并不叫协程库，这里包含了多线程，多进程，协程&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;包含各种特定系统实现的模块化事件循环&lt;/li&gt;
  &lt;li&gt;传输和协议抽象&lt;/li&gt;
  &lt;li&gt;对tcp,udp,ssl,子进程，延时调用以及其他的具体支持&lt;/li&gt;
  &lt;li&gt;模仿Futures模块但适用于事件循环适用的Future类&lt;/li&gt;
  &lt;li&gt;基于yield from的协议和任务，可以让你用顺序的方式编写并发代码&lt;/li&gt;
  &lt;li&gt;必须使用一个将产生阻塞io的调用时，哟接口可以把这个事件转移到线程池&lt;/li&gt;
  &lt;li&gt;模仿threading模块中的同步原语，可以用在单线程内的协程之间&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;asyncio 异步io并发编程 py3.4以后支持&lt;/p&gt;

&lt;p&gt;事件循环&lt;/p&gt;

&lt;p&gt;协程编码模式3个：1.事件循环 2.回调(驱动生成器) 3.epoll（io多路复用）&lt;/p&gt;

&lt;p&gt;应用：tornado, gevent, twisted(scrapy, django channels)&lt;/p&gt;

&lt;p&gt;ps: tornado不建议使用Pymysql,mysqlclient&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#事件循环+回调（驱动生成器）+epoll(IO多路复用)
#asyncio是Python用于解决异步io的一整套解决方案
#tornado,gevent,twisted(scrapy, dango channels(http2.0 websocket) 目前都是基于twisted)
#tornado(实现了web服务器)，django+flask(uwsgi,gunicorn+nginx)
#tornado可以直接部署，外加nginx

#asyncio
import asyncio
import time

async def get_html(url):
    print('start get html')
    #time.sleep()  #不能使用同步阻塞的方法
    await asyncio.sleep(2)  #耗时操作，io操作加await
    print('end get url')

if __name__ == &quot;__main__&quot;:
    start_time = time.time()
    loop  = asyncio.get_event_loop()  #事件循环，自动select
    tasks = [get_html('http://www.google.com') for i in range(10)]
    # loop.run_until_complete(get_html('http://www.google.com'))
    loop.run_until_complete(asyncio.wait(tasks))
    print('time:', time.time() - start_time)

#获取协程的返回值
from functools import partial

async def get_html(url):
    print('start get html')
    #time.sleep()  #不能使用同步阻塞的方法
    await asyncio.sleep(2)  #耗时操作，io操作加await
    return 'fank'

def callback(url, future): #partial url 要写在前面
    print(url)

if __name__ == &quot;__main__&quot;:
    start_time = time.time()
    loop  = asyncio.get_event_loop()  #事件循环，自动select
    # get_future = asyncio.ensure_future(get_html('http://www.google.com'))  #一个线程只有一个loop，这里ensure_future自动帮我们获取loop
    task = loop.create_task(get_html('http://www.google.com'))  #和上一句等效
    # loop.run_until_complete(get_html('http://www.google.com'))
    # task.add_done_callback(callback)
    #如过callback需要传参
    task.add_done_callback(partial(callback, 'http://www.googl.com'))

    # loop.run_until_complete(get_future)
    loop.run_until_complete(task)
    # print(get_future.result())
    print('time:', time.time() - start_time)

#wait 和gather的用法和区别
#gather更加高层，可以分组
async def get_html(url):
    print('start get html')
    #time.sleep()  #不能使用同步阻塞的方法
    await asyncio.sleep(2)  #耗时操作，io操作加await
    print('end get url')

if __name__ == &quot;__main__&quot;:
    start_time = time.time()
    loop  = asyncio.get_event_loop()  #事件循环，自动select
    group1 = [get_html('http://www.google.com') for i in range(10)]
    group2 = [get_html('http://www.google.com') for i in range(10)]
    # loop.run_until_complete(get_html('http://www.google.com'))
    group2.cancel() #批量取消
    loop.run_until_complete(asyncio.gather(*group1, *group2))
    print('time:', time.time() - start_time)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;取消task&quot;&gt;取消task&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# run_until_complete
import asyncio

# loop = asyncio.get_event_loop()
# loop.run_forever()  #不会停止，会一直运行
# loop.run_until_complete()  #运行了指定的协程之后会停止

async def get_html(sleep_times):
    print('waiting')
    await asyncio.sleep(sleep_times)
    print('done after {}'.format(sleep_times))

if __name__ == &quot;__main__&quot;:
    task1 = get_html(2)
    task2 = get_html(3)
    task3 = get_html(3)

    tasks = [task1, task2, task3]
    loop = asyncio.get_event_loop()

    try:
        loop.run_until_complete(asyncio.wait(tasks))
    except KeyboardInterrupt as e:
        all_tasks = asyncio.Task.all_tasks()
        for task in all_tasks:
            print('cancel task')
            print(task.cancel())
        loop.stop()
        loop.run_forever()  #很关键，不加会报错
    finally:
        loop.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;底层方法call_sooncall_latercall_at&quot;&gt;底层方法call_soon,call_later,call_at&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import asyncio

#可以给asyncio直接传递函数（不是async函数）
def callback(sleep_time):
    print('sleep {} success'.format(sleep_time))

def stoploop(loop):
    loop.stop()

if __name__ == &quot;__main__&quot;:
    loop = asyncio.get_event_loop()
    loop.call_soon(callback, 2)  #即刻执行，在队列里等到下一个循环立马执行
    loop.call_soon(stoploop, loop)

    loop.call_later(2,callback,2)  #在2秒钟之后运行callback
    loop.call_later(1,callback,1)
    loop.call_later(3,callback,3)

    now = loop.time()  #loop的time
    loop.call_at(now+2, callback, 2)
    loop.call_at(now+3, callback, 3)

    loop.call_soon_threadsafe()  #变量线程安全

    loop.run_forever()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;asynciothreadpollexecutor&quot;&gt;asyncio+ThreadPollExecutor&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#使用多线程:在协程中继承阻塞io(某些库就是阻塞的)
import asyncio
import socket
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor

def get_url(url):
    # get html by socket
    url = urlparse(url)
    host = url.netloc
    path = url.path
    if path == '':
        path = '/'
    
    #connect socket
    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client.connect((host, 80))
    client.send(&quot;GET {} HTTP/1.1\r\nHOST:{}\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode('utf8'))
    
    data = b''
    while True:
        d = client.recv(1024)
        if d:
            data += d
        else:
            break
    data = data.decode('utf8')
    htmldata = data.split('\r\n\r\n')[1]
    print(htmldata)

if __name__ == &quot;__main__&quot;:
    loop = asyncio.get_event_loop()
    executor = ThreadPoolExecutor(3)
    tasks = []
    for i in range(20):
        #参数1.线程池 2.函数名 3.函数参数
       task = loop.run_in_executor(executor, get_url, 'http://www.baidu.com/{}'.format(i))  #将某个阻塞Io函数放入executor中运行
       tasks.append(task)
    loop.run_until_complete(asyncio.wait(tasks))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;同步的方式实现异步http模拟请&quot;&gt;同步的方式实现异步http模拟请&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#asyncio没有提供http协议的接口；aiohttp异步的requests，可以启动服务器，可以爬虫
#同步的方式实现异步http模拟请求
import asyncio
import socket
from urllib.parse import urlparse

async def get_url(url):
    # get html by socket
    url = urlparse(url)
    host = url.netloc
    path = url.path
    if path == '':
        path = '/'
    
    #connect socket
    reader, writer = await asyncio.open_connection(host, 80)  #线程
    writer.write(&quot;GET {} HTTP/1.1\r\nHOST:{}\r\nConnection:close\r\n\r\n&quot;.format(path, host).encode('utf8'))
    
    all_lines = []
    async for raw_line in reader:  #异步化，因为内部有yield from语法
        data = raw_line.decode('utf8')
        all_lines.append(data)

    html = '\n'.join(all_lines)
    return html

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    tasks = []
    for i in range(20):
        url = 'http://www.baidu.com/{}'.format(i)
        tasks.append(asyncio.ensure_future(get_url(url)))
    loop.run_until_complete(asyncio.wait(tasks))
    for task in tasks:
        print(task.result()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;asyncio同步和通信&quot;&gt;asyncio同步和通信&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import asyncio
from asyncio import Lock,Queue
queue = Queue()
await queue.get()
queue1 = [] #普通的全局变量也能用，但是不能控制Size流量

cache = {}
lock = Lock()

async def get_stuff(url):
    async with lock:
        # await lock.acquire()  #async 
        if url in cache:
            return cache[url]
        stuff = await aiohttp.request('get', url)
        cache[url] = stuff
        return stuff
        # lock.release()  #不需要await

async def parse_stuff():
    stuff = await get_stuff()

async def use_stuff():
    stuff = await get_stuff()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;aiohttp实现高并发爬虫&quot;&gt;aiohttp实现高并发爬虫&lt;/h3&gt;

&lt;h4 id=&quot;aiohttp&quot;&gt;aiohttp&lt;/h4&gt;
&lt;p&gt;HTTP client/server framework for asyncio&lt;/p&gt;

&lt;p&gt;server可以搭建http服务器&lt;/p&gt;

&lt;h3 id=&quot;client爬虫&quot;&gt;client爬虫&lt;/h3&gt;
&lt;p&gt;爬取Url
抽取内部Url
过滤
反爬
分布式&lt;/p&gt;

&lt;h4 id=&quot;sanic&quot;&gt;sanic&lt;/h4&gt;
&lt;p&gt;号称可以媲美go性能的高并发web服务器&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2019/01/12/threading-python.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2019/01/12/threading-python.html</guid>
        
        <category>python,thread</category>
        
        
        <category>技术</category>
        
      </item>
    
  </channel>
</rss>
