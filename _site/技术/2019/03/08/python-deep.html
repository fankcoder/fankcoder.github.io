<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" /> <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]--> <title>Python深入学习笔记</title> <meta name="description" content="type,object和class的关系"> <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600|Droid+Sans+Mono' rel='stylesheet' type='text/css'> <link rel="stylesheet" href="/css/main.css"> <link rel="canonical" href="http://localhost:4000/%E6%8A%80%E6%9C%AF/2019/03/08/python-deep.html"> <link rel="alternate" type="application/rss+xml" title="Fank" href="http://localhost:4000/feed.xml" /> <script src="/assets/js/prefixfree.js"></script> </head> <body> <aside id="sidebar"> <div id="sidebar-left"> <a id="sidebar-avatar" href="/"> <img id="sidebar-avatar-img" alt="" src="/assets/img/avatar.jpg"/> </a> <div id="sidebar-social"> <a href="/feed.xml" class="sidebar-social-icon feed"></a> <a href="mailto:fankcoder@gmail.com" class="sidebar-social-icon email"></a> <a href="http://www.weibo.com/u/2424646683" class="sidebar-social-icon weibo" target="_blank"></a> <a href="https://github.com/fankcoder" class="sidebar-social-icon github" target="_blank"></a> </div> <ul id="sidebar-tags"> <li class="sidebar-tag active" data-filter="all">全部文章</li> <li class="sidebar-tag" data-filter="备忘">备忘</li> <li class="sidebar-tag" data-filter="工具">工具</li> <li class="sidebar-tag" data-filter="技术">技术</li> <li class="sidebar-tag" data-filter="About">About</li> </ul> </div> <div id="sidebar-right"> <div id="search-box"> <input id="search-input" type="text" placeholder="Search" /> </div> <nav id="toc"> <a class="toc-link" data-tags="工具" href="/%E5%B7%A5%E5%85%B7/2019/03/08/vscode.html"> vscode配置手册 </a> <a class="toc-link" data-tags="工具" href="/%E5%B7%A5%E5%85%B7/2019/03/08/mac-tools.html"> mac使用手册 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2019/03/08/python-deep.html"> Python深入学习笔记 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2019/03/08/appspider-tools.html"> Ubuntu&OSX的app抓包方案 </a> <a class="toc-link" data-tags="About" href="/about/2019/03/08/HeyUFindMe.html"> Hey, U find me! </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/11/01/chmod.html"> chmod命令 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/03/10/screen-linux.html"> screen工具 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/03/08/todolist-django-python.html"> Todolist 应用 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2016/03/04/general-linux-resources.html"> Linux 常用资源 </a> <a class="toc-link" data-tags="工具" href="/%E5%B7%A5%E5%85%B7/2016/01/28/good-tools.html"> 神器收藏 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2016/01/27/general-django-resource.html"> Django命令备忘录 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/01/25/amazon-spider-python.html"> 爬虫防屏蔽 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/01/20/add-static-django-python.html"> Django添加静态文件 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/01/12/threading-python.html"> Python 多线程 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/01/11/encode-python.html"> Python转码问题 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/12/29/xrange-python.html"> Python的xrange和range </a> <a class="toc-link" data-tags="工具" href="/%E5%B7%A5%E5%85%B7/2015/11/10/vpn-tools.html"> 科学上网列表 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/10/26/email-shell-linux.html"> Shell每日发邮件 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/10/13/passwd-python.html"> Python密码处理 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/10/12/os-python.html"> Python标准库os </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/08/25/re-python.html"> Python正则 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/08/11/func-python.html"> Python内置函数(map、reduce、filter) </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/07/25/awk-linux.html"> AWK </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/07/24/blog-django-python.html"> Django练习项目之搭建博客 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/05/22/xlrd-python.html"> 用xlrd\xlwt读写excel </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/01/01/chromium-flash-linux.html"> chromium安装flash </a> <a class="toc-link" data-tags="工具" href="/%E5%B7%A5%E5%85%B7/2014/12/24/ubuntu-tools.html"> Ubuntu常用 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/09/15/general-git-resources.html"> Git 常用命令 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/05/11/general-mysql-resources.html"> MySQL常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/04/23/general-bootstrap-resources.html"> Bootstrap常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/01/15/general-svn-resources.html"> SVN 常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/01/15/general-shell-resources.html"> Shell 常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/01/15/general-python-resources.html"> Python 常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/01/15/general-jquery-resources.html"> jQuery 常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/01/15/general-javascript-resources.html"> JavaScript 常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/01/15/general-html-resources.html"> HTML 常用 </a> </nav> </div> </aside> <main id="main"> <article class="post container"> <div class="post-meta"> <span class="post-meta-span date">2019 March 08</span> <span class="post-meta-span tag">python</span> </div> <h1 class="post-title">Python深入学习笔记</h1> <h3 id="typeobject和class的关系">type,object和class的关系</h3> <p>type(int) -&gt; class type -&gt; obj</p> <p>type -&gt; int -&gt; 1</p> <p>type生成类对象，类对象生成实例对象</p> <p>int.<strong>bases</strong> class ‘object’</p> <p>基类均为class object, object是最顶层基类。</p> <p>type.<strong>bases</strong> class ‘object’ type继承obj</p> <p>type(object) class ’type’ obj是type的实例, 形成环路</p> <p>object.<strong>bases</strong> None</p> <h3 id="内置类型">内置类型</h3> <p>对象3个特征:</p> <ol> <li>身份id(a)</li> <li>2.类型type</li> <li>3.值</li> </ol> <p>None全局唯一</p> <p>数值int, float,complex复数,bool</p> <p>迭代类型</p> <p>序列类型 list,bytes,range,tuple,str,array</p> <p>映射类型 dict</p> <p>集合 set , frozenset</p> <p>上下文管理器 with</p> <p>其他 模块from import,class,object,type</p> <h3 id="魔法函数">魔法函数</h3> <p>以双下划线开头，双下划线结尾。可以定制类的特性</p> <p><strong>iter</strong>,__getitem__实现了都是可迭代的</p> <p>def <strong>getitem</strong>(self, item):</p> <p>return self._list[item]</p> <p>拆包，给长度数量的变量给他们赋值</p> <h3 id="鸭子类型和多态">鸭子类型和多态</h3> <p>当一只鸟，走路，游泳，叫起来都像鸭子，那么这只鸟就可以被叫做鸭子 都实现了同一种方法，所以可以归为一类，不需要继承，只需要实现同方法，就可以实现多态</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Cat(object):
    def say(self):
        print(‘im a cat’)

class Dog(object):
    def say(self):
        print(‘im a dog’)


animal = Cat
animal().say()

animal_list = [Cat, Dog]
for animal in animal_list:
    animal().say()
</code></pre></div></div> <h3 id="抽象基类abc模块">抽象基类abc模块</h3> <p>检查某个类是否有某种方法</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Company(object):
    def __init__(self, employee_list):
        self.employee = employee_list

    def __len__(self):
        return len(self.employee)

com = Company([‘bob1’,’bob2’])
print(hasattr(com, ‘__len__’) #检验类是否具有该方法
# print(len(com))
</code></pre></div></div> <h3 id="抽象基类abc模块-1">抽象基类abc模块</h3> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from collections.abc import Sized
isinstance(com, Sized) # 判断类型
import abc

class CacheBase(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def get(self, key):
        pass

    @abc.abstractmethod
    def set(self, key, value):
        pass

class RedisCache(CacheBase):
    pass

redis_cache = REdisCache()  
#会报错，这里abstractmethod要求被继承的类，必须实现get,set
</code></pre></div></div> <p>判断继承用isinstance()不要用type()</p> <h4 id="类变量和实力变量">类变量和实力变量</h4> <p>类中的self是类的实例</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class A:
    aa = 1 #类变量
    def __init__(self, x, y):
        self.x = x
        self.y = y  #实例变量
a = A(2,3)
A.aa = 11 #修改类变量
a.aa = 100 #新建变量
print(a.x, a.y, a.aa)
print(A.a)
print(A.x) #error
</code></pre></div></div> <p>self是类的实例，类变量和类实例变量的区别</p> <p>__mro__查找。DFS深度优先，对菱形继承有问题，BFS广度优先也有覆盖问题，py3用C3算法</p> <p>@staticmethod静态方法，和普通函数一样，不需要写self参数</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Data:
    @staticmethod
    def parse_from_string(date_str):
        year, month, day = tuple(date_str)
        return Date(year, month, day)  #静态方法硬编码，返回值必须与类名相同
</code></pre></div></div> <p>@classmethod类方法，第一参数是类本身cls，返回值不需要与类同名</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@classmethod
    def from_string(cls, date_str):  #cls传递的是类本身，不是实例
        year, month, day = tuple(date_str)
        return cls(year, month, day)  #写为cls,变为动态不必与类名相同
#cls是习惯性写法，在这里甚至可以写为self
</code></pre></div></div> <h3 id="类的私有属性">类的私有属性</h3> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>self.__birthday双下划线开头，但并不绝对安全，_User__birthday依然可以访问到
class User:
    def __init__(self):
        self.__birthday = birthday  #无法被访问
    def get_age(self):
        return 2019 - self.__birthday.year
    def __get_other(self):  #私有方法
        pass
user = User(Date(1992,9,28))
user._User__birthday  #py帮助我们使用这种简单方式封装，找到规律就可以访问
</code></pre></div></div> <h3 id="自省机制">自省机制</h3> <p>自省是通过一定的机构查询到对象的内部结构</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Person:
    name = ‘user’

clss Student(Person):
    def __init__(self, school_name):
        self.school_name = ‘'
user = Student(‘abc’)
print(user.__dict__)  #打印实例属性，{’school_name’:abc}.c优化的魔法函数
print(Person.__dict__) #类属性
user.__dict__[’school_addr’] = ‘efg’  #甚至可以赋值
dir(user)  #更详细，功能更强
</code></pre></div></div> <h3 id="super">super</h3> <p>获取父类init (其实是mro顺序的类，查看方法classname.<strong>mro</strong>)</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class A:
    def __init__(self):
        print(‘a’)

class B(A):
    def __init__(self):
        print(‘b’)
        super(b, self).__init__() # py2
        super().__init__() # py3

b = B()

from threading import Thread
class MyThread(Thread):
    def __init__(self, name, user):
        self.user = user
        super().__init__(name=name)  #重用父类代码
</code></pre></div></div> <h3 id="mixin模式">mixin模式</h3> <p>多继承不推荐，mixin代替多继承 特点：</p> <ol> <li>Mixin类功能单一</li> <li>不和基类关联，可以和任意基类组合</li> <li>在mixin中不要使用supper</li> </ol> <h3 id="with上下文管理器">with上下文管理器</h3> <h3 id="collections">collections</h3> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from collections import *

from collections.abc import * #抽象基类
</code></pre></div></div> <p>tuple不可修改并不绝对。tuple值为list可以修改(id没变，不建议这样使用)</p> <p>tuple比list好处，c语音类比，tuple对应struct,list对应array.性能优化，线程安全，可以作为dict的key,拆包特性。</p> <p>namedtuple可以生成类，User = namedtuple(“User”,[‘name’,’age’])</p> <p>节省空间，用于数据处理，从数据库取数据为tuple，直接赋值</p> <h3 id="def-askargs-kwargspass">def ask(*args, **kwargs):pass</h3> <p>ask(‘f’,25) 传给*args, ask(name=’f’, age=25)传给**kwargs</p> <p>*args是个tuple, **kwargs是个dict</p> <p>_make方法初始化，_asdict()</p> <p>from collections import defaultdict C语言实现，性能高,比setdefault更强大</p> <p>default_dict = defaultdict(int) 参数是可调用对象</p> <p>default_dict[‘key’] #key=0</p> <h3 id="deque双端队列">deque双端队列</h3> <p>应用场景queue是由deque来完成的。deque是线程安全到，list不是线程安全的，由GIL保护。</p> <p>from collections import deque</p> <p>copy是浅拷贝，如果值为list会相互影响</p> <p>counter(iterm) 快速统计,counter.update().most_common(n)出现最多到前n个,使用堆实现(完全二叉树)</p> <h3 id="orderdict是有序的">OrderDict是有序的</h3> <p>py3的dict默认是有序的。</p> <p>_d = OrderedDict() _d.popitem()不需要传key _d.move_to_end()</p> <h3 id="chainmap">ChainMap</h3> <p>方便操作多个dict. 将dict连结,key相同只有一个。</p> <p>from collections import ChainMap</p> <p>new_dict = ChainMap(_d1, _d2)</p> <p>new_dict.maps全部打印，同样可以修改</p> <h3 id="类和对象">类和对象</h3> <p>type() object</p> <p>魔法函数</p> <p>hasattr(param,”<strong>len</strong>”) 判断是否有这个函数，用isinstance()更好</p> <p>希望用户继承时必须实现方法</p> <p>class CacheBase():</p> <p>def get(self, key):raise NotImplementedError</p> <p>def set(self, key, value):pass</p> <h3 id="is-和-">is 和 ==</h3> <p>is判断id是否相同</p> <p>==判断值</p> <p>isinstance 和type，判断类的类型尽量用isinstance</p> <p>try.. excepte..finally(始终运行)..</p> <p>上下文管理器协议 with语句 先调用__enter__最后调用__exit__</p> <p>### contextlib</p> <p>contextlib简化上下文管理 ,使用装饰器将函数变为上下文管理器</p> <p>import contextlib</p> <p>@contextlib.contextmanager</p> <p>def file_open(file_name):</p> <p>… yield {} …</p> <h3 id="自定义序列类">自定义序列类</h3> <p>容器序列，扁平序列，可变序列sequence，不可变序列mutable</p> <p>python面向协议编程 in可以作用于list</p> <p>+,-,extend</p> <p>+=就地加参数可以为任意序列，通过for循环append</p> <p>切片[start : end : step]，默认值可省略[0,len(L),1].</p> <p>bisect处理已排序序列，二分查找。插入排序好的数列bisect.insort(list, 5).查找位置插入bisect.bisect(list, 3)</p> <p>array和list重要区别，array只能存放指定的数据类型。布隆过滤器。</p> <p>推导式&amp;表达式，列表生成式性能能高于列表操作</p> <p>odd_list = [i for i in range(21) if i%2 == 1]</p> <p>odd_list = (i for i in range(21) if i%2 == 1)生成器表达式为小括号</p> <p>my_dict ={‘a’:1, ‘b’:2}</p> <p>_reversed = {value:key for key, value in my_dict.items()}</p> <h3 id="深入set和dict">深入set和dict</h3> <p>浅拷贝a.copy()</p> <p>深拷贝import copy</p> <p>copy.deepcopy(a)</p> <p>_dict.get(“a”, {}) get</p> <p>setdefault(key, default)先get()，没有则设置默认</p> <p>_dict.update(“a”=1,”b”=2) 也可以放tuple</p> <p>set和fronzenset(不可变)无序，不重复，fset可以做为dict的key</p> <p>dict 查哈希表，key必须为可哈希的值。str,fset,tuple,自己实现的类</p> <p>dict的内存花销大，查询速度快</p> <p>垃圾回收算法是采用引用计数 del</p> <h3 id="元类编程">元类编程</h3> <p>property动态属性，User.age可以取属性，不用调函数，类似get，set为@age.setter</p> <p>@propery</p> <p>def age(self):</p> <p>return age.year</p> <h3 id="__getattr__与__getattribute__的区别">__getattr__与__getattribute__的区别</h3> <p>__getattr__在查找不到属性的时候调用(写了就不会报错).维护dict动态访问key</p> <p>def <strong>getattr</strong>(self, item): return “not find”</p> <p>def <strong>getattribute</strong>(self, item): return “true” 无条件进入这个函数，控制全局属性访问</p> <p>属性描述符实现__get__,<strong>set</strong>,<strong>delete</strong></p> <p>数据描述符，非数据描述符</p> <p>属性查找过程</p> <p>传递方法为变化的user.age方式无法实现， 使用getattr(user, age)</p> <h3 id="__new__和__init__区别">__new__和__init__区别</h3> <p>def <strong>new</strong>(cls, *args, **kwargs):pass new传递类，在init之前，new控制对象的生成过程，如果new不返回对象，不会调用init函数</p> <p>type是默认元类，metaclass是自定义元类，可以控制实例化过程</p> <h3 id="迭代器和生成器">迭代器和生成器</h3> <p>迭代器是访问集合内元素的一种方式，一般用来遍历数据。</p> <p>迭代器和以下标的访问方式不一样，迭代器是不能返回的，迭代器提供一种惰性方式。</p> <p>__iter__迭代协议，可迭代的实现方法</p> <p>from collections.abc import Iterable,Iterator</p> <p>iter([_list])迭代器</p> <p>def <strong>iter</strong>(self) / def <strong>getitem</strong>(self, item)</p> <p>next(itor)接受迭代器，迭代器next无法切片。文件太大使用迭代器读数据</p> <p>生成器函数，函数内有yield关键字</p> <p>def gen_func(): yield 1 yield2 yield3</p> <p>gen = gen_func() #gen生成器对象，不是值</p> <p>for i in gen: print(i) 惰性求值提供了可能，比list好处是省内存</p> <p>查看字节码，import dis dis.dis(func)</p> <h3 id="socket编程">socket编程</h3> <p>import socket</p> <p>server = socket.socket()</p> <p>server.bind((‘0.0.0.0’, 8000))</p> <p>server.listen()</p> <p>sock, addr = server.accept()</p> <p>data = server.recv(1024) #1kb</p> <h3 id="多线进程">多线、进程</h3> <p>global interpreter lock GIL</p> <p>python中一个线程对应于c中的线程</p> <p>gil使得同一时刻只有一个线程在一个cpu上执行字节码</p> <p>为了安全，但速度慢，无法体现多核优势。pypy是去gil化的。gil在遇到io操作会主动释放</p> <p>操作系统调度的最小单元线程，对于io操作，多线程和多进程差别不大。</p> <p>1.通过thread类实例化</p> <p>thread1 = threading.Thread(target=func, args=(“”,))</p> <p>thread1.setDaemon(True)#设置为守护线程。当主线程关闭时，子线程被kill</p> <p>thread1.join() #阻塞，等待执行完</p> <ol> <li>通过继承thread来实现多线程</li> </ol> <p>class GetDetailHtml(threading.Thread):</p> <p>def run(self):</p> <p>pass</p> <p>thread1 = GDH()</p> <p>thread1.start()</p> <h3 id="线程之间的通信方式">线程之间的通信方式</h3> <p>1.共享全局变量(list)（多线程可以，多进程不行）</p> <p>这种方法，线程并不安全，需要加gil锁，所以并不推荐用作通信</p> <p>2.通过queue方法进行线程间同步,queue本身是线程安全的</p> <p>from queue import Queue</p> <p>detail_url_queue = Queue(maxsize=1000)</p> <p>url = queue.get()#阻塞方法，如果为空就一直停顿等待</p> <p>queueq.put_nowait()#设置为非阻塞</p> <p>.join()一直阻塞，想退出需要调用.task_down() #爬虫暂停</p> <p>如果共用变量为dict或其他，考虑使用全局变量</p> <h3 id="线程同步lock-rlock">线程同步（lock, rlock）</h3> <p>from threading import Lock</p> <p>lock = Lock()</p> <p>global lock</p> <p>lock.acquire()</p> <p>a +=1</p> <p>lock.release()</p> <ol> <li>用锁会影响性能</li> </ol> <p>2.锁会引起死锁（互相等待）</p> <p>rlock可重入的锁，在同一个线程里面，可以连续调用多次acquire，需要相等数量的release.</p> <h3 id="condition条件变量用于复杂的线程间同步锁">condition条件变量，用于复杂的线程间同步锁</h3> <p>from threading import Condition</p> <p>self.cond.acquire()</p> <p>print()</p> <p>self.cond.notify()</p> <p>self.cond.wait()</p> <p>self.release()</p> <p>with self.cond = acquire()/release()</p> <p>在调用with之后，才能使用notify, wait</p> <p>condition有两层锁，一把底层锁会在线程调用wait方法的时候释放，上面的锁会值每次调用wait时分配一把并放入到cond的等待队列中，等到notify方法唤醒</p> <h3 id="semaphore-是用于控制进入数量的锁">Semaphore 是用于控制进入数量的锁</h3> <p>#文件读写，写一搬只用一个线程，读可以允许有多个</p> <p>sem = threading.Semaphore(3)</p> <p>self.sem.acquire()</p> <p>self.sem.release() #在另一个函数release，每次3个线程</p> <p>线程池concurrent #py3.2</p> <p>from concurrent import futures</p> <p>1.主线程中可以获取某一个线程的状态或者某一个任务的状态，以及返回值</p> <p>2.当一个线程完成的时候，主线程能立即知道</p> <p>3.futures可以让多线程多进程编码接口一致</p> <p>from concurrent.futures import ThreadPoolExecutor</p> <p>executor = ThreadPoolExecutor(max_workers=2)</p> <p>task1 = executor.submit(get_html, (3))</p> <p>print(task1.done()) #done用于判定某个任务是否完成</p> <p>print(task1.result()) #阻塞的方法，可以获取执行结果</p> <p>task2.cancel()#取消</p> <p>#获取已经成功的task返回</p> <p>urls = [3,2,3]</p> <p>from concurrent.futures import as_completed</p> <p>all_task = [executor.submit(get_html, (url)) for url in urls]</p> <p>for future in as_complete(all_task):</p> <p>data = future.result()</p> <p>简化版,但返回顺序是urls，并不是谁先完成返回谁</p> <p>for data in executor.map(get_html, urls):</p> <p>print(data)</p> <h3 id="多进程">多进程</h3> <p>线程由于有gil无法并发，io操作进程切换代价高于线程。</p> <p>耗cpu的操作，多核cpu，多进程优于多线程。</p> <p>进程数据完全隔离,无法使用共享全局变量</p> <p>子进程完全拷贝Fork之后的父进程代码运行</p> <p>from concurrent.futures import ProcessPoolExecutor</p> <p>import multiproessing #比上面更底层，但不推荐</p> <p>def get_html(n):</p> <p>time.sleep(n)</p> <p>return n</p> <p>if <strong>name</strong> == ‘<strong>main</strong>’:</p> <p>progress = multiprocessing.Process(target=get_html, args=(2,))</p> <p>progress.start()</p> <p>progress.join()</p> <p>queue不能直接用于进程池通信，pool中的通信要使用manager.queue</p> <p>通过pipe实现进程通信</p> <p>recevie_pipe, send_pipe = Pipe()</p> <p>#pipe只适用与两个进程</p> <h3 id="协程-有多个入口的函数可以暂停的函数可以向暂停的地方传值">协程 （有多个入口的函数，可以暂停的函数，可以向暂停的地方传值）</h3> <p>python3.5之后的协程是原生协程，之前是利用生成器完成</p> <p>生成器不只可以产出值，还可以接受值send()</p> <p>send()是协程的基础</p> <p>throw()扔异常</p> <p>yield from iterable</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
from itertools import chain

for value in chain(list, dict, range(5))

def my_chain(*args, **kwaags):

for my_iterable in args:

yield from iterable

# for value in my_iterable:

# yield value

</code></pre></div></div> <h3 id="原生协程-async和await-e-sing-k">原生协程 async和await e sing k</h3> <p>asyncio 异步io并发编程 py3.4以后支持</p> <p>事件循环</p> <p>协程编码模式3个：1.事件循环 2.回调(驱动生成器) 3.epoll（io多路复用）</p> <p>应用：tornado, gevent, twisted(scrapy, django channels)</p> <p>ps: tornado不建议使用Pymysql,mysqlclient</p> <p>获取协程的返回值</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import asyncio

loop = asyncio.get_event_loop()

loop.run_forever()

loop.run_until_complate()
</code></pre></div></div> <p>1.loop会放到future中</p> <p>2.取消future(task)</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>async def get_html():

await asyncio.sleep(sleep_times)
</code></pre></div></div> </article> <div class="post-share"> <div class="container"> <a href="https://twitter.com/share?url=http://localhost:4000/%E6%8A%80%E6%9C%AF/2019/03/08/python-deep.html&text=Python深入学习笔记" target="_blank" class="post-share-icon twitter"></a> <a href="https://www.evernote.com/clip.action?url=http://localhost:4000/%E6%8A%80%E6%9C%AF/2019/03/08/python-deep.html&title=Python深入学习笔记" target="_blank" class="post-share-icon evernote"></a> <a href="http://service.weibo.com/share/share.php?url=http://localhost:4000/%E6%8A%80%E6%9C%AF/2019/03/08/python-deep.html&title=Python深入学习笔记" target="_blank" class="post-share-icon weibo"></a> </div> </div> <div class="footer"> <div class="container"> <p class="footer-entry">All content is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA</a></p> <p class="footer-entry">Buit with <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> and <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll theme</a> • Hosted on <a href="https://pages.github.com/" target="_blank">Github</a></p> </div> </div> </main> <button id="menu"> <span id="menu-icons"></span> </button> <script src="/assets/js/jquery-2.1.3.min.js"></script> <script src="/assets/js/jquery.pjax.js"></script> <script src="/assets/js/nprogress.js"></script> <script src="/assets/js/main.js"></script> </body> </html>
