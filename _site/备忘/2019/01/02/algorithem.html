<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" /> <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]--> <title>算法&数据结构</title> <meta name="description" content="数据结构"> <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600|Droid+Sans+Mono' rel='stylesheet' type='text/css'> <link rel="stylesheet" href="/css/main.css"> <link rel="canonical" href="http://localhost:4000/%E5%A4%87%E5%BF%98/2019/01/02/algorithem.html"> <link rel="alternate" type="application/rss+xml" title="Fank" href="http://localhost:4000/feed.xml" /> <script src="/assets/js/prefixfree.js"></script> </head> <body> <aside id="sidebar"> <div id="sidebar-left"> <a id="sidebar-avatar" href="/"> <img id="sidebar-avatar-img" alt="" src="/assets/img/avatar.jpg"/> </a> <div id="sidebar-social"> <a href="/feed.xml" class="sidebar-social-icon feed"></a> <a href="mailto:fankcoder@gmail.com" class="sidebar-social-icon email"></a> <a href="http://www.weibo.com/u/2424646683" class="sidebar-social-icon weibo" target="_blank"></a> <a href="https://github.com/fankcoder" class="sidebar-social-icon github" target="_blank"></a> </div> <ul id="sidebar-tags"> <li class="sidebar-tag active" data-filter="all">全部文章</li> <li class="sidebar-tag" data-filter="备忘">备忘</li> <li class="sidebar-tag" data-filter="工具">工具</li> <li class="sidebar-tag" data-filter="技术">技术</li> <li class="sidebar-tag" data-filter="生活">生活</li> <li class="sidebar-tag" data-filter="About">About</li> </ul> </div> <div id="sidebar-right"> <div id="search-box"> <input id="search-input" type="text" placeholder="Search" /> </div> <nav id="toc"> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2019/04/04/general-docker.html"> Docker 常用 </a> <a class="toc-link" data-tags="工具" href="/%E5%B7%A5%E5%85%B7/2019/04/02/ss_config.html"> 第N次折腾vps科学上网，解决方案笔记 </a> <a class="toc-link" data-tags="工具" href="/%E5%B7%A5%E5%85%B7/2019/03/08/vscode.html"> vscode配置手册 </a> <a class="toc-link" data-tags="工具" href="/%E5%B7%A5%E5%85%B7/2019/03/08/mac-tools.html"> mac使用手册 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2019/03/08/python-deep.html"> Python深入学习笔记 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2019/03/08/appspider-tools.html"> Ubuntu&OSX的app抓包方案 </a> <a class="toc-link" data-tags="About" href="/about/2019/03/08/HeyUFindMe.html"> Hey, U find me! </a> <a class="toc-link" data-tags="工具" href="/%E5%B7%A5%E5%85%B7/2019/02/01/vim.html"> vim使用手册 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2019/01/15/general-javascript-resources.html"> JavaScript 常用资源 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2019/01/12/threading-python.html"> Python线程&进程&协程&asyncio </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2019/01/02/algorithem.html"> 算法&数据结构 </a> <a class="toc-link" data-tags="生活" href="/%E7%94%9F%E6%B4%BB/2019/01/01/life-time-manage.html"> 时间和人生感悟 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/11/01/chmod.html"> chmod命令 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/03/10/screen-linux.html"> screen工具 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/03/08/todolist-django-python.html"> Todolist 应用 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2016/03/04/general-linux-resources.html"> Linux 常用资源 </a> <a class="toc-link" data-tags="工具" href="/%E5%B7%A5%E5%85%B7/2016/01/28/good-tools.html"> 神器收藏 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2016/01/27/general-django-resource.html"> Django命令备忘录 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/01/25/amazon-spider-python.html"> 爬虫防屏蔽 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/01/20/add-static-django-python.html"> Django添加静态文件 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2016/01/11/encode-python.html"> Python转码问题 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/12/29/xrange-python.html"> Python的xrange和range </a> <a class="toc-link" data-tags="工具" href="/%E5%B7%A5%E5%85%B7/2015/11/10/vpn-tools.html"> 科学上网列表 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/10/26/email-shell-linux.html"> Shell每日发邮件 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/10/13/passwd-python.html"> Python密码处理 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/10/12/os-python.html"> Python标准库os </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/08/25/re-python.html"> Python正则 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/08/11/func-python.html"> Python内置函数(map、reduce、filter) </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/07/25/awk-linux.html"> AWK </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/07/24/blog-django-python.html"> Django练习项目之搭建博客 </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/05/22/xlrd-python.html"> 用xlrd\xlwt读写excel </a> <a class="toc-link" data-tags="技术" href="/%E6%8A%80%E6%9C%AF/2015/01/01/chromium-flash-linux.html"> chromium安装flash </a> <a class="toc-link" data-tags="工具" href="/%E5%B7%A5%E5%85%B7/2014/12/24/ubuntu-tools.html"> Ubuntu常用 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/09/15/general-git-resources.html"> Git 常用命令 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/05/11/general-mysql-resources.html"> MySQL常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/04/23/general-bootstrap-resources.html"> Bootstrap常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/01/15/general-svn-resources.html"> SVN 常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/01/15/general-shell-resources.html"> Shell 常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/01/15/general-python-resources.html"> Python 常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/01/15/general-jquery-resources.html"> jQuery 常用资源 </a> <a class="toc-link" data-tags="备忘" href="/%E5%A4%87%E5%BF%98/2014/01/15/general-html-resources.html"> HTML 常用 </a> </nav> </div> </aside> <main id="main"> <article class="post container"> <div class="post-meta"> <span class="post-meta-span date">2019 January 02</span> <span class="post-meta-span tag">algorithem</span> </div> <h1 class="post-title">算法&数据结构</h1> <h1 id="数据结构">数据结构</h1> <h2 id="data">Data</h2> <h4 id="array">Array</h4> <p>「数组」。连续的记忆体。搜寻、插入、删除的时间复杂度都是O(N) 。资料已排序，则支援二分搜寻。</p> <h4 id="list--linked-list-">List （ Linked List ）</h4> <p>「链表」。藉由指标得到下一块记忆体。</p> <p>搜寻的时间复杂度是O(N) 。知道正确位置，插入与删除的时间复杂度是O(1) ，否则必须先搜寻。无索引值，故不支援二分搜寻。</p> <h4 id="特殊的list">特殊的List</h4> <p>尾串到头，头尾循环，称作Circular List 。特色是开头可以随便选、随便动。 只串单向，称作Singly Linked List 。双向都串，称作Doubly Linked List ，特色是双向都能搜寻。</p> <h4 id="list-里面放入array">List 里面放入Array</h4> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>英文网路称做Unrolled Linked List ，中文网路称作「松散链表」、「块状链表」。查无正式学术名称。

N 笔资料，分成A 块，每块约B = N/A 个元素。每块各自记录元素数量。

索引：先数块、再数元素，时间复杂度为O(A) 。

搜寻：全找，时间复杂度为O(N) 。资料已排序，则为O(A + logB) 。

插入、删除：一块大于等于2B 就拆开成两块，相邻两块小于等于B 就合并成一块，避免一拆开就要合并、一合并就要拆开，时间复杂度为O(A + 2B) 到O(2A + B) 。
</code></pre></div></div> <h4 id="array-里面放入list">Array 里面放入List</h4> <p>大致上就是图论的Adjacency Lists 。</p> <p>大致上就是之后提到的Hash Table 。</p> <h2 id="binary-tree---二叉树">Binary Tree - 二叉树</h2> <p>二叉树是每个节点最多有两个子树的树结构，子树有左右之分，二叉树常被用于实现二叉查找树和二叉堆。</p> <h4 id="遍历">遍历</h4> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None

class Traversal(object):
    def __init__(self):
        self.traverse_path = list()

    def preorder(self, root):
        if root:
            self.traverse_path.append(root.val)
            self.preorder(root.left)
            self.preorder(root.right)

    def inorder(self,root):
        if root:
            self.inorder(root.left)
            self.traverse_path.append(root.val)
            self.inorder(root.right)

    def postorder(self,root):
        if root:
            self.postorder(root.left)
            self.postorder(root.right)
            self.traverse_path.append(root.val)
</code></pre></div></div> <h4 id="二叉查找树">二叉查找树</h4> <p>一颗二叉查找树(BST)是一颗二叉树，其中每个节点都含有一个可进行比较的键及相应的值，且每个节点的键都大于等于左子树中的任意节点的键，而小于右子树中的任意节点的键。</p> <p>使用中序遍历可得到有序数组，这是二叉查找树的又一个重要特征。</p> <h2 id="queue">Queue</h2> <p>「队列」像排队，维持资料前后顺序。插入、删除需时O(1) 。搜寻需时O(N) 。 Queue 是一个 FIFO（先进先出）的数据结构，并发中使用较多，可以安全地将对象从一个任务传给另一个任务。</p> <h4 id="deque--double-ended-queue-">Deque （ Double Ended Queue ）</h4> <p>两头皆能插入与删除，称作Deque ，同时有着Stack 和Queue 的功效。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dq = collections.deque();
dq.appendleft(e)
dq.append(e)
dq.popleft()
dq.pop()
</code></pre></div></div> <h2 id="heap---堆">Heap - 堆</h2> <p>一般情况下，堆通常指的是二叉堆，二叉堆是一个近似完全二叉树的数据结构，但由于对二叉树平衡及插入/删除操作较为麻烦，二叉堆实际上使用数组来实现。即物理结构为数组，逻辑结构为完全二叉树。子结点的键值或索引总是小于（或者大于）它的父节点，且每个节点的左右子树又是一个二叉堆(大根堆或者小根堆)。根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常被用作实现优先队列。</p> <h4 id="特点">特点</h4> <ol> <li>以数组表示，但是以完全二叉树的方式理解。</li> <li>唯一能够同时最优地利用空间和时间的方法——最坏情况下也能保证使用 2N \log N2NlogN 次比较和恒定的额外空间。</li> <li> <p>在索引从0开始的数组中： 父节点 i 的左子节点在位置(2<em>i+1) 父节点 i 的右子节点在位置(2</em>i+2) 子节点 i 的父节点在位置floor((i-1)/2)</p> <p>class MaxHeap: def <strong>init</strong>(self, array=None): if array: self.heap = self._max_heapify(array) else: self.heap = []</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def _sink(self, array, i):
     # move node down the tree
     left, right = 2 * i + 1, 2 * i + 2
     max_index = i
     # should compare two chidren then determine which one to swap with
     if left &lt; len(array) and right &lt; len(array):
         flag = array[left] &gt; array[right]
     else:
         flag = True
     if left &lt; len(array) and array[left] &gt; array[max_index] and flag:
         max_index = left
     if right &lt; len(array) and array[right] &gt; array[max_index] and not flag:
         max_index = right
     if max_index != i:
         array[i], array[max_index] = array[max_index], array[i]
         self._sink(array, max_index)

 def _swim(self, array, i):
     # move node up the tree
     if i == 0:
         return
     father = (i - 1) / 2
     if array[father] &lt; array[i]:
         array[father], array[i] = array[i], array[father]
         self._swim(array, father)

 def _max_heapify(self, array):
     for i in xrange(len(array) / 2, -1, -1):
         self._sink(array, i)
     return array

 def push(self, item):
     self.heap.append(item)
     self._swim(self.heap, len(self.heap) - 1)

 def pop(self):
     self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]
     item = self.heap.pop()
     self._sink(self.heap, 0)
     return item
</code></pre></div> </div> </li> </ol> <h2 id="stack">Stack</h2> <p>栈是一种 LIFO(Last In First Out) 的数据结构，常用方法有添加元素，取栈顶元素，弹出栈顶元素，判断栈是否为空。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stack = []
len(stack) # size of stack

# more efficient stack
import collections
stack = collections.deque()

len(stack) != 0 - 判断stack是否weikong
stack[-1] - 取栈顶元素，不移除
pop() - 移除栈顶元素并返回该元素
append(item) - 向栈顶添加元素
</code></pre></div></div> <h2 id="set">Set</h2> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set 是一种用于保存不重复元素的数据结构。常被用作测试归属性，故其查找的性能十分重要
</code></pre></div></div> <h2 id="map">Map</h2> <p>Map 是一种关联数组的数据结构，也常被称为字典或键值对。在 Python 中 dict(Map) 是一种基本的数据结构。</p> <h4 id="hash-table">Hash Table</h4> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>当元素的数值范围很大，甚至元素不是整数，此时可以利用hash function 得到一个索引值，而不会超出阵列边界。

数值范围小，索引储存是首选，省时间费空间；数值范围大，循序储存是首选，省空间费时间。hash table 两者兼具，介于中间。
</code></pre></div></div> <h2 id="graph---图">Graph - 图</h2> <p>图的表示通常使用邻接矩阵和邻接表，前者易实现但是对于稀疏矩阵会浪费较多空间，后者使用链表的方式存储信息但是对于图搜索时间复杂度较高。</p> <h4 id="邻接矩阵">邻接矩阵</h4> <p>设顶点个数为 V, 那么邻接矩阵可以使用 V × V 的二维数组来表示。 g[i][j]表示顶点i和顶点j的关系，对于无向图可以使用0/1表示是否有连接，对于带权图则需要使用INF来区分。有重边时保存边数或者权值最大/小的边即可。</p> <h4 id="邻接表">邻接表</h4> <p>邻接表通过表示从顶点i出发到其他所有可能能到的边。</p> <h2 id="incremental-method">Incremental Method</h2> <p>「递增法」是符合电脑运作特性的方法。电脑执行程式，一次只做一个动作，完成了一件事才做下一件事。当一个问题太大太多时，化整为零、一个一个解决吧！</p> <h4 id="selection-sort">selection sort</h4> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1 def selection(_l):
  2     for i in range(len(_l)):
  3         min = i
  4         for j in range(i+1,len(_l)):
  5             if _l[j] &lt; _l[min]:
  6                 min = j
  7         _l[i], _l[min] = _l[min], _l[i]
  8     print(_l)
</code></pre></div></div> <h2 id="memoization">Memoization</h2> <p>「记忆法」是符合电脑运作特性的方法。电脑拥有大量储存空间。只要将计算过的数值，储存于记忆体，往后就能直接使用记忆体储存的资料，不必再浪费时间重复计算一遍。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array = [[0 for i in range(n)] for j in range(n)]
#利用列表生成式快速创建多维数组
</code></pre></div></div> <h2 id="enumeration">Enumeration</h2> <p>「枚举法」利用了电脑无与伦比的计算速度。找到不确定的变数，枚举所有可能性，逐一判断正确性。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1 S = "It's a pencil."
  2 s = "a pen"
  3
  4 for i in range(0, len(S)):
  5     flag = True
  6     for j in range(0, len(s)):
  7         if S[i+j] != s[j]:
  8             flag = False
  9     if flag:
 10         print(i, S[i])
 11         break
</code></pre></div></div> <h2 id="straightforward-method--trial-and-error">Straightforward Method / Trial and Error</h2> <p>「直接法」，直接算出答案。直接法和试误法刚好相反。直接法是由题目本身下手，推导答案；试误法则是从答案下手，让答案迎合题目需求。</p> <h4 id="暴力攻击-brute-force-attack-">暴力攻击（ Brute Force Attack ）</h4> <p>破解密码最简单的方法叫做「暴力攻击」。不知道密码规律的情况下，无法直接推导正确密码，只好以试误法一一检验所有可能的密码，从中找出正确密码。</p> <h4 id="单向函数-one-way-function-">单向函数（ One-way Function ）</h4> <p>「单向函数」是一种特别的函数，给定输入很容易算出输出，但是给定输出却很难算出输入。</p> <h2 id="iterative-method">Iterative Method</h2> <p>叠代法，也叫递推法。不断利用目前求得的数值，再求得新数值。</p> <h4 id="数学归纳法-mathematical-induction-">数学归纳法（ Mathematical Induction ）</h4> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>数学归纳法的第二步骤，就是证明可不可以递推！第二步骤的证明过程中一定会用到递推！
1. 先证明n = 1 成立。（有时候不见得要从1开始。）
2. 假设n = k 成立，证明n = k+1 也会成立。
当1. 2. 得证，就表示n = 1 ... ∞ 全部都成立。
</code></pre></div></div> <h4 id="插入排序法-insertion-sort-">插入排序法（ Insertion Sort ）</h4> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>从表面上来看是递增法与枚举法：第一层是递增法，逐一把每个数字插入到左方已排序的阵列。第二层是枚举法，搜寻插入位置；再将大量数字往右挪，以腾出空间插入数字。
</code></pre></div></div> <h2 id="recursive-method">Recursive Method</h2> <p>递归法。重复运用相同手法，缩减问题范围，直到厘清细节。 递推法与递归法恰好颠倒：递推法是针对已知，逐步累积，直至周全；递归法是针对未知，反覆拆解，直至精确。</p> <h2 id="greedy-method">Greedy Method</h2> <p>「贪心法」。以Incremental Method 或Iterative Method 制造答案的方法，大致上分为两类：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>一、填答案：从没有答案开始，逐步填满答案。
二、改答案：先随便弄个答案，逐步修饰答案。
一、观察问题特征，拟定一个填答案、改答案的原则。
二、随便挑几个特例，手算一下。
  如果答案都对，就大胆假设此原则是正确的。
  （也可以尝试证明此原则必定正确。）
三、实作程式码，把答案算出来。
</code></pre></div></div> <h4 id="不重复组合-combination-">不重复组合（ Combination ）</h4> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>从N 个人抓M 个人出来组团，有哪些组合方式呢？
N 个人当中的其中一个人，叫做甲君好了，我们将原问题分割成两种情形：甲君在团中、甲君不在团中。甲君在团中，演变成剩下N-1个人要再抓M-1个人出来组团。
甲君不在团中，演变成剩下N-1个人仍要抓M个人出来组团。

综合这两个子问题的组合方式，就得到答案。从N 个人抓M 个人出来组团，有哪些组合方式呢？
N 个人当中的其中一个人，叫做甲君好了，我们将原问题分割成两种情形：甲君在团中、甲君不在团中。甲君在团中，演变成剩下N-1个人要再抓M-1个人出来组团。
甲君不在团中，演变成剩下N-1个人仍要抓M个人出来组团。

综合这两个子问题的组合方式，就得到答案。
</code></pre></div></div> <h4 id="二分搜寻法-binary-search-">二分搜寻法（ Binary Search ）</h4> <p>这是在已排序阵列里面搜寻数字的方法。阵列由中央切成两边，一边数字较小、一边数字较大。这两边一定有一边不是我们所要的，可以去除，只需要继续寻找其中一边。</p> <h2 id="sort">Sort</h2> <table> <thead> <tr> <th> </th> <th>best case average case worst case</th> <th>extra space</th> <th>stable</th> </tr> </thead> <tbody> <tr> <td>brute force</td> <td>O(NR) O(NR) O(NR)</td> <td>O(N)</td> <td>O</td> </tr> <tr> <td>selection sort</td> <td>O(NN) O(NN) O(NN)</td> <td>O(1)</td> <td>X</td> </tr> <tr> <td>bubble sort</td> <td>O(N) O(NN) O(NN)</td> <td>O(1)</td> <td>O</td> </tr> <tr> <td>gnome sort</td> <td>O(N) O(NN) O(NN)</td> <td>O(1)</td> <td>O</td> </tr> <tr> <td>insertion sort</td> <td>O(N) O(NN) O(NN)</td> <td>O(1)</td> <td>O</td> </tr> <tr> <td>Shell sort</td> <td>O(NN) O(NN) O(NN)</td> <td>O(1)</td> <td>X</td> </tr> <tr> <td>merge sort</td> <td>O(NlogN) O(NlogN) O(NlogN)</td> <td>O(N)</td> <td>O</td> </tr> <tr> <td>Timsort</td> <td>O(NlogN) O(NlogN) O(NlogN)</td> <td>O(N)</td> <td>O</td> </tr> <tr> <td>quicksort</td> <td>O(NlogN) O(NlogN) O(NN)</td> <td>O(N)</td> <td>X</td> </tr> <tr> <td>heapsort</td> <td>O(NlogN) O(NlogN) O(NlogN)</td> <td>O(1)</td> <td>X</td> </tr> <tr> <td>introsort</td> <td>O(NlogN) O(NlogN) O(NlogN)</td> <td>O(N)</td> <td>X</td> </tr> <tr> <td>counting sort</td> <td>O(N+R) O(N+R) O(N+R)</td> <td>O(N+R)</td> <td>O</td> </tr> <tr> <td>radix sort</td> <td>O(NlogR) O(NlogR) O(NlogR)</td> <td>O(N)</td> <td>O</td> </tr> <tr> <td>bucket sort</td> <td>O(N+R) O(N+R) O(NNR)</td> <td>O(NR)</td> <td>X</td> </tr> <tr> <td>flashsort</td> <td>O(N+R) O(N+R) O(NN)</td> <td>O(N)</td> <td>X</td> </tr> <tr> <td>sleep sort</td> <td>O(N+R) O(N+R) O(N+R)</td> <td>O(N)</td> <td>X</td> </tr> </tbody> </table> <h4 id="排序原理">排序原理</h4> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>排序的基本原理，当今只有两种，一是对调（数字是实数），二是放置（数字必须是整数）。

纯粹透过对调来排序，已证明出数字两两比较的次数是Ω(NlogN) ，不可能更少了，当今也已经有了到达下限的排序演算法，例如merge sort 。同时透过对调与放置来排序，则可以打破方才的下限，例如flashsort 。

纯粹透过放置来排序，需要额外的记忆体空间来放置数字。时间复杂度通常是数字数量加上记忆体用量，效率相当好，只可惜只能处理整数，例如counting sort 。
</code></pre></div></div> <h4 id="selection-sort-1">selection sort</h4> <p>扫描一遍所有数字，找到最小值，挪至阵列左端。递回处理尚未排序的N-1 个元素。复杂度: O(N2) — 实际上，这和冒泡排序很像。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1 def selection(_l):
  2     for i in range(len(_l)):
  3         min = i
  4         for j in range(i+1,len(_l)):
  5             if _l[j] &lt; _l[min]:
  6                 min = j
  7         _l[i], _l[min] = _l[min], _l[i]
  8     print(_l)
</code></pre></div></div> <h4 id="bubble-sort">Bubble Sort</h4> <p>由左到右，相邻两两比较，较大者往右挪，最后最大值会出现在阵列右端。递回处理尚未排序的N-1 个元素。冒泡排序实际上是低效的，它的 O(N^2) 时间复杂度。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1 def bubble(l):
  2     for i in range(0, len(l)):
  3         for j in range(0, len(l)-i-1):
  4             if l[j] &gt; l[j+1]:
  5                 l[j], l[j+1] = l[j+1], l[j]
  6     print(l)
</code></pre></div></div> <h4 id="gnome-sort">Gnome Sort</h4> <p>原理和Bubble Sort 相同，但是两两比较的先后次序有所改变。特色是程式码只有一个loop，结构简单。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1 def gnome(l):
  2     i = 0
  3     while i &lt; len(l):
  4         if i == 0 or l[i-1] &lt; l[i]:
  5             i += 1
  6         else:
  7             l[i], l[i-1] = l[i-1], l[i]
  8             i -= 1
  9     print(l)
</code></pre></div></div> <h4 id="insertion-sort">Insertion Sort</h4> <p>由左到右，逐一把数字插入到目前已排序的阵列当中。需将大量数字往右挪，以腾出空间插入数字。最佳情况时间是O(N × 1) = O(N) ，最坏情况时间是O(N × N) = O(N2).</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1 def insert(l):
  2     for i in range(1, len(l)):
  3         key = l[i]
  4         j = i - 1
  5         while j &gt;=0 and key &lt; l[j]:
  6             l[j+1] = l[j]
  7             j -= 1
  8         l[j+1] = key
  9     print(l)
</code></pre></div></div> <h4 id="merge-sort">Merge Sort</h4> <p>归并并排序是分而治之的排序算法。 划分步骤很简单：将当前数组分成两半（如果N是偶数，则将其完全平等，或者如果N是奇数，则一边稍大于一个元素），然后递归地对这两半进行排序。 归并子例程合并两个（排序的）半部分以形成一个有序数组。归并排序非常适合分类非常大量的输入，因为O（N log N）比前面讨论的O（N2）排序算法增长得慢得多。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1 def mergeSort(arr):
  2     if len(arr) &gt;1:
  3         mid = len(arr)//2 #Finding the mid of the array
  4         L = arr[:mid] # Dividing the array elements
  5         R = arr[mid:] # into 2 halves
  6
  7         mergeSort(L) # Sorting the first half
  8         mergeSort(R) # Sorting the second half
  9
 10         i = j = k = 0
 11
 12         # Copy data to temp arrays L[] and R[]
 13         while i &lt; len(L) and j &lt; len(R):
 14             if L[i] &lt; R[j]:
 15                 arr[k] = L[i]
 16                 i+=1
 17             else:
 18                 arr[k] = R[j]
 19                 j+=1
 20             k+=1
 21
 22         # Checking if any element was left
 23         while i &lt; len(L):
 24             arr[k] = L[i]
 25             i+=1
 26             k+=1
 27
 28         while j &lt; len(R):
 29             arr[k] = R[j]
 30             j+=1
 31             k+=1
</code></pre></div></div> <h4 id="quicksort">Quicksort</h4> <p>快速排序是另一个分而治之排序算法。选主元很重要，找头中尾3个数的中位数，例如8,12,3中位数为8，复杂点5个7个数选取中位数.Quicksort 演算法的陷阱相当多，须考虑数字全都相等、判断式是小于还是小于等于、分割点恰好选到最大值或者最小值、递回的区段范围、递回的区段很短、 ……等等问题。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1 def sort(array=[12,4,5,6,7,3,1,15]):
  2     less = []
  3     equal = []
  4     greater = []
  5
  6     if len(array) &gt; 1:
  7         pivot = array[0] #can be better
  8         for x in array:
  9             if x &lt; pivot:
 10                 less.append(x)
 11             elif x == pivot:
 12                 equal.append(x)
 13             else x &gt; pivot:
 14                 greater.append(x)
 15         return sort(less)+equal+sort(greater)
 16     else:
 17         return array
</code></pre></div></div> <p>使用列表生成式简写</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  19  def qsort(arr):
 20     if len(arr) &gt; 1:
 21         pivot = arr[0]
 22         return qsort([ for x in arr if x &lt; pivot ]) + [pivot] + qsort([ for x in arr if x &gt;= pivot ])
 23     else:
 24         return arr
</code></pre></div></div> </article> <div class="post-share"> <div class="container"> <a href="https://twitter.com/share?url=http://localhost:4000/%E5%A4%87%E5%BF%98/2019/01/02/algorithem.html&text=算法&数据结构" target="_blank" class="post-share-icon twitter"></a> <a href="https://www.evernote.com/clip.action?url=http://localhost:4000/%E5%A4%87%E5%BF%98/2019/01/02/algorithem.html&title=算法&数据结构" target="_blank" class="post-share-icon evernote"></a> <a href="http://service.weibo.com/share/share.php?url=http://localhost:4000/%E5%A4%87%E5%BF%98/2019/01/02/algorithem.html&title=算法&数据结构" target="_blank" class="post-share-icon weibo"></a> </div> </div> <div id="gitalk-container"></div> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk ({ id: 'Fank', // Ensure uniqueness and length less than 50 clientID: '{ {site.comment_gitalk_clientId} }', clientSecret: '{ {site.comment_gitalk_clientSecret} }', repo: '{ {site.comment_gitalk_repo} }', owner: '{ {site.github_username} }', admin: ['{ {site.github_username} }'], distractionFreeMode: false // Facebook-like distraction free mode }) gitalk.render('gitalk-container') </script> <!-- Gitalk end --> <div class="footer"> <div class="container"> <p class="footer-entry">All content is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA</a></p> <p class="footer-entry">Buit with <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> and <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll theme</a> • Hosted on <a href="https://pages.github.com/" target="_blank">Github</a></p> </div> </div> </main> <button id="menu"> <span id="menu-icons"></span> </button> <script src="/assets/js/jquery-2.1.3.min.js"></script> <script src="/assets/js/jquery.pjax.js"></script> <script src="/assets/js/nprogress.js"></script> <script src="/assets/js/main.js"></script> <!-- --> </body> </html>
