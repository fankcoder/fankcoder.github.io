<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>三秋的博客</title>
    <link>http://fankcoder.github.io/</link>
    <description>三秋的博客</description>
    
      <item>
        <title>screen工具</title>
        <link>http://fankcoder.github.io//2016/03/10/screen-linux.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/03/10/screen-linux.html</guid>
        <pubDate>Thu, 10 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;screen-&quot;&gt;screen 多窗口工具&lt;/h2&gt;
&lt;p&gt;远程到服务器，通常情况下我们会为每一个长时间任务开一个远程终端窗口，操作下载东西或者Print十几万行数据，等待，是一件让人非常痛苦的事情，而且在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉了，screen把我们从痛苦中解救出来。&lt;/p&gt;

&lt;p&gt;screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。当断开或关闭终端时，只要不杀死screen的进程，待重新连接后任能继续断开前的操作。&lt;/p&gt;

&lt;h2 id=&quot;screen&quot;&gt;screen命令&lt;/h2&gt;
&lt;p&gt;查看会话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### screen -ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a screen on:
19393.test      (Detached)
1 Socket in /var/run/screen/S-root.&lt;/p&gt;

&lt;p&gt;选择会话&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### screen -r test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### screen -r 19393
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个新会话&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### screen -dmS test
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;快捷键&lt;/h2&gt;

&lt;p&gt;C-a d 暂时断开screen会话&lt;/p&gt;

&lt;p&gt;C-a ?	显示所有键绑定信息&lt;/p&gt;

&lt;p&gt;C-a w	显示所有窗口列表&lt;/p&gt;

&lt;p&gt;C-a C-a	切换到之前显示的窗口&lt;/p&gt;

&lt;p&gt;C-a c	创建一个新的运行shell的窗口并切换到该窗口&lt;/p&gt;

&lt;p&gt;C-a n	切换到下一个窗口&lt;/p&gt;

&lt;p&gt;C-a p	切换到前一个窗口(与C-a n相对)&lt;/p&gt;

&lt;p&gt;C-a 0..9	切换到窗口0..9&lt;/p&gt;

&lt;p&gt;C-a a	发送 C-a到当前窗口&lt;/p&gt;

&lt;p&gt;C-a k	杀掉当前窗口&lt;/p&gt;

&lt;p&gt;C-a [	进入拷贝/回滚模式&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Todolist 应用</title>
        <link>http://fankcoder.github.io//2016/03/08/todolist-django-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/03/08/todolist-django-python.html</guid>
        <pubDate>Tue, 08 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;todolist&quot;&gt;TodoList&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;TodoList是一个便捷的事项管理应用,它帮助我们管理待办任务,梳理工作思路,来提高工作效率&lt;/p&gt;

&lt;p&gt;TodoList包含账户注册登录等功能,来方便记录管理你的任务事项&lt;/p&gt;

&lt;h2 id=&quot;introduce&quot;&gt;Introduce&lt;/h2&gt;
&lt;p&gt;Todolist,a quick and convenient management application for items that are about to be done,which helps us manage the to-do tasks, combine working train of thought and improve work efficency.&lt;/p&gt;

&lt;p&gt;Todolist consists of kinds of functions,including the registration and login for an account,so that it can make your tasks record and items management much easier.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;项目地址&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/fankcoder/django-todolist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##安装&amp;amp;运行
在用户目录下执行,将代码clone到本地&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/fankcoder/django-todolist.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所需环境,请看 django-todolist/doc/requirements.txt&lt;/p&gt;

&lt;p&gt;注:为了部署方便应用默认采用了sqlite3数据库,需更换为MySQL数据库,请更改settings.py如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;&#39;&#39;
#use mysql databases
DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;NAME&#39;: &#39;todolist&#39;,
        &#39;USER&#39;: &#39;root&#39;,    #replace your mysql username
        &#39;PASSWORD&#39;: &#39;xxxxx&#39;,  #replace your mysql password
        &#39;HOST&#39;: &#39;127.0.0.1&#39;,
        &#39;PROT&#39;: &#39;3306&#39;,
    }
}
&#39;&#39;&#39;
DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为,请注意替换为自己的MySQL用户密码.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#use mysql databases
DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;NAME&#39;: &#39;todolist&#39;,
        &#39;USER&#39;: &#39;root&#39;,    #replace your mysql username
        &#39;PASSWORD&#39;: &#39;xxxxx&#39;,  #replace your mysql password
        &#39;HOST&#39;: &#39;127.0.0.1&#39;,
        &#39;PROT&#39;: &#39;3306&#39;,
    }
}
&#39;&#39;&#39;
DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),
    }
}
&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##安装&amp;amp;配置完成后&lt;/p&gt;

&lt;p&gt;建立本地数据库,在django-todo/todo/目录下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py makemigrations
python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py runserver 127.0.0.1:8001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有报错,打开浏览器并访问&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127.0.0.1:8001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可看到应用已经部署成功!&lt;/p&gt;

&lt;p&gt;##目录说明
doc 为文档目录 &lt;br /&gt;
todolist 为应用目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;django-todo/
├── doc
│   ├── index.png
│   ├── login.png
│   ├── register.png
│   ├── user_done.png
│   └── user_index.png
├── README.md
├── requirements.txt
├── requirements.txt~
└── todo
    ├── db.sqlite3
    ├── manage.py
    ├── test.py
    ├── test.py~
    ├── todo
    │   ├── __init__.py
    │   ├── __init__.pyc
    │   ├── settings.py
    │   ├── settings.pyc
    │   ├── urls.py
    │   ├── urls.pyc
    │   ├── wsgi.py
    │   └── wsgi.pyc
    └── todolist
        ├── admin.py
        ├── admin.pyc
        ├── forms.py
        ├── forms.pyc
        ├── __init__.py
        ├── __init__.pyc
        ├── models.py
        ├── models.pyc
        ├── static
        │   ├── css
        │   │   ├── create_sytle.css
        │   │   └── style.css
        │   └── js
        ├── templates
        │   ├── complete.html
        │   ├── create.html
        │   ├── index.html
        │   ├── login.html
        │   ├── nav.html
        │   └── register.html
        ├── tests.py
        ├── views.py
        └── views.pyc
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Linux 常用资源</title>
        <link>http://fankcoder.github.io//2016/03/04/general-linux-resources.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/03/04/general-linux-resources.html</guid>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;常用指令&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;遍历创建&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;当前目录&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pwd 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;上次目录&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd -
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;f&quot;&gt;删除目录 -f强制&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;rm -rf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a&quot;&gt;复制目录 -a与源文件一模一样&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cp -r
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;剪切/改名&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mv
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;find&quot;&gt;find搜索&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;find /root -iname install.log  #-i不区分大小写
find /root -user root  #按照所有者搜索
find /var/log/ -mtime +10 #查找10天前修改的文件
-10 10天内修改文件
10 10天当天修改的文件
+10 10天前修改的文件
atime 文件访问时间
ctime 改变文件属性
mtime 修改文件内容

find . -size 25k
+25k 大于25k
-小于25k
M大写

find /etc -size +20k -a -size -50k
-a and 和
-o or 或

-exec ls -lh {} \;
find /etc -size +20k -a -size -50k -exec ls -lh {} \;
将第一个结果放入第二个在处理一遍
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;grep&quot;&gt;grep&lt;/h3&gt;
&lt;p&gt;grep是包含匹配搜索文件内容,find是完全匹配搜索文件名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep &quot;size&quot; anaconda-ks.cfg
-v 取返
-i 不分大小写
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;帮助命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	man -f 查看级别相当于whatis
	whereis passwd
	ls --help选项帮助命令
	info 命令
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;zip-gz-bz2-targz-tarbz2&quot;&gt;常用压缩格式 .zip .gz .bz2 .tar.gz .tar.bz2&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;zip 压缩文件名 源文件 #压缩文件
zip -r 压缩文件名 源文件 #压缩目录

unzip 压缩文件 #解压缩

gzip 源文件 #压缩为.gz的文件,源文件会消失
gzip -c 源文件 &amp;gt; 压缩文件 #源文件保留
gzip -r 目录 #压缩目录下所有子文件,不压缩目录
gzip -d 压缩文件 #解压
gunzip 压缩文件 #解压

打包tar
tar -cvf 打包文件名 源文件
tar -xvf 解打包
tar -zcvf 压缩包名.tar.gz 源文件
tar -zxvf 压缩包名.tar.gz #解压缩
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;shutdown--&quot;&gt;shutdown [选项] 时间&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;-c 取消前一个关机命令
-h 关机
-r 重启
rboot  重启
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;mount--a-etcfatab&quot;&gt;mount -a 自动挂载/etc/fatab&lt;/h3&gt;

&lt;h3 id=&quot;w&quot;&gt;w&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;查看用户登录信息 who类似 ### last 
所有用户登录信息 /var/log/wtmp ### lastlog 
最后登录时间
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>神器收藏</title>
        <link>http://fankcoder.github.io//2016/01/28/good-tools.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/28/good-tools.html</guid>
        <pubDate>Thu, 28 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;ide&quot;&gt;编辑器 &amp;amp; IDE&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;VIM
    &lt;ul&gt;
      &lt;li&gt;gmarik/vundle&lt;/li&gt;
      &lt;li&gt;rizzatti/funcoo.vim&lt;/li&gt;
      &lt;li&gt;https://github.com/scrooloose/nerdtree.git&lt;/li&gt;
      &lt;li&gt;Modeliner&lt;/li&gt;
      &lt;li&gt;DrawIt&lt;/li&gt;
      &lt;li&gt;vim-scripts/Align&lt;/li&gt;
      &lt;li&gt;https://github.com/Lokaltog/vim-powerline.git&lt;/li&gt;
      &lt;li&gt;https://github.com/vim-scripts/taglist.vim.git&lt;/li&gt;
      &lt;li&gt;https://github.com/scrooloose/nerdcommenter.git&lt;/li&gt;
      &lt;li&gt;https://github.com/kien/ctrlp.vim.git&lt;/li&gt;
      &lt;li&gt;https://github.com/nelstrom/vim-visual-star-search.git&lt;/li&gt;
      &lt;li&gt;junegunn/goyo.vim&lt;/li&gt;
      &lt;li&gt;https://github.com/vim-scripts/Visual-Mark.git&lt;/li&gt;
      &lt;li&gt;https://github.com/mattn/emmet-vim.git&lt;/li&gt;
      &lt;li&gt;https://github.com/Shougo/neocomplcache.vim.git&lt;/li&gt;
      &lt;li&gt;https://github.com/terryma/vim-multiple-cursors.git&lt;/li&gt;
      &lt;li&gt;https://github.com/ervandew/supertab.git&lt;/li&gt;
      &lt;li&gt;https://github.com/sjl/vitality.vim.git&lt;/li&gt;
      &lt;li&gt;https://github.com/Lokaltog/vim-easymotion.git&lt;/li&gt;
      &lt;li&gt;rking/ag.vim&lt;/li&gt;
      &lt;li&gt;Valloric/YouCompleteMe&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Sublime Text
    &lt;ul&gt;
      &lt;li&gt;Abacus&lt;/li&gt;
      &lt;li&gt;ASCII Decorator&lt;/li&gt;
      &lt;li&gt;BracketHighlighter&lt;/li&gt;
      &lt;li&gt;DocBlockr&lt;/li&gt;
      &lt;li&gt;Emmet&lt;/li&gt;
      &lt;li&gt;FileDiffs&lt;/li&gt;
      &lt;li&gt;Goto-CSS-Declaration&lt;/li&gt;
      &lt;li&gt;Laravel 4 Facades&lt;/li&gt;
      &lt;li&gt;Laravel Blade Highlighter&lt;/li&gt;
      &lt;li&gt;Live CSS&lt;/li&gt;
      &lt;li&gt;Open URL&lt;/li&gt;
      &lt;li&gt;Package Control&lt;/li&gt;
      &lt;li&gt;Theme-Soda&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PhpStorm&lt;/li&gt;
  &lt;li&gt;Intellij IDEA&lt;/li&gt;
  &lt;li&gt;PyCharm&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;浏览器&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Chrome
    &lt;ul&gt;
      &lt;li&gt;Visual Event&lt;/li&gt;
      &lt;li&gt;Web Developer&lt;/li&gt;
      &lt;li&gt;XPather&lt;/li&gt;
      &lt;li&gt;Tampermonkey&lt;/li&gt;
      &lt;li&gt;Pesticide for Chrome&lt;/li&gt;
      &lt;li&gt;EditThisCookie&lt;/li&gt;
      &lt;li&gt;Clockwork&lt;/li&gt;
      &lt;li&gt;AlloyDesigner&lt;/li&gt;
      &lt;li&gt;jQuery Audit&lt;/li&gt;
      &lt;li&gt;JSONView&lt;/li&gt;
      &lt;li&gt;Octosplit&lt;/li&gt;
      &lt;li&gt;Octotree&lt;/li&gt;
      &lt;li&gt;Print GitHub markdown: GitPrint.com&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;文档 &amp;amp; 代码片段管理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;CodeBox&lt;/li&gt;
  &lt;li&gt;Dash&lt;/li&gt;
  &lt;li&gt;iDocument Plus&lt;/li&gt;
  &lt;li&gt;Sparkbox&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;调试工具 &amp;amp; 代码生成&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;CodeRunner&lt;/li&gt;
  &lt;li&gt;PAW&lt;/li&gt;
  &lt;li&gt;PaintCode&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;窗口管理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Slate&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;取色 &amp;amp; 度量&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Sip&lt;/li&gt;
  &lt;li&gt;ColorSchemer Studio&lt;/li&gt;
  &lt;li&gt;xScope&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;数据库管理&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Sequel Pro&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;屏幕录制 &amp;amp; 演示&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ScreenFlow&lt;/li&gt;
  &lt;li&gt;Zoom It&lt;/li&gt;
  &lt;li&gt;GrabIt&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;图像处理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Adobe Photoshop
    &lt;ul&gt;
      &lt;li&gt;PNG Hat&lt;/li&gt;
      &lt;li&gt;CSS Hat&lt;/li&gt;
      &lt;li&gt;Renamy&lt;/li&gt;
      &lt;li&gt;Random User Generator&lt;/li&gt;
      &lt;li&gt;Ink&lt;/li&gt;
      &lt;li&gt;GuideGuide&lt;/li&gt;
      &lt;li&gt;Griddify&lt;/li&gt;
      &lt;li&gt;FlatIcon&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Slicy&lt;/li&gt;
  &lt;li&gt;iconKit&lt;/li&gt;
  &lt;li&gt;LilyView&lt;/li&gt;
  &lt;li&gt;Mark Man&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;版本管理 &amp;amp; 比对&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Tower&lt;/li&gt;
  &lt;li&gt;Github&lt;/li&gt;
  &lt;li&gt;Kaleidoscope&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;脑图 &amp;amp; 任务&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;OmniPlan&lt;/li&gt;
  &lt;li&gt;OmniGraffle&lt;/li&gt;
  &lt;li&gt;MindNode Pro&lt;/li&gt;
  &lt;li&gt;Things&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;vnc&quot;&gt;虚拟机 &amp;amp; VNC&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;VirtualBox&lt;/li&gt;
  &lt;li&gt;VMWare Fusion&lt;/li&gt;
  &lt;li&gt;Jump Desktop&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;效率&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Alfred&lt;/li&gt;
  &lt;li&gt;PopClip&lt;/li&gt;
  &lt;li&gt;Soulver&lt;/li&gt;
  &lt;li&gt;Caffeine&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-11&quot;&gt;其他&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Sdef Editor&lt;/li&gt;
  &lt;li&gt;HopperDisassembler&lt;/li&gt;
  &lt;li&gt;Leaf&lt;/li&gt;
  &lt;li&gt;iTerm&lt;/li&gt;
  &lt;li&gt;ForkLift&lt;/li&gt;
  &lt;li&gt;GoAgentX&lt;/li&gt;
  &lt;li&gt;MPlayerX&lt;/li&gt;
  &lt;li&gt;GIFBrewery&lt;/li&gt;
  &lt;li&gt;Fritzing&lt;/li&gt;
  &lt;li&gt;Debookee&lt;/li&gt;
  &lt;li&gt;BetterZip&lt;/li&gt;
  &lt;li&gt;Cactus Beta&lt;/li&gt;
  &lt;li&gt;Bartender&lt;/li&gt;
  &lt;li&gt;AppCleaner&lt;/li&gt;
  &lt;li&gt;Adobe Effects&lt;/li&gt;
  &lt;li&gt;Adobe Illustrator&lt;/li&gt;
  &lt;li&gt;Adobe Reader&lt;/li&gt;
  &lt;li&gt;Airmail&lt;/li&gt;
  &lt;li&gt;The Unachiver&lt;/li&gt;
  &lt;li&gt;Charles&lt;/li&gt;
  &lt;li&gt;Macaw&lt;/li&gt;
  &lt;li&gt;Poedit&lt;/li&gt;
  &lt;li&gt;MacDown&lt;/li&gt;
  &lt;li&gt;Vox&lt;/li&gt;
  &lt;li&gt;TotalFinder&lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>Django命令备忘录</title>
        <link>http://fankcoder.github.io//2016/01/27/general-django-resource.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/27/general-django-resource.html</guid>
        <pubDate>Wed, 27 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;django-project&quot;&gt;新建一个 django project&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; django-admin.py startproject project-name
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;app&quot;&gt;新建 app&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py startapp app-name
 #或
 django-admin.py startapp app-name
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;同步数据库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py syncdb 
 #注意：Django 1.7.1及以上的版本需要用以下命令
 python manage.py makemigrations
 python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法可以创建表，当你在models.py中新增了类时，运行它就可以自动在数据库中创建表了，不用手动创建。&lt;/p&gt;

&lt;p&gt;备注：对已有的 models 进行修改，Django 1.7之前的版本的Django都是无法自动更改表结构的，不过有第三方工具 south,详见 Django 数据库迁移&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;使用开发服务器&lt;/h3&gt;

&lt;p&gt;开发服务器，即开发时使用，一般修改代码后会自动重启，方便调试和开发，但是由于性能问题，建议只用来测试，不要用在生产环境。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; python manage.py runserver
 python manage.py runserver 8001
 python manage.py runserver 0.0.0.0:8000
 # 如果是外网或者局域网电脑上可以用其它电脑查看开发服务器
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;清空数据库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py flush
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;创建超级管理员&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py createsuperuser
  
 # 按照提示输入用户名和对应的密码就好了邮箱可以留空，用户名和密码必填
  
 # 修改 用户密码可以用：
 python manage.py changepassword username
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;导出数据 导入数据&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py dumpdata appname &amp;gt; appname.json
 python manage.py loaddata appname.json
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;django-&quot;&gt;Django 项目环境终端&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你安装了 bpython 或 ipython 会自动用它们的界面，推荐安装 bpython。&lt;/p&gt;

&lt;p&gt;这个命令和 直接运行 python 或 bpython 进入 shell 的区别是：你可以在这个 shell 里面调用当前项目的 models.py 中的 API，对于操作数据，还有一些小测试非常方便。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;数据库命令行&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py dbshell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Django 会自动进入在settings.py中设置的数据库，如果是 MySQL 或 postgreSQL,会要求输入数据库用户密码。
在这个终端可以执行数据库的SQL语句。如果您对SQL比较熟悉，可能喜欢这种方式。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;更多命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; 终端上输入 python manage.py 可以看到详细的列表，在忘记子名称的时候特别有用。
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>爬虫防屏蔽</title>
        <link>http://fankcoder.github.io//2016/01/25/amazon-spider-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/25/amazon-spider-python.html</guid>
        <pubDate>Mon, 25 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;##介绍&lt;/p&gt;

&lt;p&gt;最近爬了amazon,发现amazon服务器,连续访问100多次后爬虫就会经常失败了,&lt;/p&gt;

&lt;p&gt;查找了下失败的原因,发现amazon会检测Ip一旦发现请求次数过多,就会跳转到输入验证码的网页&lt;/p&gt;

&lt;p&gt;需要输入正确验证码才可继续愉快的访问,搞掉验证码是个麻烦活,执意研究验证码就跨到图像分析那个学科了(不过据说某些库识别率还行)。。&lt;/p&gt;

&lt;p&gt;Gg整理正常的防屏蔽方法,总结一下比较好的解决方案.&lt;/p&gt;

&lt;h4 id=&quot;adsl&quot;&gt;ADSL重启拨号&lt;/h4&gt;

&lt;p&gt;大家都知道adsl重拨号的话,会换一个新的ip地址,那就可以写脚本设置时间重拨adsl,或者先用爬虫爬着,发现开始跳转到验证码页面了,再调用重拨adsl的脚本&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;爬代理服务器地址&lt;/h4&gt;

&lt;p&gt;很机智的解决办法，代理服务器可以很好的解决ip被屏蔽的问题&lt;/p&gt;

&lt;p&gt;不过代理服务器的网站域名经常更换,我就不提供了,大家自行Gg吧,百度说不定也会有惊喜&lt;/p&gt;

&lt;p&gt;要注意的是爬下来的代理服务器,最好检测一下是否可用!&lt;/p&gt;

&lt;p&gt;参照下面篇博客的checkProxy()函数&lt;/p&gt;

&lt;p&gt;https://blog.linuxeye.com/410.html&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
#coding:utf-8
#BLOG: blog.linuxeye.com
import urllib2
import re
import threading
import time
import MySQLdb
rawProxyList = []
checkedProxyList = []
#抓取代理网站
targets = []
for i in xrange(1,42):
        target = r&quot;http://www.proxy.com.ru/list_%d.html&quot; % i
        targets.append(target)
#抓取代理服务器正则
p = re.compile(r&#39;&#39;&#39;&amp;lt;tr&amp;gt;&amp;lt;b&amp;gt;&amp;lt;td&amp;gt;(\d+)&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;(.+?)&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;(\d+)&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;(.+?)&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;(.+?)&amp;lt;/td&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/tr&amp;gt;&#39;&#39;&#39;)
#获取代理的类
class ProxyGet(threading.Thread):
    def __init__(self,target):
        threading.Thread.__init__(self)
        self.target = target
    def getProxy(self):
        print &quot;代理服务器目标网站： &quot; + self.target
        req = urllib2.urlopen(self.target)
        result = req.read()
        #print chardet.detect(result)
        matchs = p.findall(result)
#       print matchs
        for row in matchs:
            ip=row[1]
            port =row[2]
            addr = row[4].decode(&quot;cp936&quot;).encode(&quot;utf-8&quot;)
            proxy = [ip,port,addr]
            print proxy
            rawProxyList.append(proxy)
    def run(self):
        self.getProxy()
#检验代理的类
class ProxyCheck(threading.Thread):
    def __init__(self,proxyList):
        threading.Thread.__init__(self)
        self.proxyList = proxyList
        self.timeout = 5
        self.testUrl = &quot;http://www.baidu.com/&quot;
        self.testStr = &quot;030173&quot;
    def checkProxy(self):
        cookies = urllib2.HTTPCookieProcessor()
        for proxy in self.proxyList:
            proxyHandler = urllib2.ProxyHandler({&quot;http&quot; : r&#39;http://%s:%s&#39; %(proxy[0],proxy[1])})
            #print r&#39;http://%s:%s&#39; %(proxy[0],proxy[1])
            opener = urllib2.build_opener(cookies,proxyHandler)
            opener.addheaders = [(&#39;User-agent&#39;, &#39;Mozilla/5.0 (Windows NT 6.2; WOW64; rv:22.0) Gecko/20100101 Firefox/22.0&#39;)]
            #urllib2.install_opener(opener)
            t1 = time.time()
            try:
                #req = urllib2.urlopen(&quot;http://www.baidu.com&quot;, timeout=self.timeout)
                req = opener.open(self.testUrl, timeout=self.timeout)
                #print &quot;urlopen is ok....&quot;
                result = req.read()
                #print &quot;read html....&quot;
                timeused = time.time() - t1
                pos = result.find(self.testStr)
                #print &quot;pos is %s&quot; %pos
                if pos &amp;gt; 1:
                    checkedProxyList.append((proxy[0],proxy[1],proxy[2],timeused))
                    #print &quot;ok ip: %s %s %s %s&quot; %(proxy[0],proxy[1],proxy[2],timeused)
                else:
                     continue
            except Exception,e:
                #print e.message
                continue
    def run(self):
        self.checkProxy()
if __name__ == &quot;__main__&quot;:
    getThreads = []
    checkThreads = []
#对每个目标网站开启一个线程负责抓取代理
for i in range(len(targets)):
    t = ProxyGet(targets[i])
    getThreads.append(t)
for i in range(len(getThreads)):
    getThreads[i].start()
for i in range(len(getThreads)):
    getThreads[i].join()
print &#39;.&#39;*10+&quot;总共抓取了%s个代理&quot; %len(rawProxyList) +&#39;.&#39;*10
#开启20个线程负责校验，将抓取到的代理分成20份，每个线程校验一份
for i in range(20):
    t = ProxyCheck(rawProxyList[((len(rawProxyList)+19)/20) * i:((len(rawProxyList)+19)/20) * (i+1)])
    checkThreads.append(t)
for i in range(len(checkThreads)):
    checkThreads[i].start()
for i in range(len(checkThreads)):
    checkThreads[i].join()
print &#39;.&#39;*10+&quot;总共有%s个代理通过校验&quot; %len(checkedProxyList) +&#39;.&#39;*10
#插入数据库，表结构自己创建，四个字段ip,port,speed,address
def db_insert(insert_list):
    try:
        conn = MySQLdb.connect(host=&quot;localhost&quot;, user=&quot;root&quot;, passwd=&quot;admin&quot;,db=&quot;m_common&quot;,charset=&#39;utf8&#39;)
        cursor = conn.cursor()
        cursor.execute(&#39;delete from proxy&#39;)
        cursor.execute(&#39;alter table proxy AUTO_INCREMENT=1&#39;)
        cursor.executemany(&quot;INSERT INTO proxy(ip,port,speed,address) VALUES (%s,%s,%s,%s)&quot;,insert_list)
        conn.commit()
        cursor.close()
        conn.close()
    except MySQLdb.Error,e:
        print &quot;Mysql Error %d: %s&quot; % (e.args[0], e.args[1])
#代理排序持久化
proxy_ok = []
f= open(&quot;proxy_list.txt&quot;,&#39;w+&#39;)
for proxy in sorted(checkedProxyList,cmp=lambda x,y:cmp(x[3],y[3])):
    if proxy[3] &amp;lt; 8:
        #print &quot;checked proxy is: %s:%s\t%s\t%s&quot; %(proxy[0],proxy[1],proxy[2],proxy[3])
        proxy_ok.append((proxy[0],proxy[1],proxy[3],proxy[2]))
        f.write(&quot;%s:%s\t%s\t%s\n&quot;%(proxy[0],proxy[1],proxy[2],proxy[3]))
f.close()
db_insert(proxy_ok)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想了解我的amazon爬虫?&lt;/p&gt;

&lt;p&gt;代码在github spider-comments项目下的amazon-spider-comments&lt;/p&gt;

&lt;p&gt;https://github.com/fankcoder/spider-comments&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Django添加静态文件</title>
        <link>http://fankcoder.github.io//2016/01/20/add-static-django-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/20/add-static-django-python.html</guid>
        <pubDate>Wed, 20 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;最近做了一个todolist webapp,需要添加css时候忘记添加方法了,查看了以前的项目才想起来,所以记录一下.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;settings.py 将以下代码放到最下面&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;STATIC_URL = &#39;/static/&#39;
 
STATICFILES_DIRS = ( 
    os.path.join(BASE_DIR),
)
 
STATICFILES_FINDERS = (
    &quot;django.contrib.staticfiles.finders.FileSystemFinder&quot;,
    &quot;django.contrib.staticfiles.finders.AppDirectoriesFinder&quot;,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;给html添加静态文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首行加入(一定要放在首行)，这里和Jekyll冲突了在需要代码前后添加的是“大括号和百分号”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/\{\%/load staticfiles/\%\}/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后按照jinjia2或者djagno template的语法加上css等静态文件的路径,如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/\{\%/ static &#39;css/style.css&#39; /\%\}/&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搞定&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Python 多线程</title>
        <link>http://fankcoder.github.io//2016/01/12/threading-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/12/threading-python.html</guid>
        <pubDate>Tue, 12 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;多线程类似于同时执行多个不同程序，多线程运行有如下优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用线程可以把占据长时间的程序中的任务放到后台去处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;程序的运行速度可能加快&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。&lt;/p&gt;

&lt;p&gt;指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程可以被抢占（中断）。&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） – 这就是线程的退让。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;python&quot;&gt;Python线程&lt;/h3&gt;

&lt;p&gt;Python中使用线程有两种方式：函数或者用类来包装线程对象。&lt;/p&gt;

&lt;p&gt;函数式：调用thread模块中的start_new_thread()函数来产生新线程。语法如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;thread.start_new_thread ( function, args[, kwargs] )
参数说明:

function - 线程函数。
args - 传递给线程函数的参数,他必须是个tuple类型。
kwargs - 可选参数。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# -*- coding: UTF-8 -*-

import thread
import time

# 为线程定义一个函数
def print_time( threadName, delay):
   count = 0
   while count &amp;lt; 5:
      time.sleep(delay)
      count += 1
      print &quot;%s: %s&quot; % ( threadName, time.ctime(time.time()) )

# 创建两个线程
try:
   thread.start_new_thread( print_time, (&quot;Thread-1&quot;, 2, ) )
   thread.start_new_thread( print_time, (&quot;Thread-2&quot;, 4, ) )
except:
   print &quot;Error: unable to start thread&quot;

while 1:
   pass
执行以上程序输出结果如下：
Thread-1: Thu Jan 22 15:42:17 2009
Thread-1: Thu Jan 22 15:42:19 2009
Thread-2: Thu Jan 22 15:42:19 2009
Thread-1: Thu Jan 22 15:42:21 2009
Thread-2: Thu Jan 22 15:42:23 2009
Thread-1: Thu Jan 22 15:42:23 2009
Thread-1: Thu Jan 22 15:42:25 2009
Thread-2: Thu Jan 22 15:42:27 2009
Thread-2: Thu Jan 22 15:42:31 2009
Thread-2: Thu Jan 22 15:42:35 2009
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程的结束一般依靠线程函数的自然结束；也可以在线程函数中调用thread.exit()，他抛出SystemExit exception，达到退出线程的目的。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;线程模块&lt;/h3&gt;

&lt;p&gt;Python通过两个标准库thread和threading提供对线程的支持。thread提供了低级别的、原始的线程以及一个简单的锁。&lt;/p&gt;

&lt;p&gt;thread 模块提供的其他方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;threading.currentThread(): 返回当前的线程变量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;run(): 用以表示线程活动的方法。&lt;/li&gt;
  &lt;li&gt;start():启动线程活动。&lt;/li&gt;
  &lt;li&gt;join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。&lt;/li&gt;
  &lt;li&gt;isAlive(): 返回线程是否活动的。&lt;/li&gt;
  &lt;li&gt;getName(): 返回线程名。&lt;/li&gt;
  &lt;li&gt;setName(): 设置线程名。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;threading&quot;&gt;使用Threading模块创建线程&lt;/h3&gt;

&lt;p&gt;使用Threading模块创建线程，直接从threading.Thread继承，然后重写__init__方法和run方法：
#!/usr/bin/python&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: UTF-8 -*-

import threading
import time

exitFlag = 0

class myThread (threading.Thread):   #继承父类threading.Thread
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):                   #把要执行的代码写到run函数里面 线程在创建后会直接运行run函数 
        print &quot;Starting &quot; + self.name
        print_time(self.name, self.counter, 5)
        print &quot;Exiting &quot; + self.name

def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            thread.exit()
        time.sleep(delay)
        print &quot;%s: %s&quot; % (threadName, time.ctime(time.time()))
        counter -= 1

# 创建新线程
thread1 = myThread(1, &quot;Thread-1&quot;, 1)
thread2 = myThread(2, &quot;Thread-2&quot;, 2)

# 开启线程
thread1.start()
thread2.start()

print &quot;Exiting Main Thread&quot;
以上程序执行结果如下；
Starting Thread-1
Starting Thread-2
Exiting Main Thread
Thread-1: Thu Mar 21 09:10:03 2013
Thread-1: Thu Mar 21 09:10:04 2013
Thread-2: Thu Mar 21 09:10:04 2013
Thread-1: Thu Mar 21 09:10:05 2013
Thread-1: Thu Mar 21 09:10:06 2013
Thread-2: Thu Mar 21 09:10:06 2013
Thread-1: Thu Mar 21 09:10:07 2013
Exiting Thread-1
Thread-2: Thu Mar 21 09:10:08 2013
Thread-2: Thu Mar 21 09:10:10 2013
Thread-2: Thu Mar 21 09:10:12 2013
Exiting Thread-2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;线程同步&lt;/h3&gt;

&lt;p&gt;如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。&lt;/p&gt;

&lt;p&gt;使用Thread对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有acquire方法和release方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间。如下：&lt;/p&gt;

&lt;p&gt;多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。&lt;/p&gt;

&lt;p&gt;考虑这样一种情况：一个列表里所有元素都是0，线程”set”从后向前把所有元素改成1，而线程”print”负责从前往后读取列表并打印。&lt;/p&gt;

&lt;p&gt;那么，可能线程”set”开始改的时候，线程”print”便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。&lt;/p&gt;

&lt;p&gt;锁有两种状态——锁定和未锁定。每当一个线程比如”set”要访问共享数据时，必须先获得锁定；如果已经有别的线程比如”print”获得锁定了，那么就让线程”set”暂停，也就是同步阻塞；等到线程”print”访问完毕，释放锁以后，再让线程”set”继续。&lt;/p&gt;

&lt;p&gt;经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。&lt;/p&gt;

&lt;p&gt;实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# -*- coding: UTF-8 -*-

import threading
import time

class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):
        print &quot;Starting &quot; + self.name
       # 获得锁，成功获得锁定后返回True
       # 可选的timeout参数不填时将一直阻塞直到获得锁定
       # 否则超时后将返回False
        threadLock.acquire()
        print_time(self.name, self.counter, 3)
        # 释放锁
        threadLock.release()

def print_time(threadName, delay, counter):
    while counter:
        time.sleep(delay)
        print &quot;%s: %s&quot; % (threadName, time.ctime(time.time()))
        counter -= 1

threadLock = threading.Lock()
threads = []

# 创建新线程
thread1 = myThread(1, &quot;Thread-1&quot;, 1)
thread2 = myThread(2, &quot;Thread-2&quot;, 2)

# 开启新线程
thread1.start()
thread2.start()

# 添加线程到线程列表
threads.append(thread1)
threads.append(thread2)

# 等待所有线程完成
for t in threads:
    t.join()
print &quot;Exiting Main Thread&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;queue&quot;&gt;线程优先级队列（ Queue）&lt;/h3&gt;

&lt;p&gt;Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列来实现线程间的同步。&lt;/p&gt;

&lt;p&gt;Queue模块中的常用方法:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Queue.qsize() 返回队列的大小&lt;/li&gt;
  &lt;li&gt;Queue.empty() 如果队列为空，返回True,反之False&lt;/li&gt;
  &lt;li&gt;Queue.full() 如果队列满了，返回True,反之False&lt;/li&gt;
  &lt;li&gt;Queue.full 与 maxsize 大小对应&lt;/li&gt;
  &lt;li&gt;Queue.get([block[, timeout]])获取队列，timeout等待时间&lt;/li&gt;
  &lt;li&gt;Queue.get_nowait() 相当Queue.get(False)&lt;/li&gt;
  &lt;li&gt;Queue.put(item) 写入队列，timeout等待时间&lt;/li&gt;
  &lt;li&gt;Queue.put_nowait(item) 相当Queue.put(item, False)&lt;/li&gt;
  &lt;li&gt;Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号&lt;/li&gt;
  &lt;li&gt;Queue.join() 实际上意味着等到队列为空，再执行别的操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
# -*- coding: UTF-8 -*-

import Queue
import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, q):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.q = q
    def run(self):
        print &quot;Starting &quot; + self.name
        process_data(self.name, self.q)
        print &quot;Exiting &quot; + self.name

def process_data(threadName, q):
    while not exitFlag:
        queueLock.acquire()
        if not workQueue.empty():
            data = q.get()
            queueLock.release()
            print &quot;%s processing %s&quot; % (threadName, data)
        else:
            queueLock.release()
        time.sleep(1)

threadList = [&quot;Thread-1&quot;, &quot;Thread-2&quot;, &quot;Thread-3&quot;]
nameList = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;]
queueLock = threading.Lock()
workQueue = Queue.Queue(10)
threads = []
threadID = 1

# 创建新线程
for tName in threadList:
    thread = myThread(threadID, tName, workQueue)
    thread.start()
    threads.append(thread)
    threadID += 1

# 填充队列
queueLock.acquire()
for word in nameList:
    workQueue.put(word)
queueLock.release()

# 等待队列清空
while not workQueue.empty():
    pass

# 通知线程是时候退出
exitFlag = 1

# 等待所有线程完成
for t in threads:
    t.join()
print &quot;Exiting Main Thread&quot;
以上程序执行结果：
Starting Thread-1
Starting Thread-2
Starting Thread-3
Thread-1 processing One
Thread-2 processing Two
Thread-3 processing Three
Thread-1 processing Four
Thread-2 processing Five
Exiting Thread-3
Exiting Thread-1
Exiting Thread-2
Exiting Main Thread
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Python黑魔法(split,enumerate)</title>
        <link>http://fankcoder.github.io//2016/01/11/enumerate-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/11/enumerate-python.html</guid>
        <pubDate>Mon, 11 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;split&quot;&gt;split()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
 
str = &quot;Line1-abcdef \nLine2-abc \nLine4-abcd&quot;;
print str.split( );
print str.split(&#39; &#39;, 1 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&#39;Line1-abcdef&#39;, &#39;Line2-abc&#39;, &#39;Line4-abcd&#39;]
[&#39;Line1-abcdef&#39;, &#39;\nLine2-abc \nLine4-abcd&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;split()要点:&lt;/p&gt;

&lt;p&gt;采用不带参数的split()，它会把所有空格（空格符、制表符、换行符）当作分隔符。&lt;/p&gt;

&lt;p&gt;filter(None, s.split(‘ ‘))&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = &#39;hello++world!+&#39;   #如何取得&#39;hello&#39;和&#39;world&#39;呢？
 
&amp;gt;&amp;gt;&amp;gt;a.split(&#39;+&#39;)
 
[&#39;hello&#39;, &#39;&#39;, &#39;world!&#39;, &#39;&#39;]    #含有两个空字符串
 
&amp;gt;&amp;gt;&amp;gt;filter(None, a.split(&#39;+&#39;))
 
[&#39;hello&#39;, &#39;world!&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;enumerate&quot;&gt;enumerate()&lt;/h3&gt;

&lt;p&gt;写一个带引索的遍历数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in range (0,len(list)):
    print i ,list[i]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用enumerate():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;l = [1,2,3,&#39;a&#39;,&#39;b&#39;]
 
 for index,data in enumerate(l):
     print index,data
 
&amp;gt;&amp;gt;   
0 1
1 2
2 3
3 a
4 b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简直太方便了~&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Python转码问题</title>
        <link>http://fankcoder.github.io//2016/01/11/encode-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/11/encode-python.html</guid>
        <pubDate>Mon, 11 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;在Python中，可以对String调用decode和encode方法来实现转码。&lt;/p&gt;

&lt;p&gt;比如，若要将某个String对象s从gbk内码转换为UTF-8，可以如下操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s.decode(&#39;gbk&#39;).encode(&#39;utf-8′) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可是，在实际开发中，我发现，这种办法经常会出现异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UnicodeDecodeError: ‘gbk&#39; codec can&#39;t decode bytes in position 30664-30665: illegal multibyte sequence 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为遇到了非法字符——尤其是在某些用C/C++编写的程序中，全角空格往往有多种不同的实现方式，比如\xa3\xa0，或者\xa4\x57，这些字符，看起来都是全角空格，但它们并不是“合法”的全角空格（真正的全角空格是\xa1\xa1），因此在转码的过程中出现了异常。&lt;/p&gt;

&lt;p&gt;这样的问题很让人头疼，因为只要字符串中出现了一个非法字符，整个字符串——有时候，就是整篇文章——就都无法转码。&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s.decode(&#39;gbk&#39;, ‘ignore&#39;).encode(&#39;utf-8′) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为decode的函数原型是decode([encoding], [errors=’strict’])，可以用第二个参数控制错误处理的策略，默认的参数就是strict，代表遇到非法字符时抛出异常； 
如果设置为ignore，则会忽略非法字符； 
如果设置为replace，则会用?取代非法字符； 
如果设置为xmlcharrefreplace，则使用XML的字符引用。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Python的xrange和range</title>
        <link>http://fankcoder.github.io//2015/12/29/xrange-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/12/29/xrange-python.html</guid>
        <pubDate>Tue, 29 Dec 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;这两个函数基本上都是在循环的时候用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in range(0, 100): 
print i 

for i in xrange(0, 100): 
print i 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个输出的结果都是一样的，实际上有很多不同，range会直接生成一个list对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = range(0,100) 
print type(a)  #list
print a #[0,1,2...]
print a[0], a[1] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而xrange则不会直接生成一个list，而是每次调用返回其中的一个值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = xrange(0,100) 
print type(a) #&amp;lt;type &#39;xrange&#39;&amp;gt;
print a  #xrange(100)
print a[0], a[1] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以xrange做循环的性能比range好，尤其是返回列表很长的时候！&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>科学上网列表</title>
        <link>http://fankcoder.github.io//2015/11/10/vpn-tools.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/11/10/vpn-tools.html</guid>
        <pubDate>Tue, 10 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;付费vpn列表，流量计费约4G，不包月，平时翻基本不用这个，作为临时或救急使用&lt;/p&gt;

&lt;p&gt;防止被监测，使用”X”代替了”.”&lt;/p&gt;

&lt;p&gt;所以使用方法，将”X”全部替换为”.”&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;浏览网页&lt;/h3&gt;

&lt;p&gt;74X126X180X61&lt;/p&gt;

&lt;p&gt;74X126X180X62&lt;/p&gt;

&lt;p&gt;74X126X180X58&lt;/p&gt;

&lt;p&gt;74X126X180X60&lt;/p&gt;

&lt;p&gt;74X126X180X59&lt;/p&gt;

&lt;p&gt;192X210X48X213&lt;/p&gt;

&lt;p&gt;192X210X48X214&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;下载&lt;/h3&gt;

&lt;p&gt;98X126X10X10&lt;/p&gt;

&lt;p&gt;98X126X10X11&lt;/p&gt;

&lt;p&gt;98X126X10X13&lt;/p&gt;

&lt;p&gt;98X126X10X14&lt;/p&gt;

&lt;p&gt;74X126X176X138&lt;/p&gt;

&lt;p&gt;74X126X176X139&lt;/p&gt;

&lt;p&gt;74X126X176X140&lt;/p&gt;

&lt;p&gt;74X126X176X142&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;视频专线&lt;/h3&gt;

&lt;p&gt;104X238X156X110&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;游戏&lt;/h3&gt;

&lt;p&gt;23X247X65X12&lt;/p&gt;

&lt;p&gt;23X247X65X33&lt;/p&gt;

&lt;p&gt;23X247X65X37&lt;/p&gt;

&lt;p&gt;23X247X65X38&lt;/p&gt;

&lt;p&gt;107X179X92X78&lt;/p&gt;

&lt;p&gt;107X179X92X93&lt;/p&gt;

&lt;p&gt;174X139X118X53&lt;/p&gt;

&lt;p&gt;174X139X118X54&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;海淘&lt;/h3&gt;

&lt;p&gt;98X126X222X147&lt;/p&gt;

&lt;p&gt;98X126X222X149&lt;/p&gt;

&lt;p&gt;98X126X222X150&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;日本网页&lt;/h3&gt;

&lt;p&gt;133X130X62X172&lt;/p&gt;

&lt;p&gt;133X130X55X57&lt;/p&gt;

&lt;p&gt;133X130X52X67&lt;/p&gt;

&lt;p&gt;106X185X47X87&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;下载&lt;/h3&gt;

&lt;p&gt;27X120X113X154&lt;/p&gt;

&lt;p&gt;106X185X35X12&lt;/p&gt;

&lt;p&gt;106X185X41X7&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;日海淘&lt;/h3&gt;
&lt;p&gt;106X185X49X209&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>关于我</title>
        <link>http://fankcoder.github.io//2015/11/10/about-me.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/11/10/about-me.html</guid>
        <pubDate>Tue, 10 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;h4 id=&quot;section&quot;&gt;我的标签&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Pythoner / Linux爱好者 / 玩Routeros / vim党 / INTJ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;技能体系&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;操作系统:  Ubuntu(日常开发) / Fedora(折腾) / CentOS(折腾,配置LNMP) / OSX(入门)

语言:  
       Python(熟练,主力)
       Shell(辅助)
       JavaScript(辅助)
       Java(学生时期)
       C(Linux下重新认识中)

数据库: MySQL / Mongodb / Redis

其他:  数据结构 / 算法 / Django MVC / 机算机网络 / Routeros网络管理(远程管理,PCC负载均衡,VPN等)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;痕迹&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/fankcoder&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.zhihu.com/people/si-xie-san-qiu&quot;&gt;知乎&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://weibo.com/2424646683/profile?topnav=1&amp;amp;wvr=6&amp;amp;is_all=1&quot;&gt;微博&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://fankcoder.com/&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;常用邮箱: zf.ice@qq.com&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;目前&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;奋斗&amp;amp;修炼ing
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;技术目标&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;短期: 全栈工程师
长期:  CTO
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Shell每日发邮件</title>
        <link>http://fankcoder.github.io//2015/10/26/email-shell-linux.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/10/26/email-shell-linux.html</guid>
        <pubDate>Mon, 26 Oct 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;很是好奇运维工作，刚好有幸接触到，每日发邮件脚本，多用来发送服务器日志，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LOGFILE=&quot;$fank/&quot;`date +&quot;%Y%m%d&quot;`&quot;data&quot;#每日文件

from=&quot;abc@123.com&quot;#发件人

recipients=&quot;fank@123.com&quot;#收件人


subject=&quot;[REPORT]every day check&quot; #主题
content=&quot;$(cat ${LOGFILE})&quot;  #内容

/usr/sbin/sendmail &quot;${recipients}&quot; &amp;lt;&amp;lt;EOF
subject:${subject}
from:${from}
${content}
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*该脚本需要部署在服务器定时任务crontab上&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Python密码处理</title>
        <link>http://fankcoder.github.io//2015/10/13/passwd-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/10/13/passwd-python.html</guid>
        <pubDate>Tue, 13 Oct 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;python密码处理(可用于生产模式)
　　
```
import os
from hashlib import sha256
from hmac import HMAC&lt;/p&gt;

&lt;p&gt;def encrypt_password(password, salt=None):
    “&quot;”Hash password on the fly.”””
    if salt is None:
        salt = os.urandom(8) # 64 bits.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assert 8 == len(salt)
assert isinstance(salt, str)

if isinstance(password, unicode):
    password = password.encode(&#39;UTF-8&#39;)

assert isinstance(password, str)

result = password
for i in xrange(10):
    result = HMAC(result, salt, sha256).digest()

return salt + result ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里先随机生成 64 bits 的 salt，再选择 SHA-256 算法使用 HMAC 对密码和 salt 进行 10 次叠代混淆，最后将 salt 和 hash 结果一起返回。&lt;/p&gt;

&lt;p&gt;使用的方法很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hashed = encrypt_password(&#39;secret password&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是验证函数，它直接使用 encrypt_password 来对密码进行相同的单向转换并比较&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def validate_password(hashed, input_password):
    return hashed == encrypt_password(input_password, salt=hashed[:8])

assert validate_password(hashed, &#39;secret password&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;密码项目代码查看&lt;a href=&quot;https://github.com/fankcoder/ShowMeTheCode&quot;&gt;show me the code&lt;/a&gt;下 s21/ 目录&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Python标准库os</title>
        <link>http://fankcoder.github.io//2015/10/12/os-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/10/12/os-python.html</guid>
        <pubDate>Mon, 12 Oct 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;os模块包含普遍的操作系统功能。&lt;/p&gt;

&lt;p&gt;如果你希望你的程序能够与平台无关的话，这个模块是尤为重要的。&lt;/p&gt;

&lt;p&gt;即它允许一个程序在编写后不需要任何改动，也不会发生任何问题，就可以在Linux和Windows下运行。一个例子就是使用os.sep可以取代操作系统特定的路径分割符。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;os.name字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.getcwd()函数得到当前工作目录，即当前Python脚本工作的目录路径。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.getenv()和os.putenv()函数分别用来读取和设置环境变量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.listdir()返回指定目录下的所有文件和目录名。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.remove()函数用来删除一个文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.system()函数用来运行shell命令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.linesep字符串给出当前平台使用的行终止符。例如，Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.path.split()函数返回一个路径的目录名和文件名。&lt;/p&gt;

    &lt;p&gt;例如：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;os.path.split(&#39;/home/swaroop/byte/code/poem.txt&#39;)
  
(&#39;/home/swaroop/byte/code&#39;, &#39;poem.txt&#39;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.path.isfile()和os.path.isdir()函数分别检验给出的路径是一个文件还是目录。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.path.existe()函数用来检验给出的路径是否真地存在。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>2015阅读书单</title>
        <link>http://fankcoder.github.io//2015/10/01/book-list-of-2015.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/10/01/book-list-of-2015.html</guid>
        <pubDate>Thu, 01 Oct 2015 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;程序员的呐喊&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;status: 已读&lt;/li&gt;
  &lt;li&gt;author: steve yegge&lt;/li&gt;
  &lt;li&gt;publisher: 人民邮电出版社&lt;/li&gt;
  &lt;li&gt;language: 中文&lt;/li&gt;
  &lt;li&gt;link: https://book.douban.com/subject/25884108/&lt;/li&gt;
  &lt;li&gt;notes:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;小学和中学里教的绝大部分数学都是连续的，也就是实数上的数学。而对计算机科学家来说，95％有趣的数学都是离散的，也就是整数上的数学。

我在招人的时候有一个诀窍。就是在寻找优秀的软件工程师“通才”的时候，通常在简历上你可以看到到各种让你觉得不行的关键字和词，但“编译器”是我唯一感兴趣的词。

 C是必修课
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;comment:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;作者先将各个语言都批评了一遍,最被嫌弃的语言是C++(多大仇&amp;gt;.&amp;lt;),作者最爱用的语言是Ruby,作者作为一个在IT界驰骋多年的老将,这个细节确实让我思考了一些东西,首先语言只是作为一种工具,工具虽分好用与否,但是永远陷入工具之间的选择、争辩是非常不明智的,就好像这几年特别流行的一句&quot;PHP是最好的语言&quot;这个梗,辩论工具是没有太大实际意义的,至少对我来说是这样,选择一个大趋势,提高自己编程思想才是核心竞争力.而且欧美国计算机技术比其他国家领先很多年,作者最喜欢的语言却是日本人松本行弘开发的Ruby,我觉得欧美思想确实比我们先进,我还看到过技术群里有人说自己不会去学日本人的语言..以后看到这种程序员就默默拉黑吧.

作者强调了学习编译器的重要,这也给我一个很好的深入方向,以后要安排研究编译器了,感觉很棒.

以前C学的比较浅,要在linux再玩一把C,最好能做些有意思的东西放github上.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;开源软件之道&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;status: 已读&lt;/li&gt;
  &lt;li&gt;author: 蔡俊杰&lt;/li&gt;
  &lt;li&gt;publisher: 电子工业出版社&lt;/li&gt;
  &lt;li&gt;language: 中文&lt;/li&gt;
  &lt;li&gt;link: https://book.douban.com/subject/4747758/&lt;/li&gt;
  &lt;li&gt;comment:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;抱着对开源软件的崇拜去读这书,但是读了一半就没有太大兴趣往下读了,感觉费了不少力气说明了开源软件是open不是free,但是说到不免费我就莫名奇妙对如何make money感兴趣,但是教如何赚钱的书也没法写啊..

看这本书后给自己定了个目标就是有朝一日也要向开源社区提交pull request,让自己体会一下全世界程序员一起努力的感觉~~
with the code ,change the world.

更值得一提的是github,这个网站的创建真是大大推动了开源软件的进步,注册了github帐号后,感觉到真是方便,无论是找好用的工具,还是学习别人的代码,给提高自己能力创造了及其便利的条件.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;计算机网络&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;status: 已读&lt;/li&gt;
  &lt;li&gt;author: 谢希仁&lt;/li&gt;
  &lt;li&gt;publisher: 电子工业出版社&lt;/li&gt;
  &lt;li&gt;language: 中文&lt;/li&gt;
  &lt;li&gt;comment:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;记得学生时期学习这门课，我经常坐在教室第一排，无奈学校填鸭式的教学方式，又凭着我对计算机网络的喜爱，老师讲第一章，我看第二章，讲第二章，我已经看到第四章，老师放不错的PPT时我就看PPT，学了整个学期，大多同学都不知道网线头是如何做的，还好宿舍有志同道合的小伙伴，成功将走廊里联通和移动的AP wifi,加上转接头和网线延长进了宿舍里，从此我们宿舍就成了“高速信息化宿舍”。。

最近重读一遍，感触颇深。比如在RouterOS IP -&amp;gt;ARP 列表里可以看到mac和对应ip地址，这样我就可以方便的知道是哪台电脑哪个ip网络出现问题，再看书中的描述，正是将我日常工作的行为用理论描述出来，让我更深刻的理解了本质原因。

通过这次重读，我发现学习过的知识，每当实践过后再去重新理解，就会对知识有新的认识，这是在”做过“的基础之上，更大的提高。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;计划要读的书&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/3652388/&quot;&gt;《程序员的自我修养》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/2287506/&quot;&gt;《深入理解LINUX内核》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/3012360/&quot;&gt;《C和指针》&lt;/a&gt;
想在Linux下重学C&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/25981248/&quot;&gt;《程序员健康指南》&lt;/a&gt;必读的，哈哈哈&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Python正则</title>
        <link>http://fankcoder.github.io//2015/08/25/re-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/08/25/re-python.html</guid>
        <pubDate>Tue, 25 Aug 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;整理自&lt;a href=&quot;http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html&quot;&gt;博客园&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;re&quot;&gt;re模块&lt;/h4&gt;

&lt;p&gt;Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# encoding: UTF-8
import re
 
# 将正则表达式编译成Pattern对象
pattern = re.compile(r&#39;hello&#39;)
 
# 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None
match = pattern.match(&#39;hello world!&#39;)
 
if match:
    # 使用Match获得分组信息
    print match.group()
 
### 输出 ###
# hello
re.compile(strPattern[, flag]):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。&lt;/p&gt;

&lt;p&gt;第二个参数flag是匹配模式，取值可以使用按位或运算符’|‘表示同时生效，比如re.I | re.M。&lt;/p&gt;

&lt;p&gt;另外，你也可以在regex字符串中指定模式，比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。 可选值有：&lt;/p&gt;

&lt;p&gt;re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）&lt;/p&gt;

&lt;p&gt;M(MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）&lt;/p&gt;

&lt;p&gt;S(DOTALL): 点任意匹配模式，改变’.’的行为&lt;/p&gt;

&lt;p&gt;L(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定&lt;/p&gt;

&lt;p&gt;U(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性&lt;/p&gt;

&lt;p&gt;X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = re.compile(r&quot;&quot;&quot;\d +  # the integral part
                   \.    # the decimal point
                   \d *  # some fractional digits&quot;&quot;&quot;, re.X)
b = re.compile(r&quot;\d+\.\d*&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;re提供了众多模块方法用于完成正则表达式的功能。这些方法可以使用Pattern实例的相应方法替代，唯一的好处是少写一行re.compile()代码，但同时也无法复用编译后的Pattern对象。这些方法将在Pattern类的实例方法部分一起介绍。如上面这个例子可以简写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;m = re.match(r&#39;hello&#39;, &#39;hello world!&#39;)
print m.group()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;re模块还提供了一个方法escape(string)，用于将string中的正则表达式元字符如*/+/?等之前加上转义符再返回，在需要大量匹配元字符时有那么一点用。&lt;/p&gt;

&lt;h4 id=&quot;match&quot;&gt;Match&lt;/h4&gt;

&lt;p&gt;Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。&lt;/p&gt;

&lt;p&gt;属性：&lt;/p&gt;

&lt;p&gt;string: 匹配时使用的文本。&lt;/p&gt;

&lt;p&gt;re: 匹配时使用的Pattern对象。&lt;/p&gt;

&lt;p&gt;pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。&lt;/p&gt;

&lt;p&gt;endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。&lt;/p&gt;

&lt;p&gt;lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。&lt;/p&gt;

&lt;p&gt;lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。方法：&lt;/p&gt;

&lt;p&gt;group([group1, …]):&lt;/p&gt;

&lt;p&gt;获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。&lt;/p&gt;

&lt;p&gt;groups([default]):&lt;/p&gt;

&lt;p&gt;以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。&lt;/p&gt;

&lt;p&gt;groupdict([default]):&lt;/p&gt;

&lt;p&gt;返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。&lt;/p&gt;

&lt;p&gt;start([group]):&lt;/p&gt;

&lt;p&gt;返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。&lt;/p&gt;

&lt;p&gt;end([group]):&lt;/p&gt;

&lt;p&gt;返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。&lt;/p&gt;

&lt;p&gt;span([group]):&lt;/p&gt;

&lt;p&gt;返回(start(group), end(group))。&lt;/p&gt;

&lt;p&gt;expand(template):&lt;/p&gt;

&lt;p&gt;将匹配到的分组代入template中然后返回。template中可以使用\id或\g&lt;id&gt;、\g&lt;name&gt;引用分组，但不能使用编号0。\id与\g&lt;id&gt;是等价的；但\10将被认为是第10个分组，如果你想表达\1之后是字符&#39;0&#39;，只能使用\g&amp;lt;1&amp;gt;0。&lt;/id&gt;&lt;/name&gt;&lt;/id&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
m = re.match(r&#39;(\w+) (\w+)(?P&amp;lt;sign&amp;gt;.*)&#39;, &#39;hello world!&#39;)
 
print &quot;m.string:&quot;, m.string
print &quot;m.re:&quot;, m.re
print &quot;m.pos:&quot;, m.pos
print &quot;m.endpos:&quot;, m.endpos
print &quot;m.lastindex:&quot;, m.lastindex
print &quot;m.lastgroup:&quot;, m.lastgroup
 
print &quot;m.group(1,2):&quot;, m.group(1, 2)
print &quot;m.groups():&quot;, m.groups()
print &quot;m.groupdict():&quot;, m.groupdict()
print &quot;m.start(2):&quot;, m.start(2)
print &quot;m.end(2):&quot;, m.end(2)
print &quot;m.span(2):&quot;, m.span(2)
print r&quot;m.expand(r&#39;\2 \1\3&#39;):&quot;, m.expand(r&#39;\2 \1\3&#39;)
 
### output ###
# m.string: hello world!
# m.re: &amp;lt;_sre.SRE_Pattern object at 0x016E1A38&amp;gt;
# m.pos: 0
# m.endpos: 12
# m.lastindex: 3
# m.lastgroup: sign
# m.group(1,2): (&#39;hello&#39;, &#39;world&#39;)
# m.groups(): (&#39;hello&#39;, &#39;world&#39;, &#39;!&#39;)
# m.groupdict(): {&#39;sign&#39;: &#39;!&#39;}
# m.start(2): 6
# m.end(2): 11
# m.span(2): (6, 11)
# m.expand(r&#39;\2 \1\3&#39;): world hello!
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;pattern&quot;&gt;Pattern&lt;/h4&gt;
&lt;p&gt;Pattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。&lt;/p&gt;

&lt;p&gt;Pattern不能直接实例化，必须使用re.compile()进行构造。&lt;/p&gt;

&lt;p&gt;Pattern提供了几个可读属性用于获取表达式的相关信息：&lt;/p&gt;

&lt;p&gt;pattern: 编译时用的表达式字符串。&lt;/p&gt;

&lt;p&gt;flags: 编译时用的匹配模式。数字形式。&lt;/p&gt;

&lt;p&gt;groups: 表达式中分组的数量。&lt;/p&gt;

&lt;p&gt;groupindex: 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
p = re.compile(r&#39;(\w+) (\w+)(?P&amp;lt;sign&amp;gt;.*)&#39;, re.DOTALL)
 
print &quot;p.pattern:&quot;, p.pattern
print &quot;p.flags:&quot;, p.flags
print &quot;p.groups:&quot;, p.groups
print &quot;p.groupindex:&quot;, p.groupindex
 
### output ###
# p.pattern: (\w+) (\w+)(?P&amp;lt;sign&amp;gt;.*)
# p.flags: 16
# p.groups: 3
# p.groupindex: {&#39;sign&#39;: 3}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;实例方法[&lt;/td&gt;
      &lt;td&gt;re模块方法]：&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;match(string[, pos[, endpos]])&lt;/td&gt;
      &lt;td&gt;re.match(pattern, string[, flags]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这个方法将从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。 
pos和endpos的默认值分别为0和len(string)；re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。&lt;/p&gt;

&lt;p&gt;注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;search(string[, pos[, endpos]])&lt;/td&gt;
      &lt;td&gt;re.search(pattern, string[, flags]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这个方法用于查找字符串中可以匹配成功的子串。从string的pos下标处起尝试匹配pattern，如果pattern结束时仍可匹配，则返回一个Match对象；若无法匹配，则将pos加1后重新尝试匹配；直到pos=endpos时仍无法匹配则返回None。&lt;/p&gt;

&lt;p&gt;pos和endpos的默认值分别为0和len(string))；re.search()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# encoding: UTF-8 
import re 
 
# 将正则表达式编译成Pattern对象 
pattern = re.compile(r&#39;world&#39;) 
 
# 使用search()查找匹配的子串，不存在能匹配的子串时将返回None 
# 这个例子中使用match()无法成功匹配 
match = pattern.search(&#39;hello world!&#39;) 
 
if match: 
    # 使用Match获得分组信息 
    print match.group() 
 
### 输出 ### 
# world
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;split(string[, maxsplit])&lt;/td&gt;
      &lt;td&gt;re.split(pattern, string[, maxsplit]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
 
p = re.compile(r&#39;\d+&#39;)
print p.split(&#39;one1two2three3four4&#39;)
 
### output ###
# [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;findall(string[, pos[, endpos]])&lt;/td&gt;
      &lt;td&gt;re.findall(pattern, string[, flags]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;搜索string，以列表形式返回全部能匹配的子串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
 
p = re.compile(r&#39;\d+&#39;)
print p.findall(&#39;one1two2three3four4&#39;)
 
### output ###
# [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;finditer(string[, pos[, endpos]])&lt;/td&gt;
      &lt;td&gt;re.finditer(pattern, string[, flags]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
 
p = re.compile(r&#39;\d+&#39;)
for m in p.finditer(&#39;one1two2three3four4&#39;):
    print m.group(),
 
### output ###
# 1 2 3 4
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;sub(repl, string[, count])&lt;/td&gt;
      &lt;td&gt;re.sub(pattern, repl, string[, count]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;使用repl替换string中每一个匹配的子串后返回替换后的字符串。&lt;/p&gt;

&lt;p&gt;当repl是一个字符串时，可以使用\id或\g&lt;id&gt;、\g&lt;name&gt;引用分组，但不能使用编号0。&lt;/name&gt;&lt;/id&gt;&lt;/p&gt;

&lt;p&gt;当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。&lt;/p&gt;

&lt;p&gt;count用于指定最多替换次数，不指定时全部替换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
 
p = re.compile(r&#39;(\w+) (\w+)&#39;)
s = &#39;i say, hello world!&#39;
 
print p.sub(r&#39;\2 \1&#39;, s)
 
def func(m):
    return m.group(1).title() + &#39; &#39; + m.group(2).title()
 
print p.sub(func, s)
 
### output ###
# say i, world hello!
# I Say, Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;subn(repl, string[, count])&lt;/td&gt;
      &lt;td&gt;re.sub(pattern, repl, string[, count]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;返回 (sub(repl, string[, count]), 替换次数)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
 
p = re.compile(r&#39;(\w+) (\w+)&#39;)
s = &#39;i say, hello world!&#39;
 
print p.subn(r&#39;\2 \1&#39;, s)
 
def func(m):
    return m.group(1).title() + &#39; &#39; + m.group(2).title()
 
print p.subn(func, s)
 
### output ###
# (&#39;say i, world hello!&#39;, 2)
# (&#39;I Say, Hello World!&#39;, 2)
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>Python内置函数(map、reduce、filter)</title>
        <link>http://fankcoder.github.io//2015/08/11/func-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/08/11/func-python.html</guid>
        <pubDate>Tue, 11 Aug 2015 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;map&quot;&gt;map&lt;/h3&gt;

&lt;p&gt;map(…)
    map(function, sequence[, sequence, …]) -&amp;gt; list 说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对sequence中的item依次执行function(item)，执行结果输出为list。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; map(str, range(5))           #对range(5)各项进行str操作
[&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]        #返回列表
&amp;gt;&amp;gt;&amp;gt; def add(n):return n+n
... 
&amp;gt;&amp;gt;&amp;gt; map(add, range(5))           #对range(5)各项进行add操作
[0, 2, 4, 6, 8]
&amp;gt;&amp;gt;&amp;gt; map(lambda x:x+x,range(5))   #lambda 函数，各项+本身
[0, 2, 4, 6, 8]
&amp;gt;&amp;gt;&amp;gt; map(lambda x:x+1,range(10))  #lambda 函数，各项+1
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;reduce&quot;&gt;reduce&lt;/h3&gt;

&lt;p&gt;reduce(…)
    reduce(function, sequence[, initial]) -&amp;gt; value 说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对sequence中的item顺序迭代调用function，函数必须要有2个参数。要是有第3个参数，则表示初始值，可以继续调用初始值，返回一个值。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def add(x,y):return x+y
... 
&amp;gt;&amp;gt;&amp;gt; reduce(add,range(10))        #1+2+3+...+9
45
&amp;gt;&amp;gt;&amp;gt; reduce(add,range(11))        #1+2+3+...+10
55
&amp;gt;&amp;gt;&amp;gt; reduce(lambda x,y:x*y,range(1,3),5)           #lambda 函数，5是初始值， 1*2*5
10
&amp;gt;&amp;gt;&amp;gt; reduce(lambda x,y:x*y,range(1,6))             #阶乘，1*2*3*4*5
120
&amp;gt;&amp;gt;&amp;gt; reduce(lambda x,y:x*y,range(1,6),3)           #初始值3，结果再*3
360
&amp;gt;&amp;gt;&amp;gt; reduce(lambda x,y:x+y,[1,2,3,4,5,6])          #1+2+3+4+5+6
21 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;filter&quot;&gt;filter&lt;/h3&gt;

&lt;p&gt;filter(…)
    filter(function or None, sequence) -&amp;gt; list, tuple, or string 说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对sequence中的item依次执行function(item)，将执行结果为True（！=0）的item组成一个List/String/Tuple（取决于sequence的类型）返回，False则退出（0），进行过滤。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def div(n):return n%2
... 
&amp;gt;&amp;gt;&amp;gt; filter(div,range(5))                    #返回div输出的不等于0的真值
[1, 3]
&amp;gt;&amp;gt;&amp;gt; filter(div,range(10))
[1, 3, 5, 7, 9]
&amp;gt;&amp;gt;&amp;gt; filter(lambda x : x%2,range(10))        #lambda 函数返回奇数，返回列表
[1, 3, 5, 7, 9]
&amp;gt;&amp;gt;&amp;gt; filter(lambda x : not x%2,range(10))
[0, 2, 4, 6, 8]
&amp;gt;&amp;gt;&amp;gt; def fin(n):return n!=&#39;f&#39;                #过滤&#39;z&#39; 函数，出现z则返回False
... 
&amp;gt;&amp;gt;&amp;gt; filter(fin,&#39;fankcoder&#39;)                    #&#39;z&#39;被过滤
&#39;ankcoder&#39;
&amp;gt;&amp;gt;&amp;gt; filter(lambda x : x !=&#39;f&#39;,&#39;fankcoder&#39;)     #labmda返回True值
&#39;ankcoder&#39;
&amp;gt;&amp;gt;&amp;gt; filter(lambda x : not x==&#39;f&#39;,&#39;fankcoder&#39;)  #返回：字符串
&#39;ankcoder&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>AWK</title>
        <link>http://fankcoder.github.io//2015/07/25/awk-linux.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/07/25/awk-linux.html</guid>
        <pubDate>Sat, 25 Jul 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;Awk是一种便于使用且表达能力强的程序设计语言，可应用于各种计算和数据处理任务。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;起步&lt;/h3&gt;

&lt;p&gt;有用的awk程序往往很简短，仅仅一两行。假设你有一个名为 emp.data 的文件，其中包含员工的姓名、薪资（美元/小时）以及小时数，一个员工一行数据，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Beth	4.00	0
Dan	3.75	0
kathy	4.00	10
Mark	5.00	20
Mary	5.50	22
Susie	4.25	18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你想打印出工作时间超过零小时的员工的姓名和工资（薪资乘以时间）。这种任务对于awk来说就是小菜一碟。输入这个命令行就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;awk &#39;$3 &amp;gt;0 { print $1, $2 * $3 }&#39; emp.data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你应该会得到如下输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Kathy 40
Mark 100
Mary 121
Susie 76.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令行告诉系统执行引号内的awk程序，从输入文件 emp.data 获取程序所需的数据。引号内的部分是个完整的awk程序，包含单个模式-动作语句。模式 $3&amp;gt;0 用于匹配第三列大于0的输入行，动作:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ print $1, $2 * $3 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印每个匹配行的第一个字段以及第二第三字段的乘积。&lt;/p&gt;

&lt;p&gt;如果你想打印出还没工作过的员工的姓名，则输入命令行：:&lt;/p&gt;

&lt;p&gt;awk ‘$3 == 0 { print $1 }’ emp.data
这里，模式 $3 == 0 匹配第三个字段等于0的行，动作:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ awk ‘$3 &amp;gt; 0 { print $1, $2 * $3 }’ emp.data
Kathy 40
Mark 100
Mary 121
Susie 76.5
$ awk ‘$3 == 0 { print $1 }’ emp.data
Beth
Dan
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;行首的 $ 是系统提示符，也许在你的机器上不一样。&lt;/p&gt;

&lt;h3 id=&quot;awk&quot;&gt;AWK程序的结构&lt;/h3&gt;

&lt;p&gt;上述的命令行中，引号之间的部分是awk编程语言写就的程序。&lt;/p&gt;

&lt;p&gt;awk的基本操作是一行一行地扫描输入，搜索匹配任意程序中模式的行。词语“匹配”的准确意义是视具体的模式而言，对于模式 $3 &amp;gt;0 来说，意思是“条件为真”。&lt;/p&gt;

&lt;h3 id=&quot;awk-1&quot;&gt;执行AWK程序&lt;/h3&gt;

&lt;p&gt;执行awk程序的方式有多种。你可以输入如下形式的命令行：:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;awk &#39;program&#39; input files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从而在每个指定的输入文件上执行这个program。例如，你可以输入：:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;awk &#39;$3 == 0 { print $1 }&#39; file1 file2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印file1和file2文件中第三个字段为0的每一行的第一个字段。&lt;/p&gt;

&lt;p&gt;你可以省略命令行中的输入文件，仅输入：:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;awk &#39;program&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种情况下，awk会将program应用于你在终端中接着输入的任意数据行，直到你输入一个文件结束信号（Unix系统上为control-d）。如下是Unix系统的一个会话示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ awk ‘$3 == 0 { print $1 }’
Beth 4.00 0
Beth

Dan 3.75 0
Dan

Kathy 3.75 10
Kathy 3.75 0
Kathy

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个动作非常便于尝试awk：输入你的程序，然后输入数据，观察发生了什么。&lt;/p&gt;

&lt;p&gt;注意命令行中的程序是用单引号包围着的。这会防止shell解释程序中 $ 这样的字符，也允许程序的长度超过一行。&lt;/p&gt;

&lt;p&gt;当程序比较短小（几行的长度）的时候，这种约定会很方便。然而，如果程序较长，将程序写到一个单独的文件中会更加方便。假设存在程序 progfile ，输入命令行：:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;awk -f progfile     optional list of input files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 -f 选项指示awk从指定文件中获取程序。可以使用任意文件名替换 progfile 。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;错误&lt;/h3&gt;

&lt;p&gt;如果你的awk程序存在错误，awk会给你一段诊断信息。例如，如果你打错了大括号，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;awk &#39;$3 == 0 [ print $1 }&#39; emp.data
你会得到如下信息：

awk: syntax error at source line 1
context is
$3 == 0 &amp;gt;&amp;gt;&amp;gt; [ &amp;lt;&amp;lt;&amp;lt;
extra }
missing ]
awk: bailing out at source line 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“Syntax error”意味着在 »&amp;gt; «&amp;lt; 标记的地方检测到语法错误。“Bailing out”意味着没有试图恢复。有时你会得到更多的帮助-关于错误是什么，比如大括号或括弧不匹配。&lt;/p&gt;

&lt;p&gt;因为存在句法错误，awk就不会尝试执行这个程序。然而，有些错误，直到你的程序被执行才会检测出来。&lt;/p&gt;

&lt;h3 id=&quot;nf-&quot;&gt;NF, 字段数量&lt;/h3&gt;

&lt;p&gt;Awk会对当前输入的行有多少个字段进行计数, 并且将当前行的字段数量存 储在一个内建的称作 NF 的变量中. 因此, 下面的程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ print NF, $1, $NF }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会依次打印出每一行的字段数量, 第一个字段的值, 最后一个字段的值.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;打印行号&lt;/h3&gt;

&lt;p&gt;Awk提供了另一个内建变量, 叫做 NR, 它会存储当前已经读取了多少行的计数. 我们可以使用 NR 和 $0 给 emp.data 的没一行加上行号:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ print NR, $0 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印的输出看起来会是这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 Beth   4.00     0
2 Dan    3.75     0
3 Kathy  4.00    10
4 Mark   5.00    20
5 Mary   5.50    22
6 Susie  4.25   1 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在输出中添加内容&lt;/p&gt;

&lt;p&gt;你当然也可以在字段中间或者计算的值中间打印输出想要的内容:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ print &quot;total pay for&quot;, $1, &quot;is&quot;, $2 * $3 }
输出

total pay for Beth is 0
total pay for Dan is 0
total pay for Kathy is 40
total pay for Mark is 100
total pay for Mary is 121
total pay for Susie is 76.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在打印语句中, 双引号内的文字将会在字段和计算的值中插入输出.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;高级输出&lt;/h3&gt;

&lt;p&gt;print 语句可用于快速而简单的输出。若要严格按照你所想的格式化输出，则需要使用 printf 语句。 printf 几乎可以产生任何形式的输出&lt;/p&gt;

&lt;p&gt;printf 语句的形式如下：:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;printf(format, value1, value2, ..., valuen)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 format 是字符串，包含要逐字打印的文本，穿插着 format 之后的每个值该如何打印的规格(specification)。一个规格是一个 % 符，后面跟着一些字符，用来控制一个 value 的格式。第一个规格说明如何打印 value1 ，第二个说明如何打印 value2 ，… 。因此，有多少 value 要打印，在 format 中就要有多少个 % 规格。&lt;/p&gt;

&lt;p&gt;使用 printf 打印每位员工的总薪酬：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ printf(&quot;total pay for %s is $%.2f\n&quot;, $1, $2 * $3) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;printf 语句中的规格字符串包含两个 % 规格。第一个是 %s ，说明以字符串的方式打印第一个值 $1 。第二个是 %.2f ，说明以数字的方式打印第二个值 $2*$3 ，并保留小数点后面两位。规格字符串中其他东西，包括美元符号，仅逐字打印。字符串尾部的 \n 代表开始新的一行，使得后续输出将从下一行开始。以 emp.data 为输入，该程序产生：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;total pay for Beth is $0.00
total pay for Dan is $0.00
total pay for Kathy is $40.00
total pay for Mark is $100.00
total pay for Mary is $121.00
total pay for Susie is $76.50
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;printf 不会自动产生空格或者新的行，必须是你自己来创建，所以不要忘了 \n 。&lt;/p&gt;

&lt;p&gt;打印每位员工的姓名与薪酬：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ printf(&quot;%-8s $%6.2f\n&quot;, $1, $2 * $3) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个规格 %-8s 将一个姓名以字符串形式在8个字符宽度的字段中左对齐输出。第二个规格 %6.2f 将薪酬以数字的形式，保留小数点后两位，在6个字符宽度的字段中输出。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Beth     $  0.00
Dan      $  0.00
Kathy    $ 40.00
Mark     $100.00
Mary     $121.00
Susie    $ 76.50
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后我们将展示更多的 printf 示例。一切精彩尽在2.4小节。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;排序输出&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;awk &#39;{ printf(&quot;%6.2f    %s\n&quot;, $2 * $3, $0) }&#39; emp.data | sort
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将awk的输出通过管道传给 sort 命令，输出为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  0.00    Beth  4.00 0
  0.00    Dan   3.75 0
 40.00    Kathy 4.00 10
 76.50    Susie 4.25 18
100.00    Mark  5.00 20
121.00    Mary  5.50 22
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;选择&lt;/h3&gt;

&lt;p&gt;对比选择&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$2 * $3 &amp;gt; 50 { printf(&quot;$%.2f for %s\n&quot;, $2 * $3, $1) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印出总薪资超过50美元的员工的薪酬。&lt;/p&gt;

&lt;p&gt;文本内容选择&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$1 == &quot;Susie&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;操作符 == 用于测试相等性。你也可以使用称为 正则表达式 的模式查找包含任意字母组合，单词或短语的文本。这个程序打印任意位置包含 Susie 的行：&lt;/p&gt;

&lt;p&gt;/Susie/
输出为这一行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Susie   4.25    18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正则表达式可用于指定复杂的多的模式&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;模式组合&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;可以使用括号和逻辑操作符与 &amp;amp;&amp;amp; ， 或&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;， 以及非 ! 对模式进行组合。程序:&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;$2 &amp;gt;= 4 || $3 &amp;gt;= 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会打印 $2 (第二个字段) 大于等于 4 或者 $3 (第三个字段) 大于等于 20 的行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Beth    4.00    0
kathy   4.00    10
Mark    5.00    20
Mary    5.50    22
Susie   4.25    18
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;beginend&quot;&gt;BEGIN与END&lt;/h3&gt;

&lt;p&gt;特殊模式 BEGIN 用于匹配第一个输入文件的第一行之前的位置， END 则用于匹配处理过的最后一个文件的最后一行之后的位置。这个程序使用 BEGIN 来输出一个标题：:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BEGIN { print &quot;Name    RATE    HOURS&quot;; print &quot;&quot;}
      { print }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NAME    RATE    HOURS

Beth    4.00    0
Dan     3.75    0
Kathy   4.00    10
Mark    5.00    20
Mary    5.50    22
Susie   4.25    18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序的动作部分你可以在一行上放多个语句，不过要使用分号进行分隔。注意 普通的 print 是打印当前输入行，与之不同的是 print “” 会打印一个空行。&lt;/p&gt;

&lt;h3 id=&quot;awk-2&quot;&gt;使用AWK进行计算&lt;/h3&gt;

&lt;h4 id=&quot;section-7&quot;&gt;计数&lt;/h4&gt;

&lt;p&gt;这个程序使用一个变量 emp 来统计工作超过15个小时的员工的数目：:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$3 &amp;gt; 15 { emp = emp + 1 }
END     { print emp, &quot;employees worked more than 15 hours&quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于第三个字段超过15的每行， emp 的前一个值加1。以 emp.data 为输入，该程序产生：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 employees worked more than 15 hours
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用作数字的awk变量的默认初始值为0，所以我们不需要初始化 emp 。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;求和与平均值&lt;/h4&gt;

&lt;p&gt;为计算员工的数目，我们可以使用内置变量 NR ，它保存着到目前位置读取的行数；在所有输入的结尾它的值就是所读的所有行数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;END { print NR, &quot;employees&quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出为：&lt;/p&gt;

&lt;p&gt;6 employees&lt;/p&gt;

&lt;p&gt;如下是一个使用 NR 来计算薪酬均值的程序：:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { pay = pay + $2 * $3 }
END { print NR, &quot;employees&quot;
      print &quot;total pay is&quot;, pay
      print &quot;average pay is&quot;, pay/NR
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个动作累计所有员工的总薪酬。 END 动作打印出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;6 employees
total pay is 337.5
average pay is 56.25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显， printf 可用来产生更简洁的输出。并且该程序也有个潜在的错误：在某种不太可能发生的情况下， NR 等于0，那么程序会试图执行零除，从而产生错误信息。&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;字符串连接&lt;/h4&gt;

&lt;p&gt;可以合并老字符串来创建新字符串。这种操作称为 连接（concatenation） 。程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { names = names $1 &quot; &quot;}
END { print names }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过将每个姓名和一个空格附加到变量 names 的前一个值， 来将所有员工的姓名收集进单个字符串中。最后 END 动作打印出 names 的值：&lt;/p&gt;

&lt;p&gt;Beth Dan Kathy Mark Mary Susie&lt;/p&gt;

&lt;p&gt;awk程序中，连接操作的表现形式是将字符串值一个接一个地写出来。对于每个输入行，程序的第一个语句先连接三个字符串： names 的前一个值、当前行的第一个字段以及一个空格，然后将得到的字符串赋值给 names 。&lt;/p&gt;

&lt;p&gt;因此，读取所有的输入行之后， names 就是个字符串，包含所有员工的姓名，每个姓名后面跟着一个空格。用于保存字符串的变量的默认初始值是空字符串(也就是说该字符串包含零个字符)，因此这个程序中的 names 不需要显式初始化。&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;内置函数&lt;/h4&gt;

&lt;p&gt;我们已看到awk提供了内置变量来保存某些频繁使用的数量，比如：字段的数量和输入行的数量。类似地，也有内置函数用来计算其他有用的数值。除了平方根、对数、随机数诸如此类的算术函数，也有操作文本的函数。其中之一是 length ，计算一个字符串中的字符数量。例如，这个程序会计算每个人的姓名的长度：:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ print $1, length($1) }
结果：:

Beth 4
Dan 3
Kathy 5
Mark 4
Mary 4
Susie 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;行、单词以及字符的计数&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;控制语句&lt;/h3&gt;

&lt;p&gt;Awk为选择提供了一个 if-else 语句，以及为循环提供了几个语句，所以都效仿C语言中对应的控制语句。它们仅可以在动作中使用。&lt;/p&gt;

&lt;h4 id=&quot;if-else&quot;&gt;if-else语句&lt;/h4&gt;

&lt;p&gt;如下程序将计算时薪超过6美元的员工的总薪酬与平均薪酬。它使用一个 if 来防范计算平均薪酬时的零除问题。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$2 &amp;gt; 6 { n = n + 1; pay = pay + $2 * $3 }
END    { if (n &amp;gt; 0)
            print n, &quot;employees, total pay is&quot;, pay,
                     &quot;average pay is&quot;, pay/n
         else
             print &quot;no employees are paid more than $6/hour&quot;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;emp.data 的输出是：:&lt;/p&gt;

&lt;p&gt;no employees are paid more than $6/hour&lt;/p&gt;

&lt;p&gt;if-else 语句中，if 后的条件会被计算。如果为真，执行第一个 print 语句。否则，执行第二个 print 语句。注意我们可以使用一个逗号将一个长语句截断为多行来书写。&lt;/p&gt;

&lt;p&gt;while语句&lt;/p&gt;

&lt;p&gt;一个 while 语句有一个条件和一个执行体。条件为真时执行体中的语句会被重复执行。这个程序使用公式&lt;/p&gt;

&lt;p&gt;value=amount(1+rate)yearsvalue=amount(1+rate)years&lt;/p&gt;

&lt;p&gt;来演示以特定的利率投资一定量的钱，其数值是如何随着年数增长的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# interest1 - 计算复利
#   输入: 钱数    利率    年数
#   输出: 复利值

{   i = 1
    while (i &amp;lt;= $3) {
        printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)
        i = i + 1
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件是 while 后括弧包围的表达式；循环体是条件后大括号包围的两个表达式。 printf 规格字符串中的 \t 代表制表符； ^ 是指数操作符。从 # 开始到行尾的文本是注释，会被awk忽略，但能帮助程序的读者理解程序做的事情。&lt;/p&gt;

&lt;h4 id=&quot;for&quot;&gt;for语句&lt;/h4&gt;

&lt;p&gt;另一个语句， for ，将大多数循环都包含的初始化、测试、以及自增压缩成一行。如下是之前利息计算的 for 版本：:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# interest1 - 计算复利
#   输入: 钱数    利率    年数
#   输出: 每年末的复利

{ for (i = 1; i &amp;lt;= $3; i = i + 1)
    printf(&quot;\t%.2f\n&quot;, $1 * (1 + $2) ^ i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化 i = 1 只执行一次。接下来，测试条件 i &amp;lt;= $3 ；如果为真，则执行循环体的 printf 语句。循环体执行结束后执行自增 i = i + 1 ，接着由另一次条件测试开始下一个循环迭代。代码更加紧凑，并且由于循环体仅是一条语句，所以不需要大括号来包围它。&lt;/p&gt;

&lt;h3 id=&quot;section-12&quot;&gt;数组&lt;/h3&gt;

&lt;p&gt;awk为存储一组相关的值提供了数组。虽然数组给予了awk很强的能力，但在这里我们仅展示一个简单的例子。如下程序将按行逆序打印输入。第一个动作将输入行存为数组 line 的连续元素；即第一行放在 line[1] ，第二行放在 line[2] , 依次继续。 END 动作使用一个 while 语句从后往前打印数组中的输入行：:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 反转 - 按行逆序打印输入

    { line[NR] = $0 }  # 记下每个输入行

END { i = NR           # 逆序打印
      while (i &amp;gt; 0) {
        print line[i]
        i = i - 1
      }
    }
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以 emp.data 为输入，输出为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Susie    4.25   18
Mary     5.50   22
Mark     5.00   20
Kathy    4.00   10
Dan      3.75   0
Beth     4.00   0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下是使用 for 语句实现的相同示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
# 反转 - 按行逆序打印输入

    { line[NR] = $0 }   # 记下每个输入行

END { for (i = NR; i &amp;gt; 0; i = i - 1)
        print line[i]
    }
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
  </channel>
</rss>