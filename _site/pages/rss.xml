<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>三秋的博客</title>
    <link>http://fankcoder.github.io/</link>
    <description>三秋的博客</description>
    
      <item>
        <title>screen工具</title>
        <link>http://fankcoder.github.io//2016/03/10/screen-linux.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/03/10/screen-linux.html</guid>
        <pubDate>Thu, 10 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;screen-&quot;&gt;screen 多窗口工具&lt;/h2&gt;
&lt;p&gt;远程到服务器，通常情况下我们会为每一个长时间任务开一个远程终端窗口，操作下载东西或者Print十几万行数据，等待，是一件让人非常痛苦的事情，而且在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉了，screen把我们从痛苦中解救出来。&lt;/p&gt;

&lt;p&gt;screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。当断开或关闭终端时，只要不杀死screen的进程，待重新连接后任能继续断开前的操作。&lt;/p&gt;

&lt;h2 id=&quot;screen&quot;&gt;screen命令&lt;/h2&gt;
&lt;p&gt;查看会话：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### screen -ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a screen on:
19393.test      (Detached)
1 Socket in /var/run/screen/S-root.&lt;/p&gt;

&lt;p&gt;选择会话&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### screen -r test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### screen -r 19393
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个新会话&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### screen -dmS test
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;快捷键&lt;/h2&gt;

&lt;p&gt;C-a d 暂时断开screen会话&lt;/p&gt;

&lt;p&gt;C-a ?	显示所有键绑定信息&lt;/p&gt;

&lt;p&gt;C-a w	显示所有窗口列表&lt;/p&gt;

&lt;p&gt;C-a C-a	切换到之前显示的窗口&lt;/p&gt;

&lt;p&gt;C-a c	创建一个新的运行shell的窗口并切换到该窗口&lt;/p&gt;

&lt;p&gt;C-a n	切换到下一个窗口&lt;/p&gt;

&lt;p&gt;C-a p	切换到前一个窗口(与C-a n相对)&lt;/p&gt;

&lt;p&gt;C-a 0..9	切换到窗口0..9&lt;/p&gt;

&lt;p&gt;C-a a	发送 C-a到当前窗口&lt;/p&gt;

&lt;p&gt;C-a k	杀掉当前窗口&lt;/p&gt;

&lt;p&gt;C-a [	进入拷贝/回滚模式&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Todolist 应用</title>
        <link>http://fankcoder.github.io//2016/03/08/todolist-django-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/03/08/todolist-django-python.html</guid>
        <pubDate>Tue, 08 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;todolist&quot;&gt;TodoList&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;TodoList是一个便捷的事项管理应用,它帮助我们管理待办任务,梳理工作思路,来提高工作效率&lt;/p&gt;

&lt;p&gt;TodoList包含账户注册登录等功能,来方便记录管理你的任务事项&lt;/p&gt;

&lt;h2 id=&quot;introduce&quot;&gt;Introduce&lt;/h2&gt;
&lt;p&gt;Todolist,a quick and convenient management application for items that are about to be done,which helps us manage the to-do tasks, combine working train of thought and improve work efficency.&lt;/p&gt;

&lt;p&gt;Todolist consists of kinds of functions,including the registration and login for an account,so that it can make your tasks record and items management much easier.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;项目地址&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/fankcoder/django-todolist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##安装&amp;amp;运行
在用户目录下执行,将代码clone到本地&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/fankcoder/django-todolist.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所需环境,请看 django-todolist/doc/requirements.txt&lt;/p&gt;

&lt;p&gt;注:为了部署方便应用默认采用了sqlite3数据库,需更换为MySQL数据库,请更改settings.py如下代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;&#39;&#39;
#use mysql databases
DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;NAME&#39;: &#39;todolist&#39;,
        &#39;USER&#39;: &#39;root&#39;,    #replace your mysql username
        &#39;PASSWORD&#39;: &#39;xxxxx&#39;,  #replace your mysql password
        &#39;HOST&#39;: &#39;127.0.0.1&#39;,
        &#39;PROT&#39;: &#39;3306&#39;,
    }
}
&#39;&#39;&#39;
DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为,请注意替换为自己的MySQL用户密码.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#use mysql databases
DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,
        &#39;NAME&#39;: &#39;todolist&#39;,
        &#39;USER&#39;: &#39;root&#39;,    #replace your mysql username
        &#39;PASSWORD&#39;: &#39;xxxxx&#39;,  #replace your mysql password
        &#39;HOST&#39;: &#39;127.0.0.1&#39;,
        &#39;PROT&#39;: &#39;3306&#39;,
    }
}
&#39;&#39;&#39;
DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),
    }
}
&#39;&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##安装&amp;amp;配置完成后&lt;/p&gt;

&lt;p&gt;建立本地数据库,在django-todo/todo/目录下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py makemigrations
python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py runserver 127.0.0.1:8001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有报错,打开浏览器并访问&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127.0.0.1:8001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可看到应用已经部署成功!&lt;/p&gt;

&lt;p&gt;##目录说明
doc 为文档目录 &lt;br /&gt;
todolist 为应用目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;django-todo/
├── doc
│   ├── index.png
│   ├── login.png
│   ├── register.png
│   ├── user_done.png
│   └── user_index.png
├── README.md
├── requirements.txt
├── requirements.txt~
└── todo
    ├── db.sqlite3
    ├── manage.py
    ├── test.py
    ├── test.py~
    ├── todo
    │   ├── __init__.py
    │   ├── __init__.pyc
    │   ├── settings.py
    │   ├── settings.pyc
    │   ├── urls.py
    │   ├── urls.pyc
    │   ├── wsgi.py
    │   └── wsgi.pyc
    └── todolist
        ├── admin.py
        ├── admin.pyc
        ├── forms.py
        ├── forms.pyc
        ├── __init__.py
        ├── __init__.pyc
        ├── models.py
        ├── models.pyc
        ├── static
        │   ├── css
        │   │   ├── create_sytle.css
        │   │   └── style.css
        │   └── js
        ├── templates
        │   ├── complete.html
        │   ├── create.html
        │   ├── index.html
        │   ├── login.html
        │   ├── nav.html
        │   └── register.html
        ├── tests.py
        ├── views.py
        └── views.pyc
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Linux 常用资源</title>
        <link>http://fankcoder.github.io//2016/03/04/general-linux-resources.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/03/04/general-linux-resources.html</guid>
        <pubDate>Fri, 04 Mar 2016 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;常用指令&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;遍历创建&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mkdir -p 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;当前目录&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;pwd 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;上次目录&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd -
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;f&quot;&gt;删除目录 -f强制&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;rm -rf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;a&quot;&gt;复制目录 -a与源文件一模一样&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cp -r
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;剪切/改名&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mv
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;find&quot;&gt;find搜索&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;find /root -iname install.log  #-i不区分大小写
find /root -user root  #按照所有者搜索
find /var/log/ -mtime +10 #查找10天前修改的文件
-10 10天内修改文件
10 10天当天修改的文件
+10 10天前修改的文件
atime 文件访问时间
ctime 改变文件属性
mtime 修改文件内容

find . -size 25k
+25k 大于25k
-小于25k
M大写

find /etc -size +20k -a -size -50k
-a and 和
-o or 或

-exec ls -lh {} \;
find /etc -size +20k -a -size -50k -exec ls -lh {} \;
将第一个结果放入第二个在处理一遍
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;grep&quot;&gt;grep&lt;/h3&gt;
&lt;p&gt;grep是包含匹配搜索文件内容,find是完全匹配搜索文件名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grep &quot;size&quot; anaconda-ks.cfg
-v 取返
-i 不分大小写
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;帮助命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	man -f 查看级别相当于whatis
	whereis passwd
	ls --help选项帮助命令
	info 命令
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;zip-gz-bz2-targz-tarbz2&quot;&gt;常用压缩格式 .zip .gz .bz2 .tar.gz .tar.bz2&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;zip 压缩文件名 源文件 #压缩文件
zip -r 压缩文件名 源文件 #压缩目录

unzip 压缩文件 #解压缩

gzip 源文件 #压缩为.gz的文件,源文件会消失
gzip -c 源文件 &amp;gt; 压缩文件 #源文件保留
gzip -r 目录 #压缩目录下所有子文件,不压缩目录
gzip -d 压缩文件 #解压
gunzip 压缩文件 #解压

打包tar
tar -cvf 打包文件名 源文件
tar -xvf 解打包
tar -zcvf 压缩包名.tar.gz 源文件
tar -zxvf 压缩包名.tar.gz #解压缩
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;shutdown--&quot;&gt;shutdown [选项] 时间&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;-c 取消前一个关机命令
-h 关机
-r 重启
rboot  重启
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;mount--a-etcfatab&quot;&gt;mount -a 自动挂载/etc/fatab&lt;/h3&gt;

&lt;h3 id=&quot;w&quot;&gt;w&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;查看用户登录信息 who类似 ### last 
所有用户登录信息 /var/log/wtmp ### lastlog 
最后登录时间
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>神器收藏</title>
        <link>http://fankcoder.github.io//2016/01/28/good-tools.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/28/good-tools.html</guid>
        <pubDate>Thu, 28 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;ide&quot;&gt;编辑器 &amp;amp; IDE&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;VIM
    &lt;ul&gt;
      &lt;li&gt;gmarik/vundle&lt;/li&gt;
      &lt;li&gt;rizzatti/funcoo.vim&lt;/li&gt;
      &lt;li&gt;https://github.com/scrooloose/nerdtree.git&lt;/li&gt;
      &lt;li&gt;Modeliner&lt;/li&gt;
      &lt;li&gt;DrawIt&lt;/li&gt;
      &lt;li&gt;vim-scripts/Align&lt;/li&gt;
      &lt;li&gt;https://github.com/Lokaltog/vim-powerline.git&lt;/li&gt;
      &lt;li&gt;https://github.com/vim-scripts/taglist.vim.git&lt;/li&gt;
      &lt;li&gt;https://github.com/scrooloose/nerdcommenter.git&lt;/li&gt;
      &lt;li&gt;https://github.com/kien/ctrlp.vim.git&lt;/li&gt;
      &lt;li&gt;https://github.com/nelstrom/vim-visual-star-search.git&lt;/li&gt;
      &lt;li&gt;junegunn/goyo.vim&lt;/li&gt;
      &lt;li&gt;https://github.com/vim-scripts/Visual-Mark.git&lt;/li&gt;
      &lt;li&gt;https://github.com/mattn/emmet-vim.git&lt;/li&gt;
      &lt;li&gt;https://github.com/Shougo/neocomplcache.vim.git&lt;/li&gt;
      &lt;li&gt;https://github.com/terryma/vim-multiple-cursors.git&lt;/li&gt;
      &lt;li&gt;https://github.com/ervandew/supertab.git&lt;/li&gt;
      &lt;li&gt;https://github.com/sjl/vitality.vim.git&lt;/li&gt;
      &lt;li&gt;https://github.com/Lokaltog/vim-easymotion.git&lt;/li&gt;
      &lt;li&gt;rking/ag.vim&lt;/li&gt;
      &lt;li&gt;Valloric/YouCompleteMe&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Sublime Text
    &lt;ul&gt;
      &lt;li&gt;Abacus&lt;/li&gt;
      &lt;li&gt;ASCII Decorator&lt;/li&gt;
      &lt;li&gt;BracketHighlighter&lt;/li&gt;
      &lt;li&gt;DocBlockr&lt;/li&gt;
      &lt;li&gt;Emmet&lt;/li&gt;
      &lt;li&gt;FileDiffs&lt;/li&gt;
      &lt;li&gt;Goto-CSS-Declaration&lt;/li&gt;
      &lt;li&gt;Laravel 4 Facades&lt;/li&gt;
      &lt;li&gt;Laravel Blade Highlighter&lt;/li&gt;
      &lt;li&gt;Live CSS&lt;/li&gt;
      &lt;li&gt;Open URL&lt;/li&gt;
      &lt;li&gt;Package Control&lt;/li&gt;
      &lt;li&gt;Theme-Soda&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PhpStorm&lt;/li&gt;
  &lt;li&gt;Intellij IDEA&lt;/li&gt;
  &lt;li&gt;PyCharm&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;浏览器&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Chrome
    &lt;ul&gt;
      &lt;li&gt;Visual Event&lt;/li&gt;
      &lt;li&gt;Web Developer&lt;/li&gt;
      &lt;li&gt;XPather&lt;/li&gt;
      &lt;li&gt;Tampermonkey&lt;/li&gt;
      &lt;li&gt;Pesticide for Chrome&lt;/li&gt;
      &lt;li&gt;EditThisCookie&lt;/li&gt;
      &lt;li&gt;Clockwork&lt;/li&gt;
      &lt;li&gt;AlloyDesigner&lt;/li&gt;
      &lt;li&gt;jQuery Audit&lt;/li&gt;
      &lt;li&gt;JSONView&lt;/li&gt;
      &lt;li&gt;Octosplit&lt;/li&gt;
      &lt;li&gt;Octotree&lt;/li&gt;
      &lt;li&gt;Print GitHub markdown: GitPrint.com&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;文档 &amp;amp; 代码片段管理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;CodeBox&lt;/li&gt;
  &lt;li&gt;Dash&lt;/li&gt;
  &lt;li&gt;iDocument Plus&lt;/li&gt;
  &lt;li&gt;Sparkbox&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;调试工具 &amp;amp; 代码生成&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;CodeRunner&lt;/li&gt;
  &lt;li&gt;PAW&lt;/li&gt;
  &lt;li&gt;PaintCode&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;窗口管理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Slate&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;取色 &amp;amp; 度量&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Sip&lt;/li&gt;
  &lt;li&gt;ColorSchemer Studio&lt;/li&gt;
  &lt;li&gt;xScope&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;数据库管理&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Sequel Pro&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;屏幕录制 &amp;amp; 演示&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ScreenFlow&lt;/li&gt;
  &lt;li&gt;Zoom It&lt;/li&gt;
  &lt;li&gt;GrabIt&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;图像处理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Adobe Photoshop
    &lt;ul&gt;
      &lt;li&gt;PNG Hat&lt;/li&gt;
      &lt;li&gt;CSS Hat&lt;/li&gt;
      &lt;li&gt;Renamy&lt;/li&gt;
      &lt;li&gt;Random User Generator&lt;/li&gt;
      &lt;li&gt;Ink&lt;/li&gt;
      &lt;li&gt;GuideGuide&lt;/li&gt;
      &lt;li&gt;Griddify&lt;/li&gt;
      &lt;li&gt;FlatIcon&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Slicy&lt;/li&gt;
  &lt;li&gt;iconKit&lt;/li&gt;
  &lt;li&gt;LilyView&lt;/li&gt;
  &lt;li&gt;Mark Man&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;版本管理 &amp;amp; 比对&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Tower&lt;/li&gt;
  &lt;li&gt;Github&lt;/li&gt;
  &lt;li&gt;Kaleidoscope&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;脑图 &amp;amp; 任务&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;OmniPlan&lt;/li&gt;
  &lt;li&gt;OmniGraffle&lt;/li&gt;
  &lt;li&gt;MindNode Pro&lt;/li&gt;
  &lt;li&gt;Things&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;vnc&quot;&gt;虚拟机 &amp;amp; VNC&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;VirtualBox&lt;/li&gt;
  &lt;li&gt;VMWare Fusion&lt;/li&gt;
  &lt;li&gt;Jump Desktop&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;效率&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Alfred&lt;/li&gt;
  &lt;li&gt;PopClip&lt;/li&gt;
  &lt;li&gt;Soulver&lt;/li&gt;
  &lt;li&gt;Caffeine&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-11&quot;&gt;其他&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Sdef Editor&lt;/li&gt;
  &lt;li&gt;HopperDisassembler&lt;/li&gt;
  &lt;li&gt;Leaf&lt;/li&gt;
  &lt;li&gt;iTerm&lt;/li&gt;
  &lt;li&gt;ForkLift&lt;/li&gt;
  &lt;li&gt;GoAgentX&lt;/li&gt;
  &lt;li&gt;MPlayerX&lt;/li&gt;
  &lt;li&gt;GIFBrewery&lt;/li&gt;
  &lt;li&gt;Fritzing&lt;/li&gt;
  &lt;li&gt;Debookee&lt;/li&gt;
  &lt;li&gt;BetterZip&lt;/li&gt;
  &lt;li&gt;Cactus Beta&lt;/li&gt;
  &lt;li&gt;Bartender&lt;/li&gt;
  &lt;li&gt;AppCleaner&lt;/li&gt;
  &lt;li&gt;Adobe Effects&lt;/li&gt;
  &lt;li&gt;Adobe Illustrator&lt;/li&gt;
  &lt;li&gt;Adobe Reader&lt;/li&gt;
  &lt;li&gt;Airmail&lt;/li&gt;
  &lt;li&gt;The Unachiver&lt;/li&gt;
  &lt;li&gt;Charles&lt;/li&gt;
  &lt;li&gt;Macaw&lt;/li&gt;
  &lt;li&gt;Poedit&lt;/li&gt;
  &lt;li&gt;MacDown&lt;/li&gt;
  &lt;li&gt;Vox&lt;/li&gt;
  &lt;li&gt;TotalFinder&lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>Django命令备忘录</title>
        <link>http://fankcoder.github.io//2016/01/27/general-django-resource.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/27/general-django-resource.html</guid>
        <pubDate>Wed, 27 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;django-project&quot;&gt;新建一个 django project&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; django-admin.py startproject project-name
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;app&quot;&gt;新建 app&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py startapp app-name
 #或
 django-admin.py startapp app-name
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;同步数据库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py syncdb 
 #注意：Django 1.7.1及以上的版本需要用以下命令
 python manage.py makemigrations
 python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法可以创建表，当你在models.py中新增了类时，运行它就可以自动在数据库中创建表了，不用手动创建。&lt;/p&gt;

&lt;p&gt;备注：对已有的 models 进行修改，Django 1.7之前的版本的Django都是无法自动更改表结构的，不过有第三方工具 south,详见 Django 数据库迁移&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;使用开发服务器&lt;/h3&gt;

&lt;p&gt;开发服务器，即开发时使用，一般修改代码后会自动重启，方便调试和开发，但是由于性能问题，建议只用来测试，不要用在生产环境。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; python manage.py runserver
 python manage.py runserver 8001
 python manage.py runserver 0.0.0.0:8000
 # 如果是外网或者局域网电脑上可以用其它电脑查看开发服务器
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;清空数据库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py flush
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;创建超级管理员&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py createsuperuser
  
 # 按照提示输入用户名和对应的密码就好了邮箱可以留空，用户名和密码必填
  
 # 修改 用户密码可以用：
 python manage.py changepassword username
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;导出数据 导入数据&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py dumpdata appname &amp;gt; appname.json
 python manage.py loaddata appname.json
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;django-&quot;&gt;Django 项目环境终端&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你安装了 bpython 或 ipython 会自动用它们的界面，推荐安装 bpython。&lt;/p&gt;

&lt;p&gt;这个命令和 直接运行 python 或 bpython 进入 shell 的区别是：你可以在这个 shell 里面调用当前项目的 models.py 中的 API，对于操作数据，还有一些小测试非常方便。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;数据库命令行&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; python manage.py dbshell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Django 会自动进入在settings.py中设置的数据库，如果是 MySQL 或 postgreSQL,会要求输入数据库用户密码。
在这个终端可以执行数据库的SQL语句。如果您对SQL比较熟悉，可能喜欢这种方式。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;更多命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; 终端上输入 python manage.py 可以看到详细的列表，在忘记子名称的时候特别有用。
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>爬虫防屏蔽</title>
        <link>http://fankcoder.github.io//2016/01/25/amazon-spider-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/25/amazon-spider-python.html</guid>
        <pubDate>Mon, 25 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;##介绍&lt;/p&gt;

&lt;p&gt;最近爬了amazon,发现amazon服务器,连续访问100多次后爬虫就会经常失败了,&lt;/p&gt;

&lt;p&gt;查找了下失败的原因,发现amazon会检测Ip一旦发现请求次数过多,就会跳转到输入验证码的网页&lt;/p&gt;

&lt;p&gt;需要输入正确验证码才可继续愉快的访问,搞掉验证码是个麻烦活,执意研究验证码就跨到图像分析那个学科了(不过据说某些库识别率还行)。。&lt;/p&gt;

&lt;p&gt;Gg整理正常的防屏蔽方法,总结一下比较好的解决方案.&lt;/p&gt;

&lt;h4 id=&quot;adsl&quot;&gt;ADSL重启拨号&lt;/h4&gt;

&lt;p&gt;大家都知道adsl重拨号的话,会换一个新的ip地址,那就可以写脚本设置时间重拨adsl,或者先用爬虫爬着,发现开始跳转到验证码页面了,再调用重拨adsl的脚本&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;爬代理服务器地址&lt;/h4&gt;

&lt;p&gt;很机智的解决办法，代理服务器可以很好的解决ip被屏蔽的问题&lt;/p&gt;

&lt;p&gt;不过代理服务器的网站域名经常更换,我就不提供了,大家自行Gg吧,百度说不定也会有惊喜&lt;/p&gt;

&lt;p&gt;要注意的是爬下来的代理服务器,最好检测一下是否可用!&lt;/p&gt;

&lt;p&gt;参照下面篇博客的checkProxy()函数&lt;/p&gt;

&lt;p&gt;https://blog.linuxeye.com/410.html&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
#coding:utf-8
#BLOG: blog.linuxeye.com
import urllib2
import re
import threading
import time
import MySQLdb
rawProxyList = []
checkedProxyList = []
#抓取代理网站
targets = []
for i in xrange(1,42):
        target = r&quot;http://www.proxy.com.ru/list_%d.html&quot; % i
        targets.append(target)
#抓取代理服务器正则
p = re.compile(r&#39;&#39;&#39;&amp;lt;tr&amp;gt;&amp;lt;b&amp;gt;&amp;lt;td&amp;gt;(\d+)&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;(.+?)&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;(\d+)&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;(.+?)&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;(.+?)&amp;lt;/td&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/tr&amp;gt;&#39;&#39;&#39;)
#获取代理的类
class ProxyGet(threading.Thread):
    def __init__(self,target):
        threading.Thread.__init__(self)
        self.target = target
    def getProxy(self):
        print &quot;代理服务器目标网站： &quot; + self.target
        req = urllib2.urlopen(self.target)
        result = req.read()
        #print chardet.detect(result)
        matchs = p.findall(result)
#       print matchs
        for row in matchs:
            ip=row[1]
            port =row[2]
            addr = row[4].decode(&quot;cp936&quot;).encode(&quot;utf-8&quot;)
            proxy = [ip,port,addr]
            print proxy
            rawProxyList.append(proxy)
    def run(self):
        self.getProxy()
#检验代理的类
class ProxyCheck(threading.Thread):
    def __init__(self,proxyList):
        threading.Thread.__init__(self)
        self.proxyList = proxyList
        self.timeout = 5
        self.testUrl = &quot;http://www.baidu.com/&quot;
        self.testStr = &quot;030173&quot;
    def checkProxy(self):
        cookies = urllib2.HTTPCookieProcessor()
        for proxy in self.proxyList:
            proxyHandler = urllib2.ProxyHandler({&quot;http&quot; : r&#39;http://%s:%s&#39; %(proxy[0],proxy[1])})
            #print r&#39;http://%s:%s&#39; %(proxy[0],proxy[1])
            opener = urllib2.build_opener(cookies,proxyHandler)
            opener.addheaders = [(&#39;User-agent&#39;, &#39;Mozilla/5.0 (Windows NT 6.2; WOW64; rv:22.0) Gecko/20100101 Firefox/22.0&#39;)]
            #urllib2.install_opener(opener)
            t1 = time.time()
            try:
                #req = urllib2.urlopen(&quot;http://www.baidu.com&quot;, timeout=self.timeout)
                req = opener.open(self.testUrl, timeout=self.timeout)
                #print &quot;urlopen is ok....&quot;
                result = req.read()
                #print &quot;read html....&quot;
                timeused = time.time() - t1
                pos = result.find(self.testStr)
                #print &quot;pos is %s&quot; %pos
                if pos &amp;gt; 1:
                    checkedProxyList.append((proxy[0],proxy[1],proxy[2],timeused))
                    #print &quot;ok ip: %s %s %s %s&quot; %(proxy[0],proxy[1],proxy[2],timeused)
                else:
                     continue
            except Exception,e:
                #print e.message
                continue
    def run(self):
        self.checkProxy()
if __name__ == &quot;__main__&quot;:
    getThreads = []
    checkThreads = []
#对每个目标网站开启一个线程负责抓取代理
for i in range(len(targets)):
    t = ProxyGet(targets[i])
    getThreads.append(t)
for i in range(len(getThreads)):
    getThreads[i].start()
for i in range(len(getThreads)):
    getThreads[i].join()
print &#39;.&#39;*10+&quot;总共抓取了%s个代理&quot; %len(rawProxyList) +&#39;.&#39;*10
#开启20个线程负责校验，将抓取到的代理分成20份，每个线程校验一份
for i in range(20):
    t = ProxyCheck(rawProxyList[((len(rawProxyList)+19)/20) * i:((len(rawProxyList)+19)/20) * (i+1)])
    checkThreads.append(t)
for i in range(len(checkThreads)):
    checkThreads[i].start()
for i in range(len(checkThreads)):
    checkThreads[i].join()
print &#39;.&#39;*10+&quot;总共有%s个代理通过校验&quot; %len(checkedProxyList) +&#39;.&#39;*10
#插入数据库，表结构自己创建，四个字段ip,port,speed,address
def db_insert(insert_list):
    try:
        conn = MySQLdb.connect(host=&quot;localhost&quot;, user=&quot;root&quot;, passwd=&quot;admin&quot;,db=&quot;m_common&quot;,charset=&#39;utf8&#39;)
        cursor = conn.cursor()
        cursor.execute(&#39;delete from proxy&#39;)
        cursor.execute(&#39;alter table proxy AUTO_INCREMENT=1&#39;)
        cursor.executemany(&quot;INSERT INTO proxy(ip,port,speed,address) VALUES (%s,%s,%s,%s)&quot;,insert_list)
        conn.commit()
        cursor.close()
        conn.close()
    except MySQLdb.Error,e:
        print &quot;Mysql Error %d: %s&quot; % (e.args[0], e.args[1])
#代理排序持久化
proxy_ok = []
f= open(&quot;proxy_list.txt&quot;,&#39;w+&#39;)
for proxy in sorted(checkedProxyList,cmp=lambda x,y:cmp(x[3],y[3])):
    if proxy[3] &amp;lt; 8:
        #print &quot;checked proxy is: %s:%s\t%s\t%s&quot; %(proxy[0],proxy[1],proxy[2],proxy[3])
        proxy_ok.append((proxy[0],proxy[1],proxy[3],proxy[2]))
        f.write(&quot;%s:%s\t%s\t%s\n&quot;%(proxy[0],proxy[1],proxy[2],proxy[3]))
f.close()
db_insert(proxy_ok)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想了解我的amazon爬虫?&lt;/p&gt;

&lt;p&gt;代码在github spider-comments项目下的amazon-spider-comments&lt;/p&gt;

&lt;p&gt;https://github.com/fankcoder/spider-comments&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Django添加静态文件</title>
        <link>http://fankcoder.github.io//2016/01/20/add-static-django-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/20/add-static-django-python.html</guid>
        <pubDate>Wed, 20 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;最近做了一个todolist webapp,需要添加css时候忘记添加方法了,查看了以前的项目才想起来,所以记录一下.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;settings.py 将以下代码放到最下面&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;STATIC_URL = &#39;/static/&#39;
 
STATICFILES_DIRS = ( 
    os.path.join(BASE_DIR),
)
 
STATICFILES_FINDERS = (
    &quot;django.contrib.staticfiles.finders.FileSystemFinder&quot;,
    &quot;django.contrib.staticfiles.finders.AppDirectoriesFinder&quot;,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;给html添加静态文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首行加入(一定要放在首行)，这里和Jekyll冲突了在需要代码前后添加的是“大括号和百分号”&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/\{\%/load staticfiles/\%\}/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后按照jinjia2或者djagno template的语法加上css等静态文件的路径,如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/\{\%/ static &#39;css/style.css&#39; /\%\}/&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搞定&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Python黑魔法(split,enumerate)</title>
        <link>http://fankcoder.github.io//2016/01/11/enumerate-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/11/enumerate-python.html</guid>
        <pubDate>Mon, 11 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;split&quot;&gt;split()&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
 
str = &quot;Line1-abcdef \nLine2-abc \nLine4-abcd&quot;;
print str.split( );
print str.split(&#39; &#39;, 1 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&#39;Line1-abcdef&#39;, &#39;Line2-abc&#39;, &#39;Line4-abcd&#39;]
[&#39;Line1-abcdef&#39;, &#39;\nLine2-abc \nLine4-abcd&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;split()要点:&lt;/p&gt;

&lt;p&gt;采用不带参数的split()，它会把所有空格（空格符、制表符、换行符）当作分隔符。&lt;/p&gt;

&lt;p&gt;filter(None, s.split(‘ ‘))&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = &#39;hello++world!+&#39;   #如何取得&#39;hello&#39;和&#39;world&#39;呢？
 
&amp;gt;&amp;gt;&amp;gt;a.split(&#39;+&#39;)
 
[&#39;hello&#39;, &#39;&#39;, &#39;world!&#39;, &#39;&#39;]    #含有两个空字符串
 
&amp;gt;&amp;gt;&amp;gt;filter(None, a.split(&#39;+&#39;))
 
[&#39;hello&#39;, &#39;world!&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;enumerate&quot;&gt;enumerate()&lt;/h3&gt;

&lt;p&gt;写一个带引索的遍历数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in range (0,len(list)):
    print i ,list[i]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用enumerate():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;l = [1,2,3,&#39;a&#39;,&#39;b&#39;]
 
 for index,data in enumerate(l):
     print index,data
 
&amp;gt;&amp;gt;   
0 1
1 2
2 3
3 a
4 b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简直太方便了~&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Python转码问题</title>
        <link>http://fankcoder.github.io//2016/01/11/encode-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2016/01/11/encode-python.html</guid>
        <pubDate>Mon, 11 Jan 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;在Python中，可以对String调用decode和encode方法来实现转码。&lt;/p&gt;

&lt;p&gt;比如，若要将某个String对象s从gbk内码转换为UTF-8，可以如下操作&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s.decode(&#39;gbk&#39;).encode(&#39;utf-8′) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可是，在实际开发中，我发现，这种办法经常会出现异常：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UnicodeDecodeError: ‘gbk&#39; codec can&#39;t decode bytes in position 30664-30665: illegal multibyte sequence 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为遇到了非法字符——尤其是在某些用C/C++编写的程序中，全角空格往往有多种不同的实现方式，比如\xa3\xa0，或者\xa4\x57，这些字符，看起来都是全角空格，但它们并不是“合法”的全角空格（真正的全角空格是\xa1\xa1），因此在转码的过程中出现了异常。&lt;/p&gt;

&lt;p&gt;这样的问题很让人头疼，因为只要字符串中出现了一个非法字符，整个字符串——有时候，就是整篇文章——就都无法转码。&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s.decode(&#39;gbk&#39;, ‘ignore&#39;).encode(&#39;utf-8′) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为decode的函数原型是decode([encoding], [errors=’strict’])，可以用第二个参数控制错误处理的策略，默认的参数就是strict，代表遇到非法字符时抛出异常； 
如果设置为ignore，则会忽略非法字符； 
如果设置为replace，则会用?取代非法字符； 
如果设置为xmlcharrefreplace，则使用XML的字符引用。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Python的xrange和range</title>
        <link>http://fankcoder.github.io//2015/12/29/xrange-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/12/29/xrange-python.html</guid>
        <pubDate>Tue, 29 Dec 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;这两个函数基本上都是在循环的时候用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in range(0, 100): 
print i 

for i in xrange(0, 100): 
print i 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个输出的结果都是一样的，实际上有很多不同，range会直接生成一个list对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = range(0,100) 
print type(a)  #list
print a #[0,1,2...]
print a[0], a[1] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而xrange则不会直接生成一个list，而是每次调用返回其中的一个值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = xrange(0,100) 
print type(a) #&amp;lt;type &#39;xrange&#39;&amp;gt;
print a  #xrange(100)
print a[0], a[1] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以xrange做循环的性能比range好，尤其是返回列表很长的时候！&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>科学上网列表</title>
        <link>http://fankcoder.github.io//2015/11/10/vpn-tools.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/11/10/vpn-tools.html</guid>
        <pubDate>Tue, 10 Nov 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;付费vpn列表，流量计费约4G，不包月，平时翻基本不用这个，作为临时或救急使用&lt;/p&gt;

&lt;p&gt;防止被监测，使用”X”代替了”.”&lt;/p&gt;

&lt;p&gt;所以使用方法，将”X”全部替换为”.”&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;浏览网页&lt;/h3&gt;

&lt;p&gt;74X126X180X61&lt;/p&gt;

&lt;p&gt;74X126X180X62&lt;/p&gt;

&lt;p&gt;74X126X180X58&lt;/p&gt;

&lt;p&gt;74X126X180X60&lt;/p&gt;

&lt;p&gt;74X126X180X59&lt;/p&gt;

&lt;p&gt;192X210X48X213&lt;/p&gt;

&lt;p&gt;192X210X48X214&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;下载&lt;/h3&gt;

&lt;p&gt;98X126X10X10&lt;/p&gt;

&lt;p&gt;98X126X10X11&lt;/p&gt;

&lt;p&gt;98X126X10X13&lt;/p&gt;

&lt;p&gt;98X126X10X14&lt;/p&gt;

&lt;p&gt;74X126X176X138&lt;/p&gt;

&lt;p&gt;74X126X176X139&lt;/p&gt;

&lt;p&gt;74X126X176X140&lt;/p&gt;

&lt;p&gt;74X126X176X142&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;视频专线&lt;/h3&gt;

&lt;p&gt;104X238X156X110&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;游戏&lt;/h3&gt;

&lt;p&gt;23X247X65X12&lt;/p&gt;

&lt;p&gt;23X247X65X33&lt;/p&gt;

&lt;p&gt;23X247X65X37&lt;/p&gt;

&lt;p&gt;23X247X65X38&lt;/p&gt;

&lt;p&gt;107X179X92X78&lt;/p&gt;

&lt;p&gt;107X179X92X93&lt;/p&gt;

&lt;p&gt;174X139X118X53&lt;/p&gt;

&lt;p&gt;174X139X118X54&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;海淘&lt;/h3&gt;

&lt;p&gt;98X126X222X147&lt;/p&gt;

&lt;p&gt;98X126X222X149&lt;/p&gt;

&lt;p&gt;98X126X222X150&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;日本网页&lt;/h3&gt;

&lt;p&gt;133X130X62X172&lt;/p&gt;

&lt;p&gt;133X130X55X57&lt;/p&gt;

&lt;p&gt;133X130X52X67&lt;/p&gt;

&lt;p&gt;106X185X47X87&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;下载&lt;/h3&gt;

&lt;p&gt;27X120X113X154&lt;/p&gt;

&lt;p&gt;106X185X35X12&lt;/p&gt;

&lt;p&gt;106X185X41X7&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;日海淘&lt;/h3&gt;
&lt;p&gt;106X185X49X209&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Shell每日发邮件</title>
        <link>http://fankcoder.github.io//2015/10/26/email-shell-linux.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/10/26/email-shell-linux.html</guid>
        <pubDate>Mon, 26 Oct 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;很是好奇运维工作，刚好有幸接触到，每日发邮件脚本，多用来发送服务器日志，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LOGFILE=&quot;$fank/&quot;`date +&quot;%Y%m%d&quot;`&quot;data&quot;#每日文件

from=&quot;abc@123.com&quot;#发件人

recipients=&quot;fank@123.com&quot;#收件人


subject=&quot;[REPORT]every day check&quot; #主题
content=&quot;$(cat ${LOGFILE})&quot;  #内容

/usr/sbin/sendmail &quot;${recipients}&quot; &amp;lt;&amp;lt;EOF
subject:${subject}
from:${from}
${content}
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*该脚本需要部署在服务器定时任务crontab上&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Python密码处理</title>
        <link>http://fankcoder.github.io//2015/10/13/passwd-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/10/13/passwd-python.html</guid>
        <pubDate>Tue, 13 Oct 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;python密码处理(可用于生产模式)
　　
```
import os
from hashlib import sha256
from hmac import HMAC&lt;/p&gt;

&lt;p&gt;def encrypt_password(password, salt=None):
    “&quot;”Hash password on the fly.”””
    if salt is None:
        salt = os.urandom(8) # 64 bits.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assert 8 == len(salt)
assert isinstance(salt, str)

if isinstance(password, unicode):
    password = password.encode(&#39;UTF-8&#39;)

assert isinstance(password, str)

result = password
for i in xrange(10):
    result = HMAC(result, salt, sha256).digest()

return salt + result ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里先随机生成 64 bits 的 salt，再选择 SHA-256 算法使用 HMAC 对密码和 salt 进行 10 次叠代混淆，最后将 salt 和 hash 结果一起返回。&lt;/p&gt;

&lt;p&gt;使用的方法很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hashed = encrypt_password(&#39;secret password&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是验证函数，它直接使用 encrypt_password 来对密码进行相同的单向转换并比较&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def validate_password(hashed, input_password):
    return hashed == encrypt_password(input_password, salt=hashed[:8])

assert validate_password(hashed, &#39;secret password&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;密码项目代码查看&lt;a href=&quot;https://github.com/fankcoder/ShowMeTheCode&quot;&gt;show me the code&lt;/a&gt;下 s21/ 目录&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Python标准库os</title>
        <link>http://fankcoder.github.io//2015/10/12/os-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/10/12/os-python.html</guid>
        <pubDate>Mon, 12 Oct 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;os模块包含普遍的操作系统功能。&lt;/p&gt;

&lt;p&gt;如果你希望你的程序能够与平台无关的话，这个模块是尤为重要的。&lt;/p&gt;

&lt;p&gt;即它允许一个程序在编写后不需要任何改动，也不会发生任何问题，就可以在Linux和Windows下运行。一个例子就是使用os.sep可以取代操作系统特定的路径分割符。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;os.name字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.getcwd()函数得到当前工作目录，即当前Python脚本工作的目录路径。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.getenv()和os.putenv()函数分别用来读取和设置环境变量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.listdir()返回指定目录下的所有文件和目录名。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.remove()函数用来删除一个文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.system()函数用来运行shell命令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.linesep字符串给出当前平台使用的行终止符。例如，Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.path.split()函数返回一个路径的目录名和文件名。&lt;/p&gt;

    &lt;p&gt;例如：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;os.path.split(&#39;/home/swaroop/byte/code/poem.txt&#39;)
  
(&#39;/home/swaroop/byte/code&#39;, &#39;poem.txt&#39;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.path.isfile()和os.path.isdir()函数分别检验给出的路径是一个文件还是目录。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;os.path.existe()函数用来检验给出的路径是否真地存在。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>2016阅读书单</title>
        <link>http://fankcoder.github.io//2015/10/01/book-list-of-2015.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/10/01/book-list-of-2015.html</guid>
        <pubDate>Thu, 01 Oct 2015 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;程序员的呐喊&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;status: 已读&lt;/li&gt;
  &lt;li&gt;author: steve yegge&lt;/li&gt;
  &lt;li&gt;publisher: 人民邮电出版社&lt;/li&gt;
  &lt;li&gt;language: 中文&lt;/li&gt;
  &lt;li&gt;link: https://book.douban.com/subject/25884108/&lt;/li&gt;
  &lt;li&gt;notes:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;小学和中学里教的绝大部分数学都是连续的，也就是实数上的数学。而对计算机科学家来说，95％有趣的数学都是离散的，也就是整数上的数学。

我在招人的时候有一个诀窍。就是在寻找优秀的软件工程师“通才”的时候，通常在简历上你可以看到到各种让你觉得不行的关键字和词，但“编译器”是我唯一感兴趣的词。

 C是必修课
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;comment:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;作者先将各个语言都批评了一遍,最被嫌弃的语言是C++(多大仇&amp;gt;.&amp;lt;),作者最爱用的语言是Ruby,作者作为一个在IT界驰骋多年的老将,这个细节确实让我思考了一些东西,首先语言只是作为一种工具,工具虽分好用与否,但是永远陷入工具之间的选择、争辩是非常不明智的,就好像这几年特别流行的一句&quot;PHP是最好的语言&quot;这个梗,辩论工具是没有太大实际意义的,至少对我来说是这样,选择一个大趋势,提高自己编程思想才是核心竞争力.而且欧美国计算机技术比其他国家领先很多年,作者最喜欢的语言却是日本人松本行弘开发的Ruby,我觉得欧美思想确实比我们先进,我还看到过技术群里有人说自己不会去学日本人的语言..以后看到这种程序员就默默拉黑吧.

作者强调了学习编译器的重要,这也给我一个很好的深入方向,以后要安排研究编译器了,感觉很棒.

以前C学的比较浅,要在linux再玩一把C,最好能做些有意思的东西放github上.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;开源软件之道&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;status: 已读&lt;/li&gt;
  &lt;li&gt;author: 蔡俊杰&lt;/li&gt;
  &lt;li&gt;publisher: 电子工业出版社&lt;/li&gt;
  &lt;li&gt;language: 中文&lt;/li&gt;
  &lt;li&gt;link: https://book.douban.com/subject/4747758/&lt;/li&gt;
  &lt;li&gt;comment:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;抱着对开源软件的崇拜去读这书,但是读了一半就没有太大兴趣往下读了,感觉费了不少力气说明了开源软件是open不是free,但是说到不免费我就莫名奇妙对如何make money感兴趣,但是教如何赚钱的书也没法写啊..

看这本书后给自己定了个目标就是有朝一日也要向开源社区提交pull request,让自己体会一下全世界程序员一起努力的感觉~~
with the code ,change the world.

更值得一提的是github,这个网站的创建真是大大推动了开源软件的进步,注册了github帐号后,感觉到真是方便,无论是找好用的工具,还是学习别人的代码,给提高自己能力创造了及其便利的条件.
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>Python正则</title>
        <link>http://fankcoder.github.io//2015/08/25/re-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/08/25/re-python.html</guid>
        <pubDate>Tue, 25 Aug 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;整理自&lt;a href=&quot;http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html&quot;&gt;博客园&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;re&quot;&gt;re模块&lt;/h4&gt;

&lt;p&gt;Python通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# encoding: UTF-8
import re
 
# 将正则表达式编译成Pattern对象
pattern = re.compile(r&#39;hello&#39;)
 
# 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None
match = pattern.match(&#39;hello world!&#39;)
 
if match:
    # 使用Match获得分组信息
    print match.group()
 
### 输出 ###
# hello
re.compile(strPattern[, flag]):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。&lt;/p&gt;

&lt;p&gt;第二个参数flag是匹配模式，取值可以使用按位或运算符’|‘表示同时生效，比如re.I | re.M。&lt;/p&gt;

&lt;p&gt;另外，你也可以在regex字符串中指定模式，比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。 可选值有：&lt;/p&gt;

&lt;p&gt;re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）&lt;/p&gt;

&lt;p&gt;M(MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）&lt;/p&gt;

&lt;p&gt;S(DOTALL): 点任意匹配模式，改变’.’的行为&lt;/p&gt;

&lt;p&gt;L(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定&lt;/p&gt;

&lt;p&gt;U(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性&lt;/p&gt;

&lt;p&gt;X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = re.compile(r&quot;&quot;&quot;\d +  # the integral part
                   \.    # the decimal point
                   \d *  # some fractional digits&quot;&quot;&quot;, re.X)
b = re.compile(r&quot;\d+\.\d*&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;re提供了众多模块方法用于完成正则表达式的功能。这些方法可以使用Pattern实例的相应方法替代，唯一的好处是少写一行re.compile()代码，但同时也无法复用编译后的Pattern对象。这些方法将在Pattern类的实例方法部分一起介绍。如上面这个例子可以简写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;m = re.match(r&#39;hello&#39;, &#39;hello world!&#39;)
print m.group()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;re模块还提供了一个方法escape(string)，用于将string中的正则表达式元字符如*/+/?等之前加上转义符再返回，在需要大量匹配元字符时有那么一点用。&lt;/p&gt;

&lt;h4 id=&quot;match&quot;&gt;Match&lt;/h4&gt;

&lt;p&gt;Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。&lt;/p&gt;

&lt;p&gt;属性：&lt;/p&gt;

&lt;p&gt;string: 匹配时使用的文本。&lt;/p&gt;

&lt;p&gt;re: 匹配时使用的Pattern对象。&lt;/p&gt;

&lt;p&gt;pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。&lt;/p&gt;

&lt;p&gt;endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。&lt;/p&gt;

&lt;p&gt;lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。&lt;/p&gt;

&lt;p&gt;lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。方法：&lt;/p&gt;

&lt;p&gt;group([group1, …]):&lt;/p&gt;

&lt;p&gt;获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。&lt;/p&gt;

&lt;p&gt;groups([default]):&lt;/p&gt;

&lt;p&gt;以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。&lt;/p&gt;

&lt;p&gt;groupdict([default]):&lt;/p&gt;

&lt;p&gt;返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。&lt;/p&gt;

&lt;p&gt;start([group]):&lt;/p&gt;

&lt;p&gt;返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。&lt;/p&gt;

&lt;p&gt;end([group]):&lt;/p&gt;

&lt;p&gt;返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。&lt;/p&gt;

&lt;p&gt;span([group]):&lt;/p&gt;

&lt;p&gt;返回(start(group), end(group))。&lt;/p&gt;

&lt;p&gt;expand(template):&lt;/p&gt;

&lt;p&gt;将匹配到的分组代入template中然后返回。template中可以使用\id或\g&lt;id&gt;、\g&lt;name&gt;引用分组，但不能使用编号0。\id与\g&lt;id&gt;是等价的；但\10将被认为是第10个分组，如果你想表达\1之后是字符&#39;0&#39;，只能使用\g&amp;lt;1&amp;gt;0。&lt;/id&gt;&lt;/name&gt;&lt;/id&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
m = re.match(r&#39;(\w+) (\w+)(?P&amp;lt;sign&amp;gt;.*)&#39;, &#39;hello world!&#39;)
 
print &quot;m.string:&quot;, m.string
print &quot;m.re:&quot;, m.re
print &quot;m.pos:&quot;, m.pos
print &quot;m.endpos:&quot;, m.endpos
print &quot;m.lastindex:&quot;, m.lastindex
print &quot;m.lastgroup:&quot;, m.lastgroup
 
print &quot;m.group(1,2):&quot;, m.group(1, 2)
print &quot;m.groups():&quot;, m.groups()
print &quot;m.groupdict():&quot;, m.groupdict()
print &quot;m.start(2):&quot;, m.start(2)
print &quot;m.end(2):&quot;, m.end(2)
print &quot;m.span(2):&quot;, m.span(2)
print r&quot;m.expand(r&#39;\2 \1\3&#39;):&quot;, m.expand(r&#39;\2 \1\3&#39;)
 
### output ###
# m.string: hello world!
# m.re: &amp;lt;_sre.SRE_Pattern object at 0x016E1A38&amp;gt;
# m.pos: 0
# m.endpos: 12
# m.lastindex: 3
# m.lastgroup: sign
# m.group(1,2): (&#39;hello&#39;, &#39;world&#39;)
# m.groups(): (&#39;hello&#39;, &#39;world&#39;, &#39;!&#39;)
# m.groupdict(): {&#39;sign&#39;: &#39;!&#39;}
# m.start(2): 6
# m.end(2): 11
# m.span(2): (6, 11)
# m.expand(r&#39;\2 \1\3&#39;): world hello!
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;pattern&quot;&gt;Pattern&lt;/h4&gt;
&lt;p&gt;Pattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。&lt;/p&gt;

&lt;p&gt;Pattern不能直接实例化，必须使用re.compile()进行构造。&lt;/p&gt;

&lt;p&gt;Pattern提供了几个可读属性用于获取表达式的相关信息：&lt;/p&gt;

&lt;p&gt;pattern: 编译时用的表达式字符串。&lt;/p&gt;

&lt;p&gt;flags: 编译时用的匹配模式。数字形式。&lt;/p&gt;

&lt;p&gt;groups: 表达式中分组的数量。&lt;/p&gt;

&lt;p&gt;groupindex: 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
p = re.compile(r&#39;(\w+) (\w+)(?P&amp;lt;sign&amp;gt;.*)&#39;, re.DOTALL)
 
print &quot;p.pattern:&quot;, p.pattern
print &quot;p.flags:&quot;, p.flags
print &quot;p.groups:&quot;, p.groups
print &quot;p.groupindex:&quot;, p.groupindex
 
### output ###
# p.pattern: (\w+) (\w+)(?P&amp;lt;sign&amp;gt;.*)
# p.flags: 16
# p.groups: 3
# p.groupindex: {&#39;sign&#39;: 3}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;实例方法[&lt;/td&gt;
      &lt;td&gt;re模块方法]：&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;match(string[, pos[, endpos]])&lt;/td&gt;
      &lt;td&gt;re.match(pattern, string[, flags]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这个方法将从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。 
pos和endpos的默认值分别为0和len(string)；re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。&lt;/p&gt;

&lt;p&gt;注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;search(string[, pos[, endpos]])&lt;/td&gt;
      &lt;td&gt;re.search(pattern, string[, flags]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这个方法用于查找字符串中可以匹配成功的子串。从string的pos下标处起尝试匹配pattern，如果pattern结束时仍可匹配，则返回一个Match对象；若无法匹配，则将pos加1后重新尝试匹配；直到pos=endpos时仍无法匹配则返回None。&lt;/p&gt;

&lt;p&gt;pos和endpos的默认值分别为0和len(string))；re.search()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# encoding: UTF-8 
import re 
 
# 将正则表达式编译成Pattern对象 
pattern = re.compile(r&#39;world&#39;) 
 
# 使用search()查找匹配的子串，不存在能匹配的子串时将返回None 
# 这个例子中使用match()无法成功匹配 
match = pattern.search(&#39;hello world!&#39;) 
 
if match: 
    # 使用Match获得分组信息 
    print match.group() 
 
### 输出 ### 
# world
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;split(string[, maxsplit])&lt;/td&gt;
      &lt;td&gt;re.split(pattern, string[, maxsplit]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
 
p = re.compile(r&#39;\d+&#39;)
print p.split(&#39;one1two2three3four4&#39;)
 
### output ###
# [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;findall(string[, pos[, endpos]])&lt;/td&gt;
      &lt;td&gt;re.findall(pattern, string[, flags]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;搜索string，以列表形式返回全部能匹配的子串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
 
p = re.compile(r&#39;\d+&#39;)
print p.findall(&#39;one1two2three3four4&#39;)
 
### output ###
# [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;finditer(string[, pos[, endpos]])&lt;/td&gt;
      &lt;td&gt;re.finditer(pattern, string[, flags]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
 
p = re.compile(r&#39;\d+&#39;)
for m in p.finditer(&#39;one1two2three3four4&#39;):
    print m.group(),
 
### output ###
# 1 2 3 4
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;sub(repl, string[, count])&lt;/td&gt;
      &lt;td&gt;re.sub(pattern, repl, string[, count]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;使用repl替换string中每一个匹配的子串后返回替换后的字符串。&lt;/p&gt;

&lt;p&gt;当repl是一个字符串时，可以使用\id或\g&lt;id&gt;、\g&lt;name&gt;引用分组，但不能使用编号0。&lt;/name&gt;&lt;/id&gt;&lt;/p&gt;

&lt;p&gt;当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。&lt;/p&gt;

&lt;p&gt;count用于指定最多替换次数，不指定时全部替换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
 
p = re.compile(r&#39;(\w+) (\w+)&#39;)
s = &#39;i say, hello world!&#39;
 
print p.sub(r&#39;\2 \1&#39;, s)
 
def func(m):
    return m.group(1).title() + &#39; &#39; + m.group(2).title()
 
print p.sub(func, s)
 
### output ###
# say i, world hello!
# I Say, Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;subn(repl, string[, count])&lt;/td&gt;
      &lt;td&gt;re.sub(pattern, repl, string[, count]):&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;返回 (sub(repl, string[, count]), 替换次数)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import re
 
p = re.compile(r&#39;(\w+) (\w+)&#39;)
s = &#39;i say, hello world!&#39;
 
print p.subn(r&#39;\2 \1&#39;, s)
 
def func(m):
    return m.group(1).title() + &#39; &#39; + m.group(2).title()
 
print p.subn(func, s)
 
### output ###
# (&#39;say i, world hello!&#39;, 2)
# (&#39;I Say, Hello World!&#39;, 2)
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>Python内置函数(map、reduce、filter)</title>
        <link>http://fankcoder.github.io//2015/08/11/func-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/08/11/func-python.html</guid>
        <pubDate>Tue, 11 Aug 2015 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;map&quot;&gt;map&lt;/h3&gt;

&lt;p&gt;map(…)
    map(function, sequence[, sequence, …]) -&amp;gt; list 说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对sequence中的item依次执行function(item)，执行结果输出为list。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; map(str, range(5))           #对range(5)各项进行str操作
[&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]        #返回列表
&amp;gt;&amp;gt;&amp;gt; def add(n):return n+n
... 
&amp;gt;&amp;gt;&amp;gt; map(add, range(5))           #对range(5)各项进行add操作
[0, 2, 4, 6, 8]
&amp;gt;&amp;gt;&amp;gt; map(lambda x:x+x,range(5))   #lambda 函数，各项+本身
[0, 2, 4, 6, 8]
&amp;gt;&amp;gt;&amp;gt; map(lambda x:x+1,range(10))  #lambda 函数，各项+1
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;reduce&quot;&gt;reduce&lt;/h3&gt;

&lt;p&gt;reduce(…)
    reduce(function, sequence[, initial]) -&amp;gt; value 说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对sequence中的item顺序迭代调用function，函数必须要有2个参数。要是有第3个参数，则表示初始值，可以继续调用初始值，返回一个值。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def add(x,y):return x+y
... 
&amp;gt;&amp;gt;&amp;gt; reduce(add,range(10))        #1+2+3+...+9
45
&amp;gt;&amp;gt;&amp;gt; reduce(add,range(11))        #1+2+3+...+10
55
&amp;gt;&amp;gt;&amp;gt; reduce(lambda x,y:x*y,range(1,3),5)           #lambda 函数，5是初始值， 1*2*5
10
&amp;gt;&amp;gt;&amp;gt; reduce(lambda x,y:x*y,range(1,6))             #阶乘，1*2*3*4*5
120
&amp;gt;&amp;gt;&amp;gt; reduce(lambda x,y:x*y,range(1,6),3)           #初始值3，结果再*3
360
&amp;gt;&amp;gt;&amp;gt; reduce(lambda x,y:x+y,[1,2,3,4,5,6])          #1+2+3+4+5+6
21 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;filter&quot;&gt;filter&lt;/h3&gt;

&lt;p&gt;filter(…)
    filter(function or None, sequence) -&amp;gt; list, tuple, or string 说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对sequence中的item依次执行function(item)，将执行结果为True（！=0）的item组成一个List/String/Tuple（取决于sequence的类型）返回，False则退出（0），进行过滤。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def div(n):return n%2
... 
&amp;gt;&amp;gt;&amp;gt; filter(div,range(5))                    #返回div输出的不等于0的真值
[1, 3]
&amp;gt;&amp;gt;&amp;gt; filter(div,range(10))
[1, 3, 5, 7, 9]
&amp;gt;&amp;gt;&amp;gt; filter(lambda x : x%2,range(10))        #lambda 函数返回奇数，返回列表
[1, 3, 5, 7, 9]
&amp;gt;&amp;gt;&amp;gt; filter(lambda x : not x%2,range(10))
[0, 2, 4, 6, 8]
&amp;gt;&amp;gt;&amp;gt; def fin(n):return n!=&#39;f&#39;                #过滤&#39;z&#39; 函数，出现z则返回False
... 
&amp;gt;&amp;gt;&amp;gt; filter(fin,&#39;fankcoder&#39;)                    #&#39;z&#39;被过滤
&#39;ankcoder&#39;
&amp;gt;&amp;gt;&amp;gt; filter(lambda x : x !=&#39;f&#39;,&#39;fankcoder&#39;)     #labmda返回True值
&#39;ankcoder&#39;
&amp;gt;&amp;gt;&amp;gt; filter(lambda x : not x==&#39;f&#39;,&#39;fankcoder&#39;)  #返回：字符串
&#39;ankcoder&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Django练习项目之搭建博客</title>
        <link>http://fankcoder.github.io//2015/07/24/blog-django-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/07/24/blog-django-python.html</guid>
        <pubDate>Fri, 24 Jul 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;一,环境&lt;/p&gt;

&lt;p&gt;1.Python&lt;/p&gt;

&lt;p&gt;2.Django&lt;/p&gt;

&lt;p&gt;二,安装&lt;/p&gt;

&lt;p&gt;1.Python&lt;/p&gt;

&lt;p&gt;2.Django安装,推荐先装个pip吧,easyinstall也可以,然后终端下输入:
　　
&lt;code&gt;
pip install Django
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;强烈推荐用新的Django版本,我用的是1.8.1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install Django==1.8.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试一下安装成功否&lt;/p&gt;

&lt;p&gt;终端下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python

import django

django.VERSION

(1, 8, 1, &#39;final&#39;, 0) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三,开始&lt;/p&gt;

&lt;p&gt;1.创建博客项目&lt;/p&gt;

&lt;p&gt;找个干净的文件夹,终端下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;django-admin.py startproject nameblog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里nameblog是示例,自己记得换哦&lt;/p&gt;

&lt;p&gt;打开文件夹,或者cd nameblog/  输入 ls&lt;/p&gt;

&lt;p&gt;发现项目创建好了&lt;/p&gt;

&lt;p&gt;2.创建博客app&lt;/p&gt;

&lt;p&gt;终端下:cd nameblog/  刚才已经cd进去的同学这步省了&lt;/p&gt;

&lt;p&gt;然后输入:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py startapp blog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开文件夹瞅一眼,发现多了个blog文件夹,&lt;/p&gt;

&lt;p&gt;这时候blog项目app就创建好了&lt;/p&gt;

&lt;p&gt;3.简单设置一下&lt;/p&gt;

&lt;p&gt;打开nameblog/nameblog/settings.py&lt;/p&gt;

&lt;p&gt;进行如下设置,也就是加上一条blog:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;blog&#39;,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;顺便换下Django默认语言把,你要是英文大神,请别鸟我,第二句是换时区,不换你就自个倒时差吧,好像永远差8小时~&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LANGUAGE_CODE = &#39;zh_CN&#39;
 
TIME_ZONE = &#39;Asia/Shanghai&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;四,测试Django运行成功否&lt;/p&gt;

&lt;p&gt;终端下输入,&lt;/p&gt;

&lt;p&gt;注意现在的终端目录还应该是nameblog/下,而不是nameblog/nameblog下,请参考有manage.py的这层目录&lt;/p&gt;

&lt;p&gt;好的,终端下输入:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py runserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开浏览器,访问地址:127.0.0.1:8000或者localhost:8000&lt;/p&gt;

&lt;p&gt;看到淡蓝色提示,Django工作了，项目搭建成功~&lt;/p&gt;

&lt;p&gt;如果 python manage.py runserver跑不起来&lt;/p&gt;

&lt;p&gt;可能是8000端口被占用了？输入:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py runserver 8001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;五,博客数据库&lt;/p&gt;

&lt;p&gt;首先要知道&lt;/p&gt;

&lt;p&gt;Django是一个基于MVC构造的框架,模型M，视图V和控制器C。
但是在Django中，控制器接受用户输入的部分由框架自行处理，
所以 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），称为 MTV模式。
它们各自的职责如下：&lt;/p&gt;

&lt;p&gt;层次，职责，模型（Model），即数据存取层处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。模板(Template)，即表现层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。视图（View），即业务逻辑层存取模型及调取恰当模板的相关逻辑。模型与模板之间的桥梁。&lt;/p&gt;

&lt;p&gt;了解了Django先进的框架结构,就需要一层一层的进行操作,&lt;/p&gt;

&lt;p&gt;这里注意一下,我们并没有配置数据库,Django高级一点的版本会默认配置一个sqlite3,在settings.py下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DATABASES = {
    &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;),
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置模型,首先打开模型文件nameblog/blog/models.py&lt;/p&gt;

&lt;p&gt;models.py是博客数据库的模型,每个类都是数据库中的一张表,&lt;/p&gt;

&lt;p&gt;配置如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Tag(models.Model):
    tag_name = models.CharField(max_length=20)
    create_time = models.DateTimeField(auto_now_add=True)
 
    def __unicode__(self):
        return self.tag_name
 
class Classification(models.Model):
    name = models.CharField(max_length=20)
 
    def __unicode__(self):
        return self.name
 
class Author(models.Model):
    name = models.CharField(max_length=30)
    email = models.EmailField(blank=True)
    website = models.URLField(blank=True)
 
    def __unicode__(self):
        return u&#39;%s&#39; % (self.name)
 
class Article(models.Model):
    caption = models.CharField(max_length=30)
    subcaption = models.CharField(max_length=50,blank=True)
    publish_time = models.DateTimeField(auto_now_add=True)
    update_time = models.DateTimeField(auto_now = True)
    author = models.ForeignKey(Author)
    classification = models.ForeignKey(Classification)
    tags = models.ManyToManyField(Tag, blank=True)
    content = models.TextField()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们要做博客app,就要写文章,文章需要的一些基本信息,这里基本都涵盖了（标签,分类,作者信息,发布时间等）,当然也可以加入自己想要的表,&lt;/p&gt;

&lt;p&gt;保存退出,&lt;/p&gt;

&lt;p&gt;同步数据库,进入 manage.py 所在的文件夹，在终端输入下:&lt;/p&gt;

&lt;p&gt;注意：Django 1.7 及以上的版本需要用以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py makemigrations
python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：非Django 1.7 及以上的版本需要用以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py syncdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次同步数据库会让用户输入管理员帐号密码&lt;/p&gt;

&lt;p&gt;六,配置视图&lt;/p&gt;

&lt;p&gt;打开nameblog/blog/views.py&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from django.shortcuts import render
from blog.models import Article, Tag, Classification
from django.template import RequestContext
 
def blog_list(request):
    blogs = Article.objects.all().order_by(&#39;-publish_time&#39;)
    return render(request,&#39;index.html&#39;,{&quot;blogs&quot;:blogs})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里可以看到视图函数返回index.html,现在我们需要创建html首页&lt;/p&gt;

&lt;p&gt;七,创建模板首页&lt;/p&gt;

&lt;p&gt;模板在app中默认没有这个文件夹,需要手动创建blog/templates/*.html&lt;/p&gt;

&lt;p&gt;注意：文件最好放在blog/templates/下&lt;/p&gt;

&lt;p&gt;简单写点html欢迎代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
 
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;fank&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;欢迎光临xx的博客&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以显示博客页面了，但这是静态页面还用Django搭建起来未必太Low了吧?&lt;/p&gt;

&lt;p&gt;加上我们将会发布的博客文章&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
 
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;fank&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;欢迎光临xx的博客&amp;lt;/h1&amp;gt;
&amp;lt;div&amp;gt;

&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存退出.&lt;/p&gt;

&lt;p&gt;八,配置url&lt;/p&gt;

&lt;p&gt;现在我们重新启动项目&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py runserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会发现,还是萌萌哒Django欢迎界面,说好的博客app呢?!&lt;/p&gt;

&lt;p&gt;这是因为我们还没配置Url&lt;/p&gt;

&lt;p&gt;打开nameblog/nameblog/urls.py&lt;/p&gt;

&lt;p&gt;配置:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;urlpatterns = [
    url(r&#39;^admin/&#39;, include(admin.site.urls)),
    url(r&#39;^$&#39;,&#39;blog.views.blog_list&#39;,name=&#39;blog_list&#39;),
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候,再把项目跑起来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py runserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会发现,&lt;/p&gt;

&lt;p&gt;欢迎光临xx的博客&lt;/p&gt;

&lt;p&gt;成功了~&lt;/p&gt;

&lt;p&gt;九,美化网页&lt;/p&gt;

&lt;p&gt;没有css,js的网站不是好网站&lt;/p&gt;

&lt;p&gt;创建blog/static/images; blog/static/css; blog/static/js&lt;/p&gt;

&lt;p&gt;美化html,自己折腾吧,或者可以下载现成的模板,大家各有品味,这里就不上我的例子了&lt;/p&gt;

&lt;p&gt;注意:静态文件加载需要设置settings.py&lt;/p&gt;

&lt;p&gt;详情看我的另一篇博客&lt;a href=&quot;http://fankcoder.com/2016/01/20/add-static-django.html&quot;&gt;django添加静态文件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;收集静态文件,终端下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py collectstatic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次打开漂亮的首页,眼前一亮～&lt;/p&gt;

&lt;p&gt;十,Django后台&lt;/p&gt;

&lt;p&gt;博客app做好了,可是到现在一篇文章都木有啊&lt;/p&gt;

&lt;p&gt;Django给我们提供了一个强大的后台管理,我们通过它来管理文章&lt;/p&gt;

&lt;p&gt;打开blog/admin.py,没有则新建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from django.contrib import admin
from .models import Article
  
 
admin.site.register(Article)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只需要这三行代码，我们就可以拥有一个强大的后台！&lt;/p&gt;

&lt;p&gt;提示：urls.py中关于 admin的已经默认开启&lt;/p&gt;

&lt;p&gt;运行服务器,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python manage.py runserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问 http://localhost:8000/admin/ 输入设定的帐号和密码&lt;/p&gt;

&lt;p&gt;点击 Articles，动手输入 添加几篇文章,&lt;/p&gt;

&lt;p&gt;再访问首页&lt;/p&gt;

&lt;p&gt;发现文章出现在首页了~&lt;/p&gt;

&lt;p&gt;十一,代码托管到Github&lt;/p&gt;

&lt;p&gt;在nameblog/目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git init    //初始化

$ git add  ./

$ git commit -m &#39;first commit&#39;   //提交更新，并注释信息“first commit”

$ git remote add origin git@github.com:yourproject/nameblog.git   //连接远程github项目  

$ git push -u origin master   //将本地项目更新到github项目上去
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;:) 谢谢！&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>用xlrd\xlwt读写excel</title>
        <link>http://fankcoder.github.io//2015/05/22/xlrd-python.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/05/22/xlrd-python.html</guid>
        <pubDate>Fri, 22 May 2015 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;xlrdxlwt&quot;&gt;首先安装xlrd\xlwt模块&lt;/h3&gt;

&lt;p&gt;xlrd模块下载地址:&lt;/p&gt;

&lt;p&gt;https://pypi.python.org/pypi/xlrd&lt;/p&gt;

&lt;p&gt;xlwt模块下载地址:&lt;/p&gt;

&lt;p&gt;https://pypi.python.org/pypi/xlwt&lt;/p&gt;

&lt;p&gt;linux 安装命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;windos 安装命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;使用方法&lt;/h3&gt;

&lt;h4 id=&quot;xlrd&quot;&gt;xlrd&lt;/h4&gt;
&lt;p&gt;打开excel&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import xlrd
data = xlrd.open_workbook(&#39;demo.xls&#39;) #注意这里的workbook首字母是小写
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看文件中包含sheet的名称&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data.sheet_names()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到第一个工作表，或者通过索引顺序 或 工作表名称&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;table = data.sheets()[0]
table = data.sheet_by_index(0)
table = data.sheet_by_name(u&#39;Sheet1&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取行数和列数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nrows = table.nrows
ncols = table.ncols
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取整行和整列的值（数组）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;table.row_values(i)
table.col_values(i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;循环行,得到索引的列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for rownum in range(table.nrows):
print table.row_values(rownum)
#单元格
cell_A1 = table.cell(0,0).value
cell_C4 = table.cell(2,3).value
分别使用行列索引
cell_A1 = table.row(0)[0].value
cell_A2 = table.col(1)[0].value
#简单的写入
row = 0
col = 0
ctype = 1 # 类型 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error
value = &#39;lixiaoluo&#39;
xf = 0 # 扩展的格式化 (默认是0)
table.put_cell(row, col, ctype, value, xf)
table.cell(0,0) # 文本:u&#39;lixiaoluo&#39;
table.cell(0,0).value # &#39;lixiaoluo&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;xlwt&quot;&gt;xlwt&lt;/h4&gt;

&lt;p&gt;新建一个excel文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import xlwt
file = xlwt.Workbook() #注意这里的Workbook首字母是大写，无语吧
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建一个sheet&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;table = file.add_sheet(&#39;sheet name&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写入数据table.write(行,列,value)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;table.write(0,0,&#39;test&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果对一个单元格重复操作，会引发&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;returns error:
 Exception: Attempt to overwrite cell:
 sheetname=u&#39;sheet 1&#39; rowx=0 colx=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以需要在打开时加cell_overwrite_ok=True解决&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;table = file.add_sheet(&#39;sheet name&#39;,cell_overwrite_ok=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;file.save(&#39;demo.xls&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，使用style&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;style = xlwt.XFStyle() #初始化样式

font = xlwt.Font() #为样式创建字体

font.name = &#39;Times New Roman&#39;

font.bold = True

style.font = font #为样式设置字体

table.write(0, 0, &#39;some bold Times text&#39;, style) # 使用样式
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;linuxwindos&quot;&gt;Linux下保存用中文名保存正常,windos下坑爹乱码问题&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#coding:utf8

file.save(&#39;世界你好&#39;)#linux正常,win乱码

file.save(u&#39;世界你好&#39;.encode(&#39;GBK&#39;))# win正常
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>SEO 常用资源</title>
        <link>http://fankcoder.github.io//2015/02/13/general-seo-resources.html</link>
        <guid isPermaLink="true">http://fankcoder.github.io//2015/02/13/general-seo-resources.html</guid>
        <pubDate>Fri, 13 Feb 2015 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;小技巧&lt;/h2&gt;

&lt;h3 id=&quot;url-&quot;&gt;URL中用&lt;code&gt;-&lt;/code&gt;分割单词，用&lt;code&gt;_&lt;/code&gt;关联单词&lt;/h3&gt;

&lt;p&gt;Google 会把 &lt;code&gt;a-good_reource-of-seo.html&lt;/code&gt; 拆分成关键字：&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;good_resource&lt;/code&gt;, &lt;code&gt;of&lt;/code&gt; 和 &lt;code&gt;seo&lt;/code&gt;。&lt;/p&gt;
</description>
      </item>
    
  </channel>
</rss>